#!/bin/bash -e
source aurora_infra_settings.conf
source gc_helpers.sh
source ~/.aurora.conf

if [ -z ${gerritid+x} ]; then
  echo "ERROR: gerritid has not been defined. Please make sure to run aurora init. Exiting"
  exit
fi

# ***********************************************************************************
# Function: upload_to_docker_instance_name
# Purpose : wrapper for upload_to_docker to translate instance name to instance IP
# Usage   : upload_to_docker_instance_name <Cloud instance name where docker container is running>
#                            <Local file which needs to be uploaded>
#                            <path to destination directory>
# Prereq: Your laptop's key must be already in docker container before this operation
# ***********************************************************************************
function upload_to_docker_instance_name() {
  local INSTANCE_NAME="${gerritid_lower}-$1"
  local FILE=$2
  local DESTINATION=$3
  local INSTANCE_IP=$(get_instance_ip $INSTANCE_NAME)
  upload_to_docker "$INSTANCE_IP" "$FILE" "$DESTINATION"
}

# ***********************************************************************************
# Function: download_from_docker_instance_name
# Purpose : wrapper for download_from_docker to translate instance name to instance IP
# Usage   : download_from_instance_name <Cloud instance name where docker container is running>
#                            <Location of file which needs to be downloaded>
#                            <Local machine's path where you need to download>
# Prereq: Your laptop's key must be already in docker container before this operation
# ***********************************************************************************
function download_from_docker_instance_name() {
  local INSTANCE_NAME="${gerritid_lower}-$1"
  local FILE=$2
  local DESTINATION=$3
  local INSTANCE_IP=$(get_instance_ip $INSTANCE_NAME)
  download_from_docker "$INSTANCE_IP" "$FILE" "$DESTINATION"
}

# *****************************************************************************
# Function: list_instances
# Purpose : Lists the cloud instances currently running for the user.
# Usage   : list_instances
# Prereq: Aurora init has been called.
# *****************************************************************************
function list_instances() {
  echo "Listing instances for the user:$gerritid"
  local instance_list=$(gcloud compute instances list --format=text --sort-by=creationTimestamp  --regexp "${gerritid_lower}-.*" | sed -e "s/${gerritid_lower}-//g")
  local instance_names=($(echo "$instance_list" | grep '^name'))
  local instance_status=($(echo "$instance_list" | grep status))
  local instance_creationtime=($(echo "$instance_list" | grep creationTimestamp))
  local instance_internalip=($(echo "$instance_list" | grep "networkIP"))
  printf "%-35s %-30s %-20s %-20s\n" "Name" "Creation Time" "Internal IP" "Status"
  for (( i = 1 ; i < ${#instance_names[@]} ; i=i+2 )) do
    printf "%-35s %-30s %-20s %-20s\n" ${instance_names[$i]} ${instance_creationtime[$i]} ${instance_internalip[$i]} ${instance_status[$i]}
  done
  echo "------------------------------------------------"
}

# *****************************************************************************
# Function: list_snapshots
# Purpose : Lists the cloud instances currently running for the user.
# Usage   : list_instances
# Prereq: Aurora init has been called.
# *****************************************************************************
function list_snapshots() {
  echo "Listing snapshots for the user:$gerritid"
  local snapshot_list=$(gcloud compute snapshots list --format=text --sort-by=creationTimestamp --regexp "${gerritid_lower}-.*" | sed -e "s/${gerritid_lower}-//g")
  local snapshot_names=($(echo "$snapshot_list" | grep name))
  local snapshot_status=($(echo "$snapshot_list" | grep status))
  local snapshot_size=($(echo "$snapshot_list" | grep diskSizeGb))
  local snapshot_creationtime=($(echo "$snapshot_list" | grep creationTimestamp))
  printf "%-25s %-10s %-30s %-20s\n" "Name" "Size(GB)" "CreationTime" "Status"
  for (( i = 1 ; i < ${#snapshot_names[@]} ; i=i+2 )) do
    printf "%-25s %-10s %-30s %-20s\n" ${snapshot_names[$i]} ${snapshot_size[$i]} ${snapshot_creationtime[$i]} ${snapshot_status[$i]}
  done
  echo "------------------------------------------------"
}
# *****************************************************************************
# Function: list_buildids
# Purpose : Lists buildids running for the user by getting the snapshot list.
# Usage   : list_buildids
# Prereq: Aurora init has been called.
# *****************************************************************************
function list_buildids() {
  echo "Listing build-ids for the user:$gerritid"
  local snapshot_list=$(gcloud compute snapshots list --format=text --sort-by=creationTimestamp --regexp "${gerritid_lower}-.*-ssd2" | sed -e "s/${gerritid_lower}-bld-//g" | sed -e "s/-ssd2//g" )
  local snapshot_names=($(echo "$snapshot_list" | grep name))
  local snapshot_status=($(echo "$snapshot_list" | grep status))
  local snapshot_creationtime=($(echo "$snapshot_list" | grep creationTimestamp))
  printf "%-25s %-15s %-30s %-10s\n" "Refspec" "Build-id" "CreationTime" "Status"
  for (( i = 1 ; i < ${#snapshot_names[@]} ; i=i+2 )) do
    local refspec=$(echo "${snapshot_names[$i]}" | tr - \/)
    refspec="refs/changes/$refspec"
    printf "%-25s %-15s %-30s %-10s\n" "$refspec" "bld-${snapshot_names[$i]}" "${snapshot_creationtime[$i]}" "${snapshot_status[$i]}"
  done
  echo "------------------------------------------------"
}
# *****************************************************************************
# Function: list_runids
# Purpose : Lists the runids for the user by getting the instance list.
# Usage   : list_instances
# Prereq: Aurora init has been called.
# *****************************************************************************
function list_runids() {
  echo "Listing run-ids for the user:$gerritid"
  local instance_list=$(gcloud compute instances list --format=text --sort-by=creationTimestamp  --regexp "${gerritid_lower}-run-.*" | sed -e "s/${gerritid_lower}-//g")
  local instance_names=($(echo "$instance_list" | grep '^name'))
  local instance_status=($(echo "$instance_list" | grep status))
  printf "%-15s %-20s %-10s\n" "Run-id" "Build-id" "Status"
  for (( i = 1 ; i < ${#instance_names[@]} ; i=i+2 )) do
    local runid=$(echo ${instance_names[$i]} | grep -o '[^-]*$')
    local buildid=$(echo ${instance_names[$i]} | sed -e "s/run-/bld-/")
    buildid=${buildid%-$runid}
    printf "%-15s %-20s %-10s\n" ${runid} ${buildid} "${instance_status[$i]}"
  done
  echo "------------------------------------------------"
}
# *****************************************************************************
# Function: delete_instances
# Purpose : Deletes the cloud instances currently running for the user.
# Usage   : delete_user_instances
# Prereq: Aurora init has been called.
# *****************************************************************************
function delete_instances() {
  local REGEX=".*$1.*"
  local user_instances=$(gcloud compute instances list --regexp "${REGEX}" | grep ${gerritid_lower} | cut -d ' ' -f 1)

  # TODO: Print message if no instance matches with given criteria and exit
  echo "The following instances will be permanently deleted: "
  for instance in $user_instances; do
    echo "$instance"
  done

  if [ "$2" != "-f" -a "$2" != "--force" ]; then
    read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with delete..."
    else
      exit
    fi
  fi
  for instance in $user_instances; do
    gcloud compute instances delete $instance -q --delete-disks all
  done
}

# *****************************************************************************
# Function: delete_instances
# Purpose : Deletes the cloud instances currently running for the user.
# Usage   : delete_user_instances
# Prereq: Aurora init has been called.
# *****************************************************************************
function delete_snapshots() {
  local REGEX=".*$1.*"
  local user_snapshots=$(gcloud compute snapshots list --regexp "${REGEX}" | grep ${gerritid_lower} | cut -d ' ' -f 1)

  echo "The following instances will be permanently deleted: "
  for snapshot in $user_snapshots; do
    echo "$snapshot"
  done

  if [ "$2" != "-f" -a "$2" != "--force" ]; then
    read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with delete..."
    else
      exit
    fi
  fi
  for snapshot in $user_snapshots; do
    gcloud compute snapshots delete $snapshot -q
  done
}


# *****************************************************************************
# Function: login_instance
# Purpose : Logs into the insatance name provided.
# Usage   : login_instance <build-id>
# Prereq: The instance should exsist.
# *****************************************************************************
function login_instance() {
  local INSTANCE_NAME="${gerritid_lower}-$1"
  gcloud compute instances list ${INSTANCE_NAME} | grep "${INSTANCE_NAME}" || RESULT=$? &> /dev/null
  local INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
  if [[ $RESULT -ne 0 ]];then
    echo "INSTANCE ${INSTANCE_NAME} does not exist"
    show_login_help
    exit 1
  fi
  run_cmd_docker_sshforwarding ${INSTANCE_IP} "/bin/bash"
}

function run_aurora_build() {
  local REFSPEC=$1
  local PROJ=$2
  local BRANCH=$3
  local KEEP_RUNNING=$4
  local CONTINUE=$5
  local START_STEP=1
  local END_STEP=17

  #keep_running equalling 1 means -k was specified, end step should be 1 less.
  if [[ $KEEP_RUNNING == "1" ]]; then
      END_STEP=16
  fi

  local MOD_REFSPEC=$(echo "$REFSPEC" | tr / -)
  local MOD_BRANCH=$(echo "$BRANCH" | tr _ -)
  MOD_REFSPEC=${MOD_REFSPEC:13}

  #Append branch name if building without changes.
  if [[ $REFSPEC == "none" ]]; then
    local INSTANCE_NAME=${gerritid_lower}-bld-${MOD_BRANCH}
  else
    local INSTANCE_NAME=${gerritid_lower}-bld-${MOD_REFSPEC}
  fi
  local step_rec_file=$WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step
  #Validate Inputs
  check_build_inputs $PROJ $REFSPEC $BRANCH
  # If "continue" switch has been given then do following steps
  #   a. Get the last successfully completed step.
  #   b. Start the build process from step next to last completed step.
  if [[ $CONTINUE == "--continue" ]] ; then
    # Get the last successfull step from /tmp/${INSTANCE_NAME}-last-successful-step
    LAST_SUCCESSFULL_STEP=( $(<${step_rec_file}) )
    START_STEP=$((LAST_SUCCESSFULL_STEP+1))
  else
    check_instance_limit
  fi

  #Calulate total build time
  local start_time=$(date +%s)
  aurora_build.sh -Q build -R ${START_STEP} -E ${END_STEP} -G ${REFSPEC} -P ${PROJ} -B ${BRANCH} -I ${INSTANCE_NAME}
  local end_time=$(date +%s)
  print_time_taken $start_time $end_time "aurora build"
}

# *****************************************************************************
# Function: run_aurora_run
# Purpose : Starting an instance to run test script.
# Usage   : run_aurora_run <build-id> <test-script>
#           <flag to keep instance running> <Flag to skip automaton-init step>
#           <Log directory path> <continue an already proceeding run>
#           <RUNID which you want to continue>
# *****************************************************************************
function run_aurora_run() {
  local USER_BUILD_ID=$1
  local TEST_SCRIPT=$2
  local KEEP_RUNNING=$3
  local SKIP_AUTOMATON_INIT=$4
  local log_dir=$5
  local CONTINUE=$6
  local RUNID=$7

  local START_STEP=1
  local END_STEP=14
  local UUID=`uuidgen`
  local SUUID_="${UUID##*-}"
  SUUID="${SUUID_,,}"
  BUILD_ID=${gerritid_lower}-${USER_BUILD_ID}
  local INSTANCE_NAME=`echo ${BUILD_ID}-${SUUID} | sed 's/bld/run/'`
  local step_rec_file=$WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step

  #keep_running equalling 1 means -k was specified, end step should be 1 less.
  # TODO: Need to replace following code. Everytime, some new step gets added
  # or deleted, following value will need modification. High probability of miss.
  # We can define build and run steps in conf file and should start using those
  # values everywhere.
  if [[ $KEEP_RUNNING == "1" ]]; then
      END_STEP=13
  fi
  #Validate Inputs
  check_run_inputs $BUILD_ID $TEST_SCRIPT
  # If "continue" switch has been given then do following steps
  #   a. Get the RUN-ID provided by user.
  #   b. Get the last successfully completed step.
  #   c. Start the run process from step next to last completed step.
  if [[ $CONTINUE == "--continue" ]] ; then
    # User must give the run-id(SUUID generated during first time execution of run process.)
    # along with continue such that we can know that which "aurora run" he needs to resume.
    # TODO: Exit if user does not give the run-id.
    if [ -z ${RUNID+x} ]; then
      echo "Please provide the RUN-ID which you want to continue e.g. f82ba2b78256"
      exit
    fi
    INSTANCE_NAME=`echo ${BUILD_ID}-${RUNID} | sed 's/bld/run/'`
    local step_rec_file=/tmp/${INSTANCE_NAME}-last-successful-step
    LAST_SUCCESSFULL_STEP=( $(<${step_rec_file}) )
    START_STEP=$((LAST_SUCCESSFULL_STEP+1))
  else
    check_instance_limit
  fi
  #Calulate total run time
  local start_time=$(date +%s)
  aurora_run.sh -Q run -R ${START_STEP} -E ${END_STEP} -B ${BUILD_ID} -T ${TEST_SCRIPT} -U ${SUUID} -I ${INSTANCE_NAME} --skip-automaton-init ${SKIP_AUTOMATON_INIT} -o ${log_dir}
  local end_time=$(date +%s)
  print_time_taken $start_time $end_time "aurora run"
}
