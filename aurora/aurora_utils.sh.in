#!/bin/bash -e
source aurora_infra_settings.conf
source gc_helpers.sh
source ~/.aurora.conf
source pl_utils.sh
source help.sh

if [[ -z ${gerritid+x} || -z ${emailid+x}  ]]; then
  echo "ERROR: gerritid or emailid has not been defined. Please make sure to run aurora init. Exiting"
  exit
fi

# ***********************************************************************************
# Function: upload_using_instance_name
# Purpose : Upload a file to instance using his name.
# Usage   : upload_using_instance_name <Cloud instance name>
#                            <Local file which needs to be uploaded>
#                            <path to destination directory>
# ***********************************************************************************
function upload_using_instance_name() {
  if [[ $# -ne 3 ]]; then
    show_upload_help
    exit
  fi
  local INSTANCE_NAME="${emailid}-$1"
  local FILE=$2
  local DESTINATION=$3
  local INSTANCE_IP=$(get_instance_ip $INSTANCE_NAME)
  upload "$INSTANCE_IP" "$FILE" "$DESTINATION"
}

# ***********************************************************************************
# Function: download_using_instance_name
# Purpose : Download a file from cloud instance using his name.
# Usage   : download_from_instance_name <Cloud instance name>
#                            <Location of file which needs to be downloaded>
#                            <Local machine's path where you need to download>
# ***********************************************************************************
function download_using_instance_name() {
  if [[ $# -ne 3 ]]; then
    show_download_help
    exit
  fi
  local INSTANCE_NAME="${emailid}-$1"
  local FILE=$2
  local DESTINATION=$3
  local INSTANCE_IP=$(get_instance_ip $INSTANCE_NAME)
  download "$INSTANCE_IP" "$FILE" "$DESTINATION"
}

# *****************************************************************************
# Function: list_instances
# Purpose : Lists the cloud instances currently running for the user.
# Usage   : list_instances <emailid>
# Prereq: Aurora init has been called.
# *****************************************************************************
function list_instances() {
  local EMAILID=$1
  if [[ $EMAILID =~ ^.*\@plumgrid\.com$ ]];then
    local EMAILID=$(echo "$EMAILID" | sed 's/@plumgrid.com//')
    local EMAILID=${EMAILID,,}
  fi
  echo "Listing instances for the user:$EMAILID"
  local instance_list=$(gcloud compute instances list --format=text --sort-by=creationTimestamp  --regexp "${EMAILID}-.*" | sed -e "s/${EMAILID}-//g")
  local instance_names=($(echo "$instance_list" | grep '^name'))
  local instance_status=($(echo "$instance_list" | grep status))
  local instance_creationtime=($(echo "$instance_list" | grep creationTimestamp))
  local instance_internalip=($(echo "$instance_list" | grep "networkIP"))
  echo "-----------------------------------------------------------------------------------------"
  printf "%-30s %-30s %-20s %-20s\n" "Name" "Creation Time" "Internal IP" "Status"
  echo "-----------------------------------------------------------------------------------------"
  for (( i = 1 ; i < ${#instance_names[@]} ; i=i+2 )) do
    printf "%-30s %-30s %-20s %-20s\n" ${instance_names[$i]} ${instance_creationtime[$i]} ${instance_internalip[$i]} ${instance_status[$i]}
  done
  printf "\n"
}

# *****************************************************************************
# Function: list_snapshots
# Purpose : Lists the cloud instances currently running for the user.
# Usage   : list_snapshots <emailid>
# Prereq: Aurora init has been called.
# *****************************************************************************
function list_snapshots() {
  local EMAILID=$1
  if [[ $EMAILID =~ ^.*\@plumgrid\.com$ ]];then
    local EMAILID=$(echo "$EMAILID" | sed 's/@plumgrid.com//')
    local EMAILID=${EMAILID,,}
  fi
  echo "Listing snapshots for the user:$EMAILID"
  local snapshot_list=$(gcloud compute snapshots list --format=text --sort-by=creationTimestamp --regexp "${EMAILID}-.*" | sed -e "s/${EMAILID}-//g")
  local snapshot_names=($(echo "$snapshot_list" | grep name))
  local snapshot_status=($(echo "$snapshot_list" | grep status))
  local snapshot_size=($(echo "$snapshot_list" | grep diskSizeGb))
  local snapshot_creationtime=($(echo "$snapshot_list" | grep creationTimestamp))
  echo "---------------------------------------------------------------------------"
  printf "%-25s %-10s %-30s %-20s\n" "Name" "Size(GB)" "CreationTime" "Status"
  echo "---------------------------------------------------------------------------"
  for (( i = 1 ; i < ${#snapshot_names[@]} ; i=i+2 )) do
    printf "%-25s %-10s %-30s %-20s\n" ${snapshot_names[$i]} ${snapshot_size[$i]} ${snapshot_creationtime[$i]} ${snapshot_status[$i]}
  done
  printf "\n"
}
# *****************************************************************************
# Function: list_buildids
# Purpose : Lists buildids running for the user by getting the snapshot list.
# Usage   : list_buildids <emailid>
# Prereq: Aurora init has been called.
# *****************************************************************************
function list_buildids() {
  local EMAILID=$1
  if [[ $EMAILID =~ ^.*\@plumgrid\.com$ ]];then
    local EMAILID=$(echo "$EMAILID" | sed 's/@plumgrid.com//')
    local EMAILID=${EMAILID,,}
  fi
  echo "Listing build-ids for the user:$EMAILID"
  local snapshot_list=$(gcloud compute snapshots list --format=text --sort-by=creationTimestamp --regexp "${EMAILID}-.*-ssd2" | sed -e "s/${EMAILID}-//" | sed -e "s/-ssd2//g" )
  local snapshot_names=($(echo "$snapshot_list" | grep name))
  local snapshot_status=($(echo "$snapshot_list" | grep status))
  local snapshot_creationtime=($(echo "$snapshot_list" | grep creationTimestamp))
  echo "-----------------------------------------------------------------------------------------"
  printf "%-30s %-20s %-30s %-10s\n" "Build-id" "Refspec/Branch" "CreationTime" "Status"
  echo "-----------------------------------------------------------------------------------------"
  for (( i = 1 ; i < ${#snapshot_names[@]} ; i=i+2 )) do
    local refspec=$(echo "${snapshot_names[$i]}" | sed -e "s/.*bld-//g" )
    printf "%-30s %-20s %-30s %-10s\n" "${snapshot_names[$i]}" "$refspec" "${snapshot_creationtime[$i]}" "${snapshot_status[$i]}"
  done
  printf "\n"
}
# *****************************************************************************
# Function: list_runids
# Purpose : Lists the runids for the user by getting the instance list.
# Usage   : list_runids <emailid>
# Prereq: Aurora init has been called.
# *****************************************************************************
function list_runids() {
  local EMAILID=$1
  if [[ $EMAILID =~ ^.*\@plumgrid\.com$ ]];then
    local EMAILID=$(echo "$EMAILID" | sed 's/@plumgrid.com//')
    local EMAILID=${EMAILID,,}
  fi
  echo "Listing run-ids for the user:$EMAILID"
  local instance_list=$(gcloud compute instances list --format=text --sort-by=creationTimestamp  --regexp "${EMAILID}-.*run-.*" | sed -e "s/${EMAILID}-//g")
  local instance_names=($(echo "$instance_list" | grep '^name'))
  local instance_status=($(echo "$instance_list" | grep status))
  echo "--------------------------------------------------------------------"
  printf "%-15s %-40s %-10s\n" "Run-id" "Build-id-[Run-TAG]" "Status"
  echo "--------------------------------------------------------------------"
  for (( i = 1 ; i < ${#instance_names[@]} ; i=i+2 )) do
    local runid=$(echo ${instance_names[$i]} | grep -o '[^-]*$')
    local buildid=$(echo ${instance_names[$i]} | sed -e "s/run-/bld-/")
    buildid=${buildid%-$runid}
    printf "%-15s %-40s %-10s\n" ${runid} ${buildid} "${instance_status[$i]}"
  done
  printf "\n"
}
# *****************************************************************************
# Function: list_disks
# Purpose : Lists the disks without instances for the user.
# Usage   : list_disks <emailid>
# Prereq: Aurora init has been called.
# *****************************************************************************
function list_disks() {
  local EMAILID=$1
  if [[ $EMAILID =~ ^.*\@plumgrid\.com$ ]];then
    local EMAILID=$(echo "$EMAILID" | sed 's/@plumgrid.com//')
    local EMAILID=${EMAILID,,}
  fi
  echo "Listing disks for the user:$EMAILID"
  # Instances
  local instance_list=$(gcloud compute instances list --format=text --sort-by=creationTimestamp --regexp ".*" | grep ${EMAILID} | sed -e "s/${EMAILID}-//g")
  local instance_names=($(echo "$instance_list" | grep '^name'))
  local instances_str=${instance_names[1]}
  for (( i = 3; i < ${#instance_names[@]} ; i=i+2 )) do
    instances_str="$instances_str\|${instance_names[$i]}"
  done

  # Disks without instances
  local REGEX=".*${EMAILID}.*"

  if [[ -n $instances_str ]]; then
    local disk_list=$(gcloud compute disks list --format=text --sort-by=creationTimestamp --regexp "${REGEX}" | grep ${EMAILID} | sed -e "s/${EMAILID}-//g" | grep -v "$instances_str")
  else
    local disk_list=$(gcloud compute disks list --format=text --sort-by=creationTimestamp --regexp "${REGEX}" | grep ${EMAILID} | sed -e "s/${EMAILID}-//g")
  fi

  local disk_names=($(echo "$disk_list" | grep name))
  echo "------------------------------------------------"
  printf "%-35s %-20s\n" "Name"
  echo "------------------------------------------------"
  for (( i = 1 ; i < ${#disk_names[@]} ; i=i+2 )) do
    printf "%-35s\n" ${disk_names[$i]}
  done
  printf "\n"
}

# *****************************************************************************
# Function: start_instances
# Purpose : Starts the cloud instances currently shutdown for the user. Much like a laptop.
# Usage   : start_user_instances
# Prereq: Aurora init has been called. Aurora shutdown has been called.
# *****************************************************************************
function start_instances() {
  local REGEX=".*$1.*"
  local user_instances=$(gcloud compute instances list --regexp "${REGEX}" | grep ${emailid} | cut -d ' ' -f 1)

  if [[ -z ${user_instances} ]]; then
   echo "No such instances found"
   exit
  fi

  echo "The following instances will be started: "
  for instance in $user_instances; do
    echo "$instance"
  done

  if [ "$2" != "-f" -a "$2" != "--force" ]; then
    read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with startup..."
    else
      exit
    fi
  fi
  user_instances=$(echo "${user_instances}" | tr '\n' ' ')
  gcloud compute instances start $user_instances -q
}

# *****************************************************************************
# Function: shutdown_instances
# Purpose : Shuts down the cloud instances currently running for the user. Much like a laptop.
# Usage   : shutdown_user_instances
# Prereq: Aurora init has been called.
# *****************************************************************************
function shutdown_instances() {
  local REGEX=".*$1.*"
  local user_instances=$(gcloud compute instances list --regexp "${REGEX}" | grep ${emailid} | cut -d ' ' -f 1)

  if [[ -z ${user_instances} ]]; then
   echo "No such instances found"
   exit
  fi

  echo "The following instances will be shutdown: "
  for instance in $user_instances; do
    echo "$instance"
  done

  if [ "$2" != "-f" -a "$2" != "--force" ]; then
    read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with shutdown..."
    else
      exit
    fi
  fi
  user_instances=$(echo "${user_instances}" | tr '\n' ' ')
  gcloud compute instances stop $user_instances -q
}

# *****************************************************************************
# Function: delete_instances
# Purpose : Deletes the cloud instances currently running for the user.
# Usage   : delete_user_instances
# Prereq: Aurora init has been called.
# *****************************************************************************
function delete_instances() {
  local REGEX=$(echo "$1" | tr -d '*' ).*
  local user_instances=$(gcloud compute instances list --regexp "${emailid}-${REGEX}" | grep "^${emailid}.*" | cut -d ' ' -f 1)

  if [[ -z ${user_instances} ]]; then
   echo "No such instances found"
   return
  fi

  echo "The following instances will be permanently deleted: "
  for instance in $user_instances; do
    echo "$instance"
  done

  if [ "$2" != "-f" -a "$2" != "--force" ]; then
    read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with delete..."
    else
      exit
    fi
  fi
  user_instances=$(echo "${user_instances}" | tr '\n' ' ')
  gcloud compute instances delete $user_instances -q --delete-disks all
}

# *****************************************************************************
# Function: delete_snapshots
# Purpose : Deletes the cloud snapshots currently running for the user.
# Usage   : delete_user_snapshots
# Prereq: Aurora init has been called.
# *****************************************************************************
function delete_snapshots() {
  local REGEX=$(echo "$1" | tr -d '*' ).*
  local user_snapshots=$(gcloud compute snapshots list --regexp "${emailid}-${REGEX}" | grep "^${emailid}.*" | cut -d ' ' -f 1)

  if [[ -z ${user_snapshots} ]]; then
   echo "No such snapshots found"
   return
  fi

  echo "The following snapshots will be permanently deleted: "
  for snapshot in $user_snapshots; do
    echo "$snapshot"
  done

  if [ "$2" != "-f" -a "$2" != "--force" ]; then
    read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with delete..."
    else
      exit
    fi
  fi
  user_snapshots=$(echo "${user_snapshots}" | tr '\n' ' ')
  gcloud compute snapshots delete $user_snapshots -q
}
# *****************************************************************************
# Function: delete_disks
# Purpose : Deletes the disks currently running for the user.
# Usage   : delete_disks
# Prereq: Aurora init has been called.
# *****************************************************************************
function delete_disks() {
  local REGEX=$(echo "$1" | tr -d '*' ).*
  local user_disks=$(gcloud compute disks list --regexp "${emailid}-${REGEX}" | grep "^${emailid}.*" | cut -d ' ' -f 1)

  if [[ -z ${user_disks} ]]; then
   echo "No such disks found"
   return
  fi

  echo "The following disks will be permanently deleted: "
  for disk in $user_disks; do
    echo "$disk"
  done

  if [ "$2" != "-f" -a "$2" != "--force" ]; then
    read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with delete..."
    else
      exit
    fi
  fi
  user_disks=$(echo "${user_disks}" | tr '\n' ' ')
  gcloud compute disks delete $user_disks -q
}
# *****************************************************************************
# Function: set_max_instances
# Purpose : Changes the number of max instances allowed..
# Usage   : set_max_instances <max instances>
# Prereq:   aurora init has been called.
# *****************************************************************************
function set_max_instances() {
  local MAX_INSTANCES=$1
  if [[ "$MAX_INSTANCES" =~ ^[^0-9]+$ ]]; then
    echo "Number of instances should be a number"
    exit 1
  fi
  echo "Changing the maximum number of instances for user:${emailid} to $MAX_INSTANCES"
  sed -i "s/MAX_USER_INSTANCES=.*/MAX_USER_INSTANCES=$MAX_INSTANCES/" /home/$USER/.aurora.conf
}
# *****************************************************************************
# Function: login_instance
# Purpose : Logs into the insatance name provided.
# Usage   : login_instance <build-id>
# Prereq: The instance should exsist.
# *****************************************************************************
function login_instance() {
  if [[ $1 == "help" || -z $1 ]]; then
    show_login_help
    exit 1
  fi
  local INSTANCE_NAME="${emailid}-$1"
  local retval=$?
  gcloud compute instances list ${INSTANCE_NAME} | grep "${INSTANCE_NAME}" | grep "RUNNING" || retval=$?
  if [[ $retval -eq 0 ]]; then
    local INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
    run_cmd_gci_sshforwarding ${INSTANCE_IP} "/bin/bash"
  else
    echo "Instance not found or not running."
    exit 1
  fi
}
# *****************************************************************************
# Function: list_entities
# Purpose : Parses the options for aurora ls and calls the respective functions
# Usage   : list_entities <entity type>
# Prereq:   aurora init has been called.
# *****************************************************************************
function list_entities()
{
  if [[ $1 == "help" ]]; then
    show_ls_help
    exit 1
  fi

  if [[ -z "${gerritid}" || -z "${emailid}" ]]; then
    echo "gerritid or email not set, please run aurora init"
    exit 1
  fi

  local EMAILID=${2:-$emailid}
  case $1 in
    instances|"")
      list_instances $EMAILID;;
    snapshots)
      list_snapshots $EMAILID;;
    run)
      list_runids $EMAILID;;
    build)
      list_buildids $EMAILID;;
    disks)
      list_disks $EMAILID;;
    *)
      echo "Invalid entity for aurora ls"
      show_ls_help ;;
  esac
}

# *****************************************************************************
# Function: start_entities
# Purpose : Parses the options for aurora start and calls the respective functions
# Usage   : start_entities <entity type> <regex>
# Prereq:   aurora init has been called.
# *****************************************************************************
function start_entities()
{
  if [[ $1 == "help" || $# -lt 2 ]]; then
    show_start_help
    exit 1
  fi

  if [[ -z "${gerritid}" || -z "${emailid}"  ]]; then
    echo "gerritid or email not set, please run aurora init"
    exit 1
  fi

  case $1 in
    instances)
      start_instances $2 $3 ;;
    *)
      echo "Invalid entity for aurora start"
      show_start_help ;;
  esac
}

# *****************************************************************************
# Function: shutdown_entities
# Purpose : Parses the options for aurora shutdown and calls the respective functions
# Usage   : shutdown_entities <entity type> <regex>
# Prereq:   aurora init has been called.
# *****************************************************************************
function shutdown_entities()
{
  if [[ $1 == "help" || $# -lt 2 ]]; then
    show_shutdown_help
    exit 1
  fi

  if [[ -z "${gerritid}" || -z "${emailid}"  ]]; then
    echo "gerritid or email not set, please run aurora init"
    exit 1
  fi

  case $1 in
    instances)
      shutdown_instances $2 $3 ;;
    *)
      echo "Invalid entity for aurora shutdown"
      show_shutdown_help;;
  esac
}

# *****************************************************************************
# Function: delete_entities
# Purpose : Parses the options for aurora rm and calls the respective functions
# Usage   : delete_entities <entity type> <regex>
# Prereq:   aurora init has been called.
# *****************************************************************************
function delete_entities()
{
  if [[ $1 == "help" || $# -lt 2 ]]; then
    show_rm_help
    exit 1
  fi

  if [[ -z "${gerritid}" || -z "${emailid}"  ]]; then
    echo "gerritid or email not set, please run aurora init"
    exit 1
  fi

  case $1 in
    instances| run)
      delete_instances $2 $3 ;;
    snapshots| build)
      delete_snapshots $2 $3 ;;
    disks)
      delete_disks $2 $3;;
    *)
      echo "Invalid entity for aurora rm"
      show_rm_help;;
  esac
}

# *****************************************************************************
# Function: cp_entities
# Purpose : Copy an entity created by some other user
# Usage   : cp_entities <entity type> <entitiy_name> <optional_tag>
# *****************************************************************************
function cp_entities()
{
  if [[ $1 == "help" || $# -lt 2 ]]; then
    show_cp_help
    exit 1
  fi

  if [[ -z "${gerritid}" || -z "${emailid}"  ]]; then
    echo "gerritid or email not set, please run aurora init"
    exit 1
  fi

  case $1 in
    build)
      cp_build $2 $3 $4;;
    *)
      echo "Invalid entity for aurora cp"
      show_cp_help;;
  esac
}

# *****************************************************************************
# Function: run_debug_test
# Purpose : Parses the options for debug-test for local and non-local changes
# Usage   : run_debug_test <arguments>
# Prereq:   aurora init has been called.
# *****************************************************************************
function run_debug_test() {
echo "*** run_debug_test $@ ***"
  local TEMP=`getopt -o W:l:i:n:s:Ka:c:e:h --long WORKSPACE:,keep-running,buildid:,test_iterations:,num_instances:,script:,local_commit:,existing_commit_hash:,alps-path:,\help -n 'aurora.sh' -- "$@"`
eval set -- "$TEMP"

local TEST_ITERATIONS=1
local NUM_INSTANCES=1
local ALPS_PATH=/home/${USER}/work/alps
# extract options and their arguments into variables.
while true ; do
  case "$1" in
    -W| --WORKSPACE) export WORKSPACE=$2 ; shift 2 ;;
    -l|--buildid) BUILD_ID=$2 ; shift 2 ;;
    -i|--test_iterations) TEST_ITERATIONS=$2 ; shift 2 ;;
    -s|--script) USER_SCRIPT=$2 ; shift 2 ;;
    -n|--num_instances) NUM_INSTANCES=$2 ; shift 2 ;;
    -K|--keep-running) KEEP_RUNNING="-K" ; shift ;;
#Optional argments for local changes transfer
    -c|--local_commit) LOCAL_COMMIT_HASH=$2 ; shift 2 ;;
    -e|--existing_commit_hash) EXISTING_COMMIT_HASH=$2 ; shift 2 ;;
    -a|--alps-path) ALPS_PATH=$2 ; shift 2 ;;
    -h|--help)
      show_debug_test_help
      exit 0
      shift ;;
    --) shift ; break ;;
    *)
      echo "Unrecognized option $1"
       exit 1 ;;
  esac
done

if [[ -z "$BUILD_ID" || -z "$USER_SCRIPT"  ]]; then
  echo "Missing required arguments"
  show_debug_test_help
  exit 1
fi
check_file_existence "$USER_SCRIPT"

if [[ -n "$LOCAL_COMMIT_HASH" ]]; then
  #Check if ALPS_PATH is correct
  local retval=0
  git rev-parse --resolve-git-dir $ALPS_PATH/.git || retval=$?
  if [[ $retval != "0" ]]; then
    echo "Alps not found at :$ALPS_PATH"
    echo "Use the -a(--alps-path) to specify the path to alps"
    exit 1
  fi
  #Check if commit is correct
  local commit_check=$(git --git-dir $ALPS_PATH/.git --work-tree $ALPS_PATH cat-file -t $LOCAL_COMMIT_HASH)
  if [[ $commit_check != "commit" ]]; then
    echo "Not a valid commit. Please enter a valid commit."
    exit 1
  fi
    #Run with local changes
    run_pipelines.sh -P "DEBUG-TEST" --base_script_dir "@CMAKE_CURRENT_BINARY_DIR@/pipeline_scripts/alps/" -i $TEST_ITERATIONS -s $USER_SCRIPT\
 -n $NUM_INSTANCES -l $BUILD_ID -a $ALPS_PATH -c $LOCAL_COMMIT_HASH $KEEP_RUNNING
else
  #Run without local changes.
  # TODO: Output should be redirected to some file.
  echo "Running without local changes"
  run_pipelines.sh -P "DEBUG-TEST" --base_script_dir "@CMAKE_CURRENT_BINARY_DIR@/pipeline_scripts/alps/" -i $TEST_ITERATIONS\
  -s $USER_SCRIPT -n $NUM_INSTANCES -l $BUILD_ID -e ${EXISTING_COMMIT_HASH} $KEEP_RUNNING
fi
}

# *****************************************************************************
# Function: cp_build
# Purpose : Copy a particular build created by some other user.
# Usage   : cp_build <SRC_USER_EMAIL> <SRC_BUILD_ID> <Optional Tag>
# *****************************************************************************
function cp_build() {
  # SRC_BUILD_ID=lastlast-bld-stable-4-0 and SRC_USER_EMAIL=ahsanr@plumgrid.com
  # disk1=ahsanr-lastlast-bld-stable-4-0-d1   and disk2=ahsanr-lastlast-bld-stable-4-0-d2
  # ssd1 =ahsanr-lastlast-bld-stable-4-0-ssd1 and ssd2 =ahsanr-lastlast-bld-stable-4-0-ssd2
  # MY_TAG=final
  local SRC_USER_EMAIL=$1
  local SRC_BUILD_ID=$2
  local MY_TAG=$3


  local mod_src_user_email=${SRC_USER_EMAIL%@*}   # ahsanr
  local complete_src_build_id=${mod_src_user_email}-${SRC_BUILD_ID} # ahsanr-lastlast-bld-stable-4-0
  local mod_my_emailid=${emailid%@*}
  local my_build_id=""


    # if src has a tag
  if [[ $SRC_BUILD_ID =~ [[:alnum:]]+-bld ]]; then
    # pullout the tag name
    local SRC_TAG=`expr "$BASH_REMATCH" : '\(.*-\)'` #lastlast-
    # trim out the leading -
    SRC_TAG=${SRC_TAG%-} #lastlast

    #...and we have a tag as well
    if [[ "$MY_TAG" != "" ]]; then
      echo "replacing $SRC_TAG with $MY_TAG"
      my_build_id=${mod_my_emailid}-${SRC_BUILD_ID}
      my_build_id="${my_build_id/$SRC_TAG/$MY_TAG}" # tahir-final-bld-stable-4-0

    #..but we don't have a tag
    else
      echo "no new tag, copying $SRC_TAG as is"
      my_build_id=${mod_my_emailid}-${SRC_BUILD_ID} # tahir-lastlast-bld-stable-4-0
    fi

    # If src doesn't have a tag
  else
    #...and we have a tag
    if [[ "$MY_TAG" != ""  ]]; then
      echo "adding TAG: $MY_TAG to the bld name"
      my_build_id=${mod_my_emailid}-${MY_TAG}-${SRC_BUILD_ID} # tahir-final-bld-stable-4-0

    #...and neither do we
    else
      my_build_id=${mod_my_emailid}-${SRC_BUILD_ID} # tahir-bld-stable-4-0
    fi
  fi

  local my_disk1=${my_build_id}-d1
  local my_disk2=${my_build_id}-d2
  local my_ssd1=${my_build_id}-ssd1
  local my_ssd2=${my_build_id}-ssd2


  # TODO: Return if src build-id does not exist
  # *******************
  # Create disk from source snapshot
  # *******************
  echo "Create disk from source snapshot"
  exec_gcloud_cmd disks create "${my_disk1}" \
      --source-snapshot "${complete_src_build_id}-ssd1" --type "$DISK_TYPE" --size="$DISK1_SIZE" -q
  exec_gcloud_cmd disks create "${my_disk2}" \
      --source-snapshot "${complete_src_build_id}-ssd2" --type "$DISK_TYPE" --size="$DISK2_SIZE" -q

  # *******************
  # Create destination snapshot from disk
  # *******************
  echo "Create destination snapshot from disk"
  exec_gcloud_cmd disks snapshot ${my_disk2} --snapshot-names ${my_ssd2}
  exec_gcloud_cmd disks snapshot ${my_disk1} --snapshot-names ${my_ssd1}

  # *******************
  # Delete my intermediate disks
  # *******************
  echo "Deleting intermediate disks"
  exec_gcloud_cmd disks delete ${my_disk1} -q
  exec_gcloud_cmd disks delete ${my_disk2} -q
}
