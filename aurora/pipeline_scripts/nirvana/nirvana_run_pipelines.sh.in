#!/bin/bash -e
export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:/opt/pg/scripts/gcloud/aurora/pipeline_scripts/:$PATH
source /home/$USER/.aurora.conf
source pl_utils.sh
source pl_help.sh
source pl_settings.conf
source gc_helpers.sh

#Show help
if [[ $3 == "help" ]]; then
  show_pl_help
  exit 1
fi
BUILD_ENV_USER=${USER}
STEP_ST=1
STEP_ED=7
DEST_SCRIPT_DIR=0

echo "run_pipelines.sh $@"
ARGS=$@
# read the options
TEMP=`getopt -o W:p:l:P:b:s:n:e:i:\r:Kh --long WORKSPACE:,buildid:,existing_commit_hash:,project:,num_instances:,script:,pipeline:,branch:,test_iterations:,base_script_dir:,cost_pipeline_code:,keep-running,\help -n 'nirvana_run_pipelines.sh' -- "$@"`
eval set -- "$TEMP"

# extract options and their arguments into variables.
while true ; do
  case "$1" in
    -W| --WORKSPACE) export WORKSPACE=$2 ; shift 2 ;;
    -l|--buildid) USER_BUILD_ID=$2 ; shift 2 ;;
    -P|--pipeline) PIPELINE=$2 ; shift 2 ;;
    -p|--project) PROJECT=$2 ; shift 2 ;;
    -b|--branch) BRANCH=$2 ; shift 2 ;;
    -s|--script) USER_SCRIPT=$2 ; shift 2 ;;
    -i|--test_iterations) TEST_ITERATIONS=$2 ; shift 2 ;;
    -r|--base_script_dir) BASE_SCRIPT_DIR=$2 ; shift 2;;
    -n|--num_instances) NUM_INSTANCES=$2 ; shift 2 ;;
    -e|--existing_commit_hash) EXISTING_COMMIT_HASH=$2 ; shift 2 ;;
    --cost_pipeline_code) COST_CODE="$2" ; shift 2 ;;
    -K|--keep-running) KEEP_RUNNING="-K"; shift ;;
    -h|--help)
      show_run_tests_help
      exit 0
      shift ;;
    --) shift ; break ;;
    *)
      echo "Unrecognized option $1"
       exit 1 ;;
  esac
done

mkdir -p ${WORKSPACE}/logs
if [[ -z "$USER_BUILD_ID" ]]; then
  echo "Please supply required "--buildid" argument"
  show_run_tests_help
  exit 1
fi

BUILD_ID=${emailid}-${USER_BUILD_ID}
MOD_BUILD_ID=`echo ${BUILD_ID} | sed 's/bld/run/'`

if [[ $PIPELINE != "nirvana" && $PIPELINE != "DEBUG-TEST" ]]; then
  echo "Invalid Pipeline Specified"
  exit 1
fi

# TODO: log/untar_log directory is defined in two locations.
script_dir=$(get_script_dir $WORKSPACE $DEST_SCRIPT_DIR $PIPELINE $MOD_BUILD_ID)
log_dir=${script_dir}/logs
untar_log_dir=${script_dir}/untar_logs

echo "nirvana_run_pipelines.sh $ARGS" > $log_dir/aurora_pipeline_command

# Incase validate test stability is triggered
if [[ $PIPELINE == "DEBUG-TEST" ]]; then
  #Set the number of iterations
  TEST_ITERATIONS=$(set_iteration_count $PIPELINE $TEST_ITERATIONS)
  #Set the number of instances
  NUM_INSTANCES=$(set_instance_count $PIPELINE $NUM_INSTANCES)
else
  db=$(get_db $PIPELINE $BRANCH)
  if [[ -e $db ]]; then
    echo "database selected = $db"
  else
    echo "$db does not exist!"
    exit 1
  fi
fi

function run_test() {
  local step=$1

  case "$step" in
  1)
    # Generate scripts to be used by "aurora run"
    echo "Going to generate test scripts"
    if [[ $PIPELINE == "DEBUG-TEST" ]]; then
      echo "pipeline is debug-test"
      gen_user_tests.sh -b ${BASE_SCRIPT} -i ${TEST_ITERATIONS} -n ${NUM_INSTANCES} -d ${script_dir} --base_script_dir ${BASE_SCRIPT_DIR} -s ${USER_SCRIPT}
    else
      echo "Copying base test"
      cp ${BASE_SCRIPT_DIR}/$BASE_SCRIPT ${script_dir}/${BASE_SCRIPT}-1
    fi
    ;;

  2)
    pids=()
    echo "log_dir=$log_dir script_dir=$script_dir"
    while read -r -d $'\0'; do
      aurora run -l ${USER_BUILD_ID} -o ${log_dir} -s $REPLY --cost_pipeline_code ${COST_CODE} $KEEP_RUNNING -S /opt/pg/ > $REPLY.txt 2>&1 &
      #Get the pid of the last background command
      pids+=("$!")
    done < <(find ${script_dir} -regextype posix-extended  -regex '^.*.sh-[0-9]+$' -print0)
    sleep 30
    ;;

  3)
    pipeline_start_time=$(date +%s)
    echo "Waiting for command to finish ..."
    # Background loop to print the number of aurora_run processes
    while [[ ! -z `pgrep -f "run -l ${USER_BUILD_ID} -o ${log_dir}"` ]]; do
      echo -n "[`pgrep -f \"run -l ${USER_BUILD_ID} -o ${log_dir}\" | wc -l`] ";
      sleep 60 ;
    done &
    echoer_pid=$!
    FAIL=0
    for pid in "${pids[@]}"; do
      wait "$pid" || FAIL=$(($? + $FAIL))
    done
    pipeline_end_time=$(date +%s)
    #Exit if any value is nonzero
    if [[ $FAIL != 0 ]]; then
      #Kill the echo while loop, suppress output
      disown $echoer_pid && kill $echoer_pid
      #Copy the aurora_run logs.
      for file in `ls ${script_dir}/*.txt` ; do
        grep "Run has been completed successfully" $file > /dev/null || cp $file "$WORKSPACE/logs/AURORA.RUN.FAILED.`basename ${file}`"
      done
      echo "Some aurora runs exited unsuccesfully."
      status=1
    else
      #Kill the echo while loop, suppress output
      disown $echoer_pid && kill $echoer_pid
      echo "Aurora run completed successfully."
    fi
    ;;

  4)
    # Start collecting logs
    echo "Copying all logs to ${WORKSPACE}/logs directory"
    find ${log_dir} -name "*${MOD_BUILD_ID}*.tar" -type f -exec tar xf {} -C ${untar_log_dir} \; -exec rm {} \;
    ;;

  5)
    # Generate failed test case report.
    num_failures=$(get_failing_test_number ${untar_log_dir})
    echo "num_failures=$num_failures"
    #Get total tests ran
    local num_total_tests=$(get_total_tests_run ${untar_log_dir})
    echo "Total number of tests run = $num_total_tests"

    if [[ $num_total_tests -eq 0 ]]; then
      status=1
      echo "No tests were run"
    fi

    time_taken=$(print_time_taken $pipeline_start_time $pipeline_end_time "running $PIPELINE pipeline")
    #Create Reports for builder
    generate_status_report "$PIPELINE" "$num_failures" "$num_total_tests" "$time_taken" "${WORKSPACE}/aurora-pipeline-status"
    generate_failing_list "${untar_log_dir}" "${WORKSPACE}/logs/failing-list.log"
    ;;

  6)
    generate_ctest_output ${untar_log_dir} ${WORKSPACE}/logs/ctest_output.log
    if [[ -e ${WORKSPACE}/logs/ctest_output.log ]]; then
      pushd ${WORKSPACE}/logs
      gzip ctest_output.log
      popd
    fi
    ;;
  7)
    generate_test_directories ${untar_log_dir} ${WORKSPACE}/test_logs

    mv ${WORKSPACE}/test_logs  ${WORKSPACE}/logs
    tar czf $script_dir.tar.gz -C $WORKSPACE/ ${script_dir#$WORKSPACE/}
    mv $script_dir.tar.gz ${WORKSPACE}/logs/aurora_infra_logs.tar.gz
    echo "Finishing up ..."
    if [[ $num_failures -eq 0 && -z $status ]]; then
      status=0
    else
      status=1
    fi

    rm -rf $script_dir
    return $status
    ;;


  *)
    echo "NOP - $step"
  ;;
  esac
}

script_start_time=$(date +%s)
for STEP in `seq ${STEP_ST} ${STEP_ED}`; do
  printf "\n    === Starting STEP $STEP === \n"
  start_time=$(date +%s)
  run_test $STEP
  end_time=$(date +%s)
  print_time_taken $start_time $end_time "[$STEP]"
done
script_end_time=$(date +%s)
print_time_taken $script_start_time $script_end_time "[RUN]"
