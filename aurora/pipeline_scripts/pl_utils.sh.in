#!/bin/bash -e
source pl_settings.conf
source ~/.aurora.conf
. gc_helpers.sh

function get_db() {
  local pipeline=$1
  local branch=$2
  if [[ -n "$branch" ]]; then
    local db="${DB_PATH}$pipeline-$branch.db"
  fi
  if [[ -e "$db" ]]; then
    echo ${db}
    return 0
  fi
  if [[ $pipeline == "smoke" ]]; then
    db=${SMOKE_DB}
  elif [[ $pipeline == "corelib-smoke" ]]; then
    db=${CORELIB_SMOKE_DB}
  elif [[ $pipeline == "extended" ]]; then
    db=${EXTENDED_DB}
  elif [[ $pipeline == "unstable" ]]; then
    db=${UNSTABLE_DB}
  elif [[ $pipeline == "pgui-smoke" ]]; then
    db=${PGUI_SMOKE_DB}
  elif [[ $pipeline == "omni" ]]; then
    db=${OMNI_DB}
  elif [[ $pipeline == "pgui-extended" ]]; then
    db=${PGUI_EXTENDED_DB}
  else
    echo "Unknown Pipeline"
    return 1
  fi
  echo ${db}
}

function get_script_dir() {
  local workspace=$1
  local script_dir=$2
  local pipeline=$3
  local mod_build_id=$4
  local timestamp=$(date +%Y_%m_%d_%H_%M_%S)

  if [[ ${script_dir} == "0" ]]; then
    script_dir="$workspace/${pipeline}-${mod_build_id}"
    mkdir -p $script_dir/logs
    mkdir -p $script_dir/untar_logs
  else
    script_dir=$script_dir
  fi
  echo $script_dir
}

# *****************************************************************************
# Function: remove_test_from_db
# Purpose : Removes a test case from the database
# Usage   : remove_test_from_db <DB Path> <Name of Table in DB> <test name>
# *****************************************************************************
function remove_test_from_db() {
  local TESTS_DB=$1
  local TESTS_TABLE=$2
  local TEST_NAME=$3

  sqlite3 $TESTS_DB "DELETE FROM $TESTS_TABLE WHERE name='$TEST_NAME';"
}

# *****************************************************************************
# Function: add_new_tests_to_db
# Purpose : Adds a test case to the database if it does not exist already.
# Usage   : add_new_failing_tests_to_db <DB Path> <test name>
# *****************************************************************************
function add_new_tests_to_db() {
  local TESTS_DB=$1
  local test_name=$2
  local tag=$3
  local time=$(date +%s)

  if [[ "$tag" == "failing" ]]; then
    local exists=$(sqlite3 $TESTS_DB "SELECT EXISTS(SELECT 1 FROM $FAILING_TESTS_TABLE WHERE name='$test_name' LIMIT 1);")
    if [[ $exists != "1" ]]; then
      echo "New failure:$test_name"
      sqlite3 $TESTS_DB "insert into $FAILING_TESTS_TABLE (Name, FailureProb, FirstOccurence) values ('$test_name', '0', '$time')"
    fi
  elif [[ "$tag" == "unstable" ]]; then
    local exists=$(sqlite3 $TESTS_DB "SELECT EXISTS(SELECT 1 FROM $UNSTABLE_TESTS_TABLE WHERE name='$test_name' LIMIT 1);")
    if [[ $exists != "1" ]]; then
      echo "New failure:$test_name"
      sqlite3 $TESTS_DB "insert into $UNSTABLE_TESTS_TABLE (Name, FailureProb, FirstPassingOccurence) values ('$test_name', '0', '$time')"
    fi
  fi
}

# *****************************************************************************
# Function: update_failing_tests_prob
# Purpose : Updates the database with the new failure probablity for a given test.
# Usage   : update_failing_tests_prob <DB Path> <test name> <failure probability>
# *****************************************************************************
function update_failing_tests_prob() {
  local FAILING_TESTS_DB=$1
  local test_name=$2
  local failure_prob=$3
  local curr_time=$(date +%s)

  #If the probability of failure was less than 10 previously, First
  #occurance should be updated when the test started failing.
  local old_failure_prob=$(sqlite3 $FAILING_TESTS_DB "SELECT FailureProb from $FAILING_TESTS_TABLE WHERE name='$test_name';")
  sqlite3 $FAILING_TESTS_DB "UPDATE $FAILING_TESTS_TABLE SET FailureProb='$failure_prob' WHERE name='$test_name';"
  #exists=$(sqlite3 $FAILING_TESTS_DB "SELECT EXISTS(SELECT 1 FROM $FAILING_TESTS_TABLE WHERE name='$test_name' LIMIT 1);")
  if [[ $old_failure_prob -lt 10 && $failure_prob -ge 10 ]]; then
    #Update the failing since field
    sqlite3 $FAILING_TESTS_DB "UPDATE $FAILING_TESTS_TABLE SET FirstOccurence='$curr_time' WHERE name='$test_name';"
  fi
}

# *****************************************************************************
# Function: update_passing_tests_prob
# Purpose : Updates the database with the new failure probablity for a given test.
# Usage   : update_passing_tests_prob <DB Path> <test name> <failure probability>
# *****************************************************************************
function update_passing_tests_prob() {
  local UNSTABLE_TESTS_DB=$1
  local test_name=$2
  local failure_prob=$3
  local curr_time=$(date +%s)

  # The first occurrence should be the first time the test starts to pass 100/100 iterations. If a test passes the first day and fails
  # the next day, the first occurrence should be the next time the test passes 100/100 iterations.
  local old_failure_prob=$(sqlite3 $UNSTABLE_TESTS_DB "SELECT FailureProb from $UNSTABLE_TESTS_TABLE WHERE name='$test_name';")
  sqlite3 $UNSTABLE_TESTS_DB "UPDATE $UNSTABLE_TESTS_TABLE SET FailureProb='$failure_prob' WHERE name='$test_name';"
  if [[ $old_failure_prob -gt 0 && $failure_prob -eq 0 ]]; then
    #Update the failing since field
    sqlite3 $UNSTABLE_TESTS_DB "UPDATE $UNSTABLE_TESTS_TABLE SET FirstPassingOccurence='$curr_time' WHERE name='$test_name';"
  fi
}

# *****************************************************************************
# Function: check_flag_inputs
# Purpose : Checks the inputs given to aurora flag.
# Usage   : check_flag_inputs <build-id> <test-list> <test iterations> <num instances>
#                              <branch>
# *****************************************************************************
function check_flag_inputs() {
  local build_id=$1
  local test_iterations=$2
  local num_instances=$3
  local branch=$4

  #Check build-id exists
  check_run_inputs ${emailid}-$build_id

  #Verify iterations and num_instances are numbers
  re='^[0-9]+$'
  if ! [[ $test_iterations =~ $re ]] ; then
    echo "test_iterations is not a number, exiting."
    exit 1
  fi

  if ! [[ $num_instances =~ $re ]] ; then
    echo "num_instances is not a number, exiting."
    exit 1
  fi

  #Verify input Branch
  local RESULT=0
  git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/alps "${branch}" | grep -q "${branch}" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Branch: $branch does not exist for the project: alps"
    exit 1
  fi



}
