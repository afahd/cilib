#!/bin/bash -e
source pl_settings.conf
source ~/.aurora.conf
. gc_helpers.sh

function get_db() {
  local pipeline=$1
  local branch=$2
  if [[ -n "$branch" ]]; then
    local db="${DB_PATH}$pipeline-$branch.db"
    if [[ -e "$db" ]]; then
      echo ${db}
      return 0
    fi
  fi

  if [[ -n "${PIPELINE_DB[$pipeline]}" ]]; then
    echo ${PIPELINE_DB[$pipeline]}
  else
    echo "Unknown Pipeline"
    return 1
  fi
}

function get_script_dir() {
  local workspace=$1
  local script_dir=$2
  local pipeline=$3
  local mod_build_id=$4
  local timestamp=$(date +%Y_%m_%d_%H_%M_%S)

  if [[ ${script_dir} == "0" ]]; then
    script_dir="$workspace/${pipeline}-${mod_build_id}"
    mkdir -p $script_dir/logs
    mkdir -p $script_dir/untar_logs
  else
    script_dir=$script_dir
  fi
  echo $script_dir
}

# *****************************************************************************
# Function: remove_test_from_db
# Purpose : Removes a test case from the database
# Usage   : remove_test_from_db <DB Path> <Name of Table in DB> <test name>
# *****************************************************************************
function remove_test_from_db() {
  local TESTS_DB=$1
  local TESTS_TABLE=$2
  local TEST_NAME=$3

  sqlite3 $TESTS_DB "DELETE FROM $TESTS_TABLE WHERE name='$TEST_NAME';"
}

# *****************************************************************************
# Function: add_new_tests_to_db
# Purpose : Adds a test case to the database if it does not exist already.
# Usage   : add_new_failing_tests_to_db <DB Path> <test name>
# *****************************************************************************
function add_new_tests_to_db() {
  local TESTS_DB=$1
  local test_name=$2
  local tag=$3
  local time=$(date +%s)

  if [[ "$tag" == "failing" ]]; then
    local exists=$(sqlite3 $TESTS_DB "SELECT EXISTS(SELECT 1 FROM $FAILING_TESTS_TABLE WHERE name='$test_name' LIMIT 1);")
    if [[ $exists != "1" ]]; then
      echo "New failure:$test_name"
      sqlite3 $TESTS_DB "insert into $FAILING_TESTS_TABLE (Name, FailureProb, FirstOccurence) values ('$test_name', '0', '$time')"
    fi
  elif [[ "$tag" == "unstable" ]]; then
    local exists=$(sqlite3 $TESTS_DB "SELECT EXISTS(SELECT 1 FROM $UNSTABLE_TESTS_TABLE WHERE name='$test_name' LIMIT 1);")
    if [[ $exists != "1" ]]; then
      echo "New failure:$test_name"
      sqlite3 $TESTS_DB "insert into $UNSTABLE_TESTS_TABLE (Name, FailureProb, FirstPassingOccurence) values ('$test_name', '0', '$time')"
    fi
  fi
}

# *****************************************************************************
# Function: update_failing_tests_prob
# Purpose : Updates the database with the new failure probablity for a given test.
# Usage   : update_failing_tests_prob <DB Path> <test name> <failure probability>
# *****************************************************************************
function update_failing_tests_prob() {
  local FAILING_TESTS_DB=$1
  local test_name=$2
  local failure_prob=$3
  local curr_time=$(date +%s)

  #If the probability of failure was less than 10 previously, First
  #occurance should be updated when the test started failing.
  local old_failure_prob=$(sqlite3 $FAILING_TESTS_DB "SELECT FailureProb from $FAILING_TESTS_TABLE WHERE name='$test_name';")
  sqlite3 $FAILING_TESTS_DB "UPDATE $FAILING_TESTS_TABLE SET FailureProb='$failure_prob' WHERE name='$test_name';"
  #exists=$(sqlite3 $FAILING_TESTS_DB "SELECT EXISTS(SELECT 1 FROM $FAILING_TESTS_TABLE WHERE name='$test_name' LIMIT 1);")
  if [[ $old_failure_prob -lt 10 && $failure_prob -ge 10 ]]; then
    #Update the failing since field
    sqlite3 $FAILING_TESTS_DB "UPDATE $FAILING_TESTS_TABLE SET FirstOccurence='$curr_time' WHERE name='$test_name';"
  fi
}

# *****************************************************************************
# Function: update_passing_tests_prob
# Purpose : Updates the database with the new failure probablity for a given test.
# Usage   : update_passing_tests_prob <DB Path> <test name> <failure probability>
# *****************************************************************************
function update_passing_tests_prob() {
  local UNSTABLE_TESTS_DB=$1
  local test_name=$2
  local failure_prob=$3
  local curr_time=$(date +%s)

  # The first occurrence should be the first time the test starts to pass 100/100 iterations. If a test passes the first day and fails
  # the next day, the first occurrence should be the next time the test passes 100/100 iterations.
  local old_failure_prob=$(sqlite3 $UNSTABLE_TESTS_DB "SELECT FailureProb from $UNSTABLE_TESTS_TABLE WHERE name='$test_name';")
  sqlite3 $UNSTABLE_TESTS_DB "UPDATE $UNSTABLE_TESTS_TABLE SET FailureProb='$failure_prob' WHERE name='$test_name';"
  if [[ $old_failure_prob -gt 0 && $failure_prob -eq 0 ]]; then
    #Update the failing since field
    sqlite3 $UNSTABLE_TESTS_DB "UPDATE $UNSTABLE_TESTS_TABLE SET FirstPassingOccurence='$curr_time' WHERE name='$test_name';"
  fi
}

# *****************************************************************************
# Function: check_flag_inputs
# Purpose : Checks the inputs given to aurora flag.
# Usage   : check_flag_inputs <build-id> <test-list> <test iterations> <num instances>
#                              <branch>
# *****************************************************************************
function check_flag_inputs() {
  local build_id=$1
  local test_iterations=$2
  local num_instances=$3
  local branch=$4

  #Check build-id exists
  check_run_inputs ${emailid}-$build_id

  #Verify iterations and num_instances are numbers
  re='^[0-9]+$'
  if ! [[ $test_iterations =~ $re ]] ; then
    echo "test_iterations is not a number, exiting."
    exit 1
  fi

  if ! [[ $num_instances =~ $re ]] ; then
    echo "num_instances is not a number, exiting."
    exit 1
  fi

  #Verify input Branch
  local RESULT=0
  git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/alps "${branch}" | grep -q "${branch}" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Branch: $branch does not exist for the project: alps"
    exit 1
  fi
}

# *****************************************************************************
# Function: get_total_tests_run
# Purpose : Returns the number of tests run by adding files from each instance
#           in a given directory.
# Usage   : get_total_tests_run <Path to downloaded logs>
# *****************************************************************************
function get_total_tests_run() {
  local log_dir=$1

  local test_count=$(find ${log_dir} -name "total_tests_inst*" -type f)
  #Get total tests ran
  local num_total_tests=0
  for file in ${test_count[@]}; do
    num_total_tests=$((`cat $file`+$num_total_tests))
  done

  echo "$num_total_tests"
}

# *****************************************************************************
# Function: collect_xml_logs
# Purpose : Collects generated XML logs to a target directory. Multiple iterations
#           of a test are treated as a single test. Failing tests take precedence.
# Usage   : collect_xml_logs <source log directory> <Output directory>
# *****************************************************************************
function collect_xml_logs() {
  if [[ $# -ne '2' ]]; then
    echo "Wrong number of argument \"$#\" passed, exiting."
    exit 1
  fi

  local source_dir=$1
  local target_dir=$2

  mkdir -p ${target_dir}
  #Replace the '.FAILED' for the failing logs so failing logs take precedence
  find ${source_dir} -type f -name "*FAILED.xml" -exec  rename -f 's/.FAILED.xml/.xml/' '{}' \;
  #Copy the xml logs
  find ${source_dir} -type f -name "*.xml" -exec mv {} ${target_dir} \;

}

# *****************************************************************************
# Function: get_failing_test_number
# Purpose : Returns the number of failing tests in a given directory.
# Usage   : get_failing_test_number <Log dir>
# *****************************************************************************
function get_failing_test_number() {
  local log_dir=$1
  echo "$(find ${log_dir} -name "*FAILED.log" | wc -l)"
}


# *****************************************************************************
# Function: generate_status_report
# Purpose : Generates the status report file for builder to consume
# Usage   : generate_status_report <Pipeline name> <Number of failures> <Total tests ran>
#           <Time taken> <Output file>
# *****************************************************************************
function generate_status_report() {

  if [[ $# -ne '5' ]]; then
    echo "Wrong number of argument \"$#\" passed, exiting."
    exit 1
  fi

  local pipeline=$1
  local num_failures=$2
  local total_tests=$3
  local time_taken=$4
  local output_file=$5

  # Write to status file in case of failures
  if [[ ${num_failures} -gt 0 ]]; then
    cat /dev/null > ${output_file}
    #Write status for builder script
    echo "$pipeline,$time_taken,${num_failures},$total_tests" > ${output_file}
  fi
}

# *****************************************************************************
# Function: generate_failing_list
# Purpose : Generates the list of tests failing in the run from a given folder
#           to be consumed by builder
# Usage   : generate_failing_list <log dir> <Output file>
# *****************************************************************************
function generate_failing_list() {

  if [[ $# -ne '2' ]]; then
    echo "Wrong number of argument \"$#\" passed, exiting."
    exit 1
  fi

  local log_dir=$1
  local output_file=$2

  cat /dev/null > ${output_file}

  local failed_list=$(find ${log_dir} -name "*FAILED.log")
  local num_failures=$(get_failing_test_number $log_dir)

  if [[ ${num_failures} -gt 0 ]]; then
    for test_name in ${failed_list[@]}; do
      test_name=$(basename "$test_name")
      test_name=$(echo "$test_name" | sed 's/ctestout_inst.*_iter[0-9]\+_//' | sed 's/.FAILED.log//' )
      echo "$test_name" >> "${output_file}"
    done
  fi
}

# *****************************************************************************
# Function: generate_ctest_output
# Purpose : Concatenates and outputs the ctest logs
# Usage   : generate_ctest_output <log dir> <Output file>
# *****************************************************************************
function generate_ctest_output() {
  if [[ $# -ne '2' ]]; then
    echo "Wrong number of argument \"$#\" passed, exiting."
    exit 1
  fi

  local log_dir=$1
  local output_file=$2

  #Concatenate all the log files into one file
  for log_file in `find ${log_dir} -type f -name "*.log"` ; do
      cat $log_file >>  ${output_file}
      echo "--------------------------------------" >> ${output_file}
  done
}

# *****************************************************************************
# Function: generate_test_directories
# Purpose : Places the failing tests and related files in their seperate folders.
# Usage   : generate_test_directories <log dir> <Output dir>
# *****************************************************************************
function generate_test_directories() {
  if [[ $# -ne '2' ]]; then
    echo "Wrong number of argument \"$#\" passed, exiting."
    exit 1
  fi

  local log_dir=$1
  local out_dir=$2

  #Make the output directory
  mkdir -p ${out_dir}

  # find all the failed files and copy them to the output directory
  for file in `find ${log_dir} -type f -name "*FAILED.log" -o -type f -name "*.tar.gz"`; do
    base_test_name=`basename $file`
    #Remove the instance number, iteration number and extension
    pretty_test_name=$(echo "$base_test_name" | sed 's/ctestout_inst.*_iter[0-9]\+_//' | sed 's/.FAILED.log//' | sed 's/.tar.gz//')
    mkdir -p ${out_dir}/$pretty_test_name
    cp $file ${out_dir}/$pretty_test_name/$base_test_name
  done
}
# *****************************************************************************
# Function: set_instance_count
# Purpose : Returns the number of instances for a given pipeline.
# Usage   : set_instance_count <pipeine name> <over-ride value>
# *****************************************************************************
function set_instance_count() {

  local pipeline_name=$1
  local override_value=$2
  local instance_count
  #Set the number of instances
  if [[ -z "$override_value" ]]; then
    #Change number instances
    if [[ -n ${INSTANCE_COUNT[$PIPELINE]} ]]; then
      instance_count=${INSTANCE_COUNT[$PIPELINE]}
    else
      instance_count=${INSTANCE_COUNT['default']}
    fi
  else
      instance_count=$override_value
  fi
  echo "$instance_count"
  echo "Num Instances = $instance_count" >&2
}


# *****************************************************************************
# Function: set_iteration_count
# Purpose : Returns the number of iterations for a given pipeline.
# Usage   : set_iteration_count <pipeine name> <over-ride value>
# *****************************************************************************
function set_iteration_count() {

  local pipeline_name=$1
  local override_value=$2
  local iteration_count
  #Set the number of instances
  if [[ -z "$override_value" ]]; then
    #Change number instances
    if [[ -n ${ITERATION_COUNT[$PIPELINE]} ]]; then
      iteration_count=${ITERATION_COUNT[$PIPELINE]}
    else
      iteration_count=${ITERATION_COUNT['default']}
    fi
  else
      iteration_count=$override_value
  fi
  echo "$iteration_count"
  echo "Num Iterations = $iteration_count" >&2
}
