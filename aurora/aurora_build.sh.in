#!/bin/bash -e
source help.sh

export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
echo "aurora_build.sh started with [aurora_build.sh  $@]"
ARGS=$@
. gc_helpers.sh
. aurora_utils.sh
source aurora_infra_settings.conf
source /home/$USER/.aurora.conf


#Show help
if [[ $1 == "help" ]]; then
  show_build_help
  exit 1
fi
# TODO: Make a decision about machine type and Disk sizes.

BRANCH=""
REFSPEC="none"
TAG="none"
PROJECT=""

declare -A MINOR_STEPS_ST
declare -A MINOR_STEPS_ED
MAJOR_STEPS="build"
MINOR_STEPS_ST[build]=1
MINOR_STEPS_ED[build]=22

CONTINUE=0

# read the options
TEMP=`getopt -o Kr:t:Cb:p:W:Q:R:E:Oh --long keep-running,refspec:,WORKSPACE:,tag:,\continue,branch:,proj:,stop,help,major:,minor_st:,minor_end: -n 'aurora.sh' -- "$@"`
eval set -- "$TEMP"
while true ; do
  case "$1" in
     -K| --keep-running ) KEEP_RUNNING=1; shift ;;
     -r| --refspec) REFSPEC=$2; shift 2 ;;
     -t| --tag) TAG=$2 ; shift 2 ;;
     -C| --continue) CONTINUE=1 ; shift ;;
     -b|--branch) BRANCH=$2; shift 2 ;;
     -p|--proj) PROJECT=$2; shift 2 ;;
     -W| --WORKSPACE) export WORKSPACE=$2 ; shift 2 ;;

     -Q| --major ) MAJOR_STEPS="$2"; TMP_MAJOR="$2"; shift 2;;
     -R| --minor_st ) MINOR_STEPS_ST[$TMP_MAJOR]="$2"; shift 2 ;;
     -E| --minor_end ) MINOR_STEPS_ED[$TMP_MAJOR]="$2"; shift 2 ;;
     -O| --stop ) STOP=1; shift ;;
     -h| --help ) show_build_help; exit 0; shift;;
     --) shift ; break ;;
     *) exit 1 ;;
  esac
done

mkdir -p ${WORKSPACE}/logs
echo "aurora_build.sh started with [aurora_build.sh  $ARGS]" > ${WORKSPACE}/logs/aurora_build_command

#Check required Arguments
if [[ -z "$BRANCH" || -z "PROJECT" ]]; then
  echo "Required argument -b(--branch) or -p(--project)"
  show_build_help
  exit 1
fi

#keep_running equalling 1 means -k was specified, end step should be 1 less.
if [[ $KEEP_RUNNING == "1" ]]; then
  MINOR_STEPS_ED[build]=21
fi

#Generating Instance name piece by piece
INSTANCE_NAME=${emailid}
#Append tag if provided
if [[ $TAG != "none" ]]; then
  #Only keeping alphanumeric characters
  TAG=${TAG//[^[:alnum:]]/}
  #Converting to lowercase since instance name cannot contain uppercase characters
  TAG=${TAG,,}
  INSTANCE_NAME=${INSTANCE_NAME}-${TAG}
fi

#Append refspec
if [[ $REFSPEC == "none" ]]; then
  MOD_BRANCH=$(echo "$BRANCH" | tr _ -)
  INSTANCE_NAME=${INSTANCE_NAME}-bld-${MOD_BRANCH}
else
  MOD_REFSPEC=$(echo "$REFSPEC" | sed -e 's/refs\/changes\///')
  MOD_REFSPEC=$(echo "$MOD_REFSPEC" | tr /_ -)
  INSTANCE_NAME=${INSTANCE_NAME}-bld-${MOD_REFSPEC}
fi

step_file=$WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step
#Validate Inputs
check_build_inputs $INSTANCE_NAME $PROJECT $REFSPEC $BRANCH
#Check /home/$USER/.ssh/id_rsa.pub file
check_file_existence "/home/$USER/.ssh/id_rsa.pub"
# If "continue" switch has been given then do following steps
#   a. Get the last successfully completed step.
#   b. Start the build process from step next to last completed step.
if [[ $CONTINUE == "1" ]] ; then
  #Continue only if file exists
  if [[ ! -f $step_file ]]; then
    echo "No last successful step, cannot resume. Exiting"
    exit 1
  fi
  # Get the last successfull step from $WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step
  LAST_SUCCESSFULL_STEP=( $(<${step_file}) )
  MINOR_STEPS_ST[build]=$((LAST_SUCCESSFULL_STEP+1))
else
  check_instance_limit
fi

# Describe the possible mappings for branch->component translations
declare -A branch_to_component
branch_to_component['master']='unstable'
branch_to_component['stable_4_0']='everest'
# Convert the branch name to respective component name
for key in ${!branch_to_component[@]}; do
  if [[ "${key}" == ${BRANCH} ]]; then
    APT_COMPONENT=${branch_to_component[$key]}
    break
  fi
done

#Get the IP address of the instances, needed incase continue is specified.
INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})

# TODO: SN_ID variable should hold the "v3-d1" part as well.
# This way we will not need to change v3 manually.
SN_ID=$(get_latest_snapshot_id)
SNAP1=${PRIM_INST_NAME}-d1-${SN_ID}
SNAP2=${PRIM_INST_NAME}-d2-${SN_ID}
DOCK_NAME=pg-docker-repo:5000/pg_dev:${SN_ID}

#Create file to ensure continue works if run/build is aborted before 1st step completes
touch $step_file

function build_image() {
  local step=$1
  case "$step" in

  1)
    echo "Creating the disk[${INSTANCE_NAME}-d1] for the instance in the cloud"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d1" \
      --source-snapshot "${SNAP1}" --type "$DISK_TYPE" --size="$DISK1_SIZE" -q
    record_step $step $step_file
    ;;

  2)
    echo "Creating the disk[${INSTANCE_NAME}-d2] for the instance in the cloud"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d2" \
      --source-snapshot "${SNAP2}" --type "$DISK_TYPE" --size="$DISK2_SIZE" -q
    record_step $step $step_file
    ;;

  3)
    local key_file=$(mktemp $WORKSPACE/keys-XXXXX)
    echo ${USER}:$(cat /home/${USER}/.ssh/id_rsa.pub) > $key_file
    echo plumgrid:$(echo ${COMMON_KEY}) >> $key_file
    echo "Creating the instance[$INSTANCE_NAME] in the cloud"
    tryexec exec_gcloud_cmd instances create "${INSTANCE_NAME}" \
      --machine-type "$MACHINE_TYPE" --network "$NETWORK" --maintenance-policy \
      "MIGRATE" --scopes "$SCOPES" -q \
      --disk "name=${INSTANCE_NAME}-d1" "mode=rw" "boot=yes" "auto-delete=yes" \
      --disk "name=${INSTANCE_NAME}-d2" "mode=rw" "boot=no" "auto-delete=yes" --no-address --tags "no-ip" \
      --metadata-from-file sshKeys=$key_file
    rm $key_file
    record_step $step $step_file
    ;;

  4)
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
    echo "Waiting for the machine to boot up and allow ssh access"
    tryexec wait_for_instance ${INSTANCE_IP}
    record_step $step $step_file
    ;;

  5)
    echo "setting up forward on ${INSTANCE_NAME} Machine "
    tryexec run_cmd_gci ${INSTANCE_IP} "echo 'host *' > ~/.ssh/config; echo '    ForwardAgent yes'>>~/.ssh/config"
    record_step $step $step_file
    ;;

  6)
    echo "starting the pgdev container"
    tryexec run_dock_container ${INSTANCE_IP} ${DOCK_NAME} "./local_docker_id" "./local_docker_ip"
    tryexec verify_docker_running ${INSTANCE_IP} ${DOCK_NAME}
    record_step $step $step_file
    ;;

  7)
    echo "Copy build-instance key to pgdev container"
    tryexec run_cmd_gci ${INSTANCE_IP} "echo -e  'y\n'|ssh-keygen -t rsa -N \"\" -f ~/.ssh/id_rsa"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo su -c \"cat /home/${USER}/.ssh/id_rsa.pub >> \
      /var/lib/docker/btrfs/subvolumes/\`cat local_docker_id\`/home/plumgrid/.ssh/authorized_keys\""
    record_step $step $step_file
    ;;

  8)
    echo "Copy local key to pgdev container"
    tryexec scp -o UserKnownHostsFile=/dev/null -o CheckHostIP=no -o StrictHostKeyChecking=no ~/.ssh/id_rsa.pub ${USER}@${INSTANCE_IP}:./auth-key.pub
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo su -c \"cat /home/${USER}/auth-key.pub >> \
      /var/lib/docker/btrfs/subvolumes/\`cat local_docker_id\`/home/plumgrid/.ssh/authorized_keys\""
    record_step $step $step_file
    ;;

  9)
    tryexec check_ssh_server_status ${INSTANCE_IP} || retval=$?
    if [[ $retval == 1 ]]; then
      run_cmd_gci ${INSTANCE_IP} "sudo docker ps"
      echo "Docker stopped.. Please run aurora build with --continue to retry!!"
      record_step 4 $step_file
      exit $retval
    fi
    record_step $step $step_file
    ;;

  10)
    GIT_SYNC_SCRIPT=$(mktemp $WORKSPACE/gitsync.sh-XXXXX)
    echo "Generate script for syncing the gerrit repo"
    tryexec write_gitsync.sh "${GIT_SYNC_SCRIPT}" "${BRANCH}" "${PROJECT}" "${REFSPEC}"
    tryexec upload_to_docker ${INSTANCE_IP} ${GIT_SYNC_SCRIPT} /tmp/
    GIT_SYNC_BASE=$(basename ${GIT_SYNC_SCRIPT} )
    tryexec run_cmd_docker ${INSTANCE_IP} "mv /tmp/${GIT_SYNC_BASE} /tmp/gitsync.sh"
    rm ${GIT_SYNC_SCRIPT}
    record_step $step $step_file
    ;;

  11)
    echo "Execute the gitsynch script on docker container in steps"
    # Run Step1: cleanup
    echo "gitsync Step1: Perform cleanup on the setup"
    tryexec check_ssh_server_status ${INSTANCE_IP}
    tryexec run_cmd_docker_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh cleanup"
    record_step $step $step_file
    ;;

  12)
    # Run Step2: Fetch tools
    echo "gitsync Step2: Fetching latest tools"
    retryexec run_cmd_docker_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh tools"
    record_step $step $step_file
    ;;

  13)
    # Run Step3: Fetch all repos
    echo "gitsync Step3: Fetching all the repos (${PROJECT_LIST[@]})"
    for p in ${PROJECT_LIST[@]}; do
      retryexec run_cmd_docker_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh all_repos $p"
    done
    record_step $step $step_file
    ;;

  14)
    # Run Step4: Fetch iovisor
    echo "gitsync Step4: Fetching latest iovisor"
    retryexec run_cmd_docker_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh iovisor"
    record_step $step $step_file
    ;;

  15)
    # Checkout the required changes for specified project and set apt_component
    echo "gitsync Step5: Checking out required code on ${PROJECT}"
    retryexec run_cmd_docker_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh checkout"
    record_step $step $step_file
    ;;

  16)
    echo "Starting build-all.sh for ${APT_COMPONENT}==="
    tryexec run_build_all ${INSTANCE_IP} ${APT_COMPONENT} "/tmp/build_all.log"
    record_step $step $step_file
    ;;

  17)
    # Adding polling as a separate step, so that if the connection broke at the previous step,
    # this step can be run directly to see if the previous command is still running
    echo "Polling for build-all (tailing \"/tmp/build_all.log\" for complete logs)"
    retryexec run_poll_cmd ${INSTANCE_IP} "run_build_all.sh" "/tmp/build_all.log" "1"
    tryexec download_from_docker ${INSTANCE_IP} "/tmp/build_all.log" "${WORKSPACE}/logs/"
    record_step $step $step_file
    ;;

  18)
    echo "Making a snapshot for the container"
    tryexec run_cmd_gci ${INSTANCE_IP} "echo \"pg_dev_${INSTANCE_NAME}\" > docker_build_id" "t"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo docker commit \`cat ./local_docker_id\` pg_dev_${INSTANCE_NAME}:latest"
    record_step $step $step_file
    ;;

  19)
    echo "Making sure docker(pg_dev_${INSTANCE_NAME}:latest) is commited successfully"
    tryexec verify_docker_commited ${INSTANCE_IP} "pg_dev_${INSTANCE_NAME}"
    record_step $step $step_file
    ;;

  20)
    BUILD_ID=`echo ${INSTANCE_NAME} | sed "s/${emailid}-//"`
    echo "Creating a snapshot of VM for BUILD-ID=${BUILD_ID}"
    tryexec run_cmd_gci ${INSTANCE_IP} "echo ${INSTANCE_NAME}-ssd1 > ~/build_d1_snapshot"
    tryexec run_cmd_gci ${INSTANCE_IP} "echo ${INSTANCE_NAME}-ssd2 > ~/build_d2_snapshot"
    tryexec run_cmd_gci ${INSTANCE_IP} "echo ${SN_ID} > ~/primary_snapshot"

    #SSD-2 needs to be created 1st because using fsfreeze on / causes ssh timeout
    #Flushing the disk buffers
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo sync"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo fsfreeze -f /opt || true"
    tryexec exec_gcloud_cmd disks snapshot ${INSTANCE_NAME}-d2 --snapshot-names ${INSTANCE_NAME}-ssd2
    record_step $step $step_file
    ;;


  21)
    #Flushing the disk buffers
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo sync"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo fsfreeze -f / || true"
    tryexec exec_gcloud_cmd disks snapshot ${INSTANCE_NAME}-d1 --snapshot-names ${INSTANCE_NAME}-ssd1

    echo "BUILD-ID=${BUILD_ID}" | tee $WORKSPACE/logs/build_id
    record_step $step $step_file
    ;;

  22)
    echo "Shutting down the Instance ${INSTANCE_NAME}"
    tryexec exec_gcloud_cmd instances delete ${INSTANCE_NAME} --delete-disks all  -q
    rm $step_file
    printf "\n\n *********************** BUILD-ID = ${BUILD_ID} *********************** \n\n"
    ;;

  *)
    echo "NOP - $step"
  ;;
  esac
}

for MAJOR_STEP in $MAJOR_STEPS; do
  echo ""
  echo " ====== Starting STEP [$MAJOR_STEP] Number of Steps ::${MINOR_STEPS_ST[$MAJOR_STEP]} -> ${MINOR_STEPS_ED[$MAJOR_STEP]}  ======"
  echo ""
  for MINOR_STEP in `seq ${MINOR_STEPS_ST[$MAJOR_STEP]} ${MINOR_STEPS_ED[$MAJOR_STEP]}`; do
    echo ""
    echo "    === Starting STEP [$MAJOR_STEP][$MINOR_STEP] ==="
    echo ""
    case "$MAJOR_STEP" in
      build)
        start_time=$(date +%s)
        build_image $MINOR_STEP
        end_time=$(date +%s)
        print_time_taken $start_time $end_time "[$MAJOR_STEP][$MINOR_STEP]"
      ;;
      *)
        echo "UNKNOWN STEP $MAJOR_STEP.$MINOR_STEP"
      ;;
    esac
    if [ -n "$STOP" ] ; then
      exit
    fi
  done
done

