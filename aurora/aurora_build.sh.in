#!/bin/bash -e

export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
echo "aurora_build.sh started with [aurora_build.sh  $@]"
. gc_helpers.sh
. aurora_utils.sh
source aurora_infra_settings.conf
source /home/$USER/.aurora.conf

# TODO: Get the latest snapshot id and use that in below variables
SN_ID=$(get_latest_snapshot_id)
SNAP1=plumgrid-builder-v1-d1-${SN_ID}
SNAP2=plumgrid-builder-v1-d2-${SN_ID}
DOCK_NAME=pg-docker-repo:5000/pg_dev:${SN_ID}

# TODO: Make a decision about machine type and Disk sizes.
# TODO: Use values from aurora_settings.conf file
MACHINETYPE="n1-standard-4"
DISK1_SIZE=10
DISK2_SIZE=200
GIT_SYNC_SCRIPT="/tmp/gitsync.sh"
BRANCH=""
REFSPEC=""
PROJECT=""

declare -A MINOR_STEPS_ST
declare -A MINOR_STEPS_ED
BUILD_ENV_USER=${USER}
MAJOR_STEPS="build"
MINOR_STEPS_ST[init]=1
MINOR_STEPS_ST[build]=1
MINOR_STEPS_ED[init]=1
MINOR_STEPS_ED[build]=15

function usage() {
cat <<EOF
usage: $0
 -c | --cleanup : Test Cleanup
 -Q | --major : Jump to specific major step in the install process
 -R | --minor_st : Jump to specific minor step in the install process
 -E | --minor_end : Stop at this step when in debug
 -G | --gerrit_refpec: Mention the gerrit refspec
 -B | --branch: branch to run the setup on. Options: master, stable_4_0
 -P | --project: project on which the code change is expected. Options: alps, pg_ui, etc
 -O | --stop : DONT Continue beyond the specifict step to end of the installation
 -h | --help : help
EOF
exit 0
}

# Parsing arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
     -c| --cleanup ) CLEANUP=1;  ;;
     -Q| --major ) MAJOR_STEPS="$2"; TMP_MAJOR="$2"; shift ;;
     -R| --minor_st ) MINOR_STEPS_ST[$TMP_MAJOR]="$2"; shift ;;
     -E| --minor_end ) MINOR_STEPS_ED[$TMP_MAJOR]="$2"; shift ;;
     -G| --gerrit_refspec ) REFSPEC=$2; shift ;;
     -B| --branch ) BRANCH=$2; shift ;;
     -P| --project ) PROJECT=$2; shift ;;
     -I| --instance_name ) INSTANCE_NAME=$2; shift ;;
     -O| --stop ) STOP=1; ;;
     -h | --help ) usage; ;;
    -- ) shift; break ;;
    * )
      echo "Unknown parameter: $1";
      usage; break;;
  esac
  shift
done

# Describe the possible mappings for branch->component translations
declare -A branch_to_component
branch_to_component['master']='unstable'
branch_to_component['stable_4_0']='everest'
# Convert the branch name to respective component name
for key in ${!branch_to_component[@]}; do
  if [[ "${key}" == ${BRANCH} ]]; then
    APT_COMPONENT=${branch_to_component[$key]}
    break
  fi
done


function init_id() {
  conf_file="/opt/pg/scripts/aurora.conf"
  echo "Please enter your gerrit id: "
  read gerritid
  echo "gerritid=${gerritid}" > ${conf_file}
}

function build_image() {
  local step=$1
  case "$step" in

  1)
    echo "Creating the disk[${INSTANCE_NAME}-d1] and [${INSTANCE_NAME}-d2] for the instance in the cloud"
    tryexec gcloud -q --verbosity ${VERBOSITY} compute disks create "${INSTANCE_NAME}-d1" \
      --source-snapshot "${SNAP1}" --type "pd-standard" --size="$DISK1_SIZE"
    tryexec gcloud -q --verbosity ${VERBOSITY} compute disks create "${INSTANCE_NAME}-d2" \
      --source-snapshot "${SNAP2}" --type "pd-standard" --size="$DISK2_SIZE"
    record_step $step
    ;;

  2)
    echo "Creating the instance[$INSTANCE_NAME] in the cloud"
    tryexec gcloud -q --verbosity ${VERBOSITY} compute instances create "${INSTANCE_NAME}" \
      --machine-type "$MACHINETYPE" --network "net-10-10" --maintenance-policy \
      "MIGRATE" --scopes "https://www.googleapis.com/auth/devstorage.read_only" \
      --disk "name=${INSTANCE_NAME}-d1" "mode=rw" "boot=yes" "auto-delete=yes" \
      --disk "name=${INSTANCE_NAME}-d2" "mode=rw" "boot=no" "auto-delete=yes"
    record_step $step
    ;;

  3)
    echo "Waiting for the machine to boot up and allow ssh access"
    wait_for_instance ${INSTANCE_NAME}
    record_step $step
    ;;

  4)
    echo "setting up forward on ${INSTANCE_NAME} Machine "
    tryexec run_cmd_gci ${INSTANCE_NAME} "echo 'host *' > ~/.ssh/config; echo '    ForwardAgent yes'>>~/.ssh/config"
    record_step $step
    ;;

  5)
    echo "starting the pgdev container"
    tryexec run_dock_container ${INSTANCE_NAME} ${DOCK_NAME} "./local_docker_id" "./local_docker_ip"
    tryexec verify_docker_running ${INSTANCE_NAME} ${DOCK_NAME}
    record_step $step
    ;;

  6)
    echo "Copy build-instance key to pgdev container"
    tryexec run_cmd_gci ${INSTANCE_NAME} "ssh-keygen -t rsa -N \"\" -f ~/.ssh/id_rsa"
    tryexec run_cmd_gci ${INSTANCE_NAME} "sudo su -c \"cat /home/$USER/.ssh/id_rsa.pub >> \
      /var/lib/docker/btrfs/subvolumes/\`cat local_docker_id\`/home/plumgrid/.ssh/authorized_keys\""
    record_step $step
    ;;

  7)
    echo "Copy local key to pgdev container"
    tryexec gcloud compute copy-files ~/.ssh/id_rsa.pub ${USER}@${INSTANCE_NAME}:./auth-key.pub
    tryexec run_cmd_gci ${INSTANCE_NAME} "sudo su -c \"cat /home/$USER/auth-key.pub >> \
      /var/lib/docker/btrfs/subvolumes/\`cat local_docker_id\`/home/plumgrid/.ssh/authorized_keys\""
    record_step $step
    ;;

  8)
    tryexec check_ssh_server_status ${INSTANCE_NAME}
    record_step $step
    ;;

  9)
    # TODO: Use auror_utils copy_to_docker function
    echo "Generate script for syncing the gerrit repo"
    tryexec write_gitsync.sh "${GIT_SYNC_SCRIPT}" "${BRANCH}" "${PROJECT}" "${REFSPEC}"
    tryexec upload_to_docker ${INSTANCE_NAME} ${GIT_SYNC_SCRIPT} /tmp/
    record_step $step
    ;;

  10)
    echo "Execute the gitsynch script on docker container"
    tryexec check_ssh_server_status ${INSTANCE_NAME}
    tryexec run_cmd_docker_sshforwarding ${INSTANCE_NAME} "bash ${GIT_SYNC_SCRIPT}"
    record_step $step
    ;;

  11)
    echo "Starting build-all.sh for ${APT_COMPONENT}==="
    tryexec run_cmd_docker_sshforwarding_bg ${INSTANCE_NAME} "/bin/bash /home/plumgrid/run_build_all.sh ${APT_COMPONENT}" "/tmp/build_all.log"
    record_step $step
    ;;

  12)
    # Adding polling as a separate step, so that if the connection broke at the previous step,
    # this step can be run directly to see if the previous command is still running
    echo "Polling for build-all (tailing \"/tmp/build_all.log\" for complete logs)"
    run_poll_cmd ${INSTANCE_NAME} "run_build_all.sh" "/tmp/build_all.log"
    record_step $step
    ;;

  13)
    echo "Making a snapshot for the container"
    tryexec run_cmd_gci ${INSTANCE_NAME} "echo \"pg_dev_${INSTANCE_NAME}\" > docker_build_id" "t"
    tryexec run_cmd_gci ${INSTANCE_NAME} "sudo docker commit \`cat ./local_docker_id\` pg_dev_${INSTANCE_NAME}:latest"
    record_step $step
    ;;

  14)
    echo "Making sure docker(pg_dev_${INSTANCE_NAME}:latest) is commited successfully"
    tryexec verify_docker_commited ${INSTANCE_NAME} "pg_dev_${INSTANCE_NAME}"
    record_step $step
    ;;

  15)
    BUILD_ID=`echo ${INSTANCE_NAME} | sed "s/${gerritid}-//"`
    echo "Creating a snapshot of VM for BUILD-ID=${BUILD_ID}"
    tryexec gcloud compute -q ssh ${USER}@${INSTANCE_NAME} --ssh-flag='-t' --command "echo ${INSTANCE_NAME}-ssd1 > ~/build_d1_snapshot"
    tryexec gcloud compute -q ssh ${USER}@${INSTANCE_NAME} --ssh-flag='-t' --command "echo ${INSTANCE_NAME}-ssd2 > ~/build_d2_snapshot"
    tryexec gcloud compute -q ssh ${USER}@${INSTANCE_NAME} --ssh-flag='-t' --command "echo ${SN_ID} > ~/primary_snapshot"
    create_snapshot ${INSTANCE_NAME}-d1 ${INSTANCE_NAME}-ssd1
    create_snapshot ${INSTANCE_NAME}-d2 ${INSTANCE_NAME}-ssd2
    echo " BUILD-ID = ${BUILD_ID} "
    record_step $step
    ;;

  16)
    echo "Shutting down the Instance ${INSTANCE_NAME}"
    tryexec gcloud compute instances delete ${INSTANCE_NAME} --delete-disks all  -q
    record_step $step
    printf "\n\n *********************** BUILD-ID = ${BUILD_ID} *********************** \n\n"
    ;;

  *)
    echo "NOP - $step"
  ;;
  esac
}

for MAJOR_STEP in $MAJOR_STEPS; do
  echo ""
  echo " ====== Starting STEP [$MAJOR_STEP] Number of Steps ::${MINOR_STEPS_ST[$MAJOR_STEP]} -> ${MINOR_STEPS_ED[$MAJOR_STEP]}  ======"
  echo ""
  for MINOR_STEP in `seq ${MINOR_STEPS_ST[$MAJOR_STEP]} ${MINOR_STEPS_ED[$MAJOR_STEP]}`; do
    echo ""
    echo "    === Starting STEP [$MAJOR_STEP][$MINOR_STEP] ==="
    echo ""
    case "$MAJOR_STEP" in
      init)
        echo "Going to call init function"
        init_id
      ;;
      build)
        build_image $MINOR_STEP
      ;;
      *)
        echo "UNKNOWN STEP $MAJOR_STEP.$MINOR_STEP"
      ;;
    esac
    if [ -n "$STOP" ] ; then
      exit
    fi
  done
done

