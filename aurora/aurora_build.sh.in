#!/bin/bash -e
source help.sh

# This script basically creates a snapshot image containing repositories, packages, dependencies required to run plumgrid
# tests. The script is configurable using multiple flag/switches based on the use of the developer. Details on the switches
# can be seen by running "aurora build help" on the terminal. The script basically creates an instance pulls all the
# repos checks out the refspec if desired and runs build all. This leaves the instance ready to run almost each and every
# test in the plumgrid test suite. A snapshot of this image is created and is available to the user for further action.
# i.e. run specific tests, run a specific pipeline, run a script on an instance. All of the afore mentioned actions would
# be completed using gcloud instances created from this snapshot.
# The snapshot created (Build id) is printed at the end of the script.

export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
echo "aurora_build.sh started with [aurora_build.sh  $@]"
ARGS=$@
. gc_helpers.sh
. aurora_utils.sh
source aurora_infra_settings.conf
source /home/$USER/.aurora.conf


#Show help
if [[ $1 =~ "help" ]]; then
  show_build_help
  exit 1
fi

BRANCH=""
REFSPEC="none"
TAG="none"
GIT_TAG="none"
PROJECT=""

STEP_ST=1

TOTAL_BUILD_STEPS=27
STEP_ED=$TOTAL_BUILD_STEPS

GIVEN_ST=0
GIVEN_ED=0

CONTINUE=0

# read the options
TEMP=`getopt -o Kr:t:Cb:g:p:W:s:R:E:h --long keep-running,refspec:,script:,WORKSPACE:,tag:,\continue,branch:,git-tag:,proj:,help,step_st:,step_end: -n 'aurora.sh' -- "$@"`

eval set -- "$TEMP"
while true ; do
  case "$1" in
     -K| --keep-running ) KEEP_RUNNING=1; shift ;;
     -r| --refspec) REFSPEC=$2; shift 2 ;;
     -s| --script ) BUILD_SCRIPT=$2; shift 2 ;;
     -t| --tag) TAG=$2 ; shift 2 ;;
     -C| --continue) CONTINUE=1 ; shift ;;
     -b| --branch) BRANCH=$2; shift 2 ;;
     -g| --git-tag) GIT_TAG=$2; shift 2 ;;
     -p| --proj) PROJECT=$2; shift 2 ;;
     -W| --WORKSPACE) export WORKSPACE=$2 ; shift 2 ;;

     -R| --step_st ) STEP_ST="$2"; GIVEN_ST=1; shift 2 ;;
     -E| --step_end ) STEP_ED="$2"; GIVEN_ED=1; shift 2 ;;
     -h| --help ) show_build_help; exit 0; shift;;
     --) shift ; break ;;
     *) exit 1 ;;
  esac
done

mkdir -p ${WORKSPACE}/logs

#Assign the default build script for the project
if [[ -z "$BUILD_SCRIPT" ]]; then
  BUILD_SCRIPT="${INIT_SCRIPT[$PROJECT]}"
fi
#If the project build script does not exist, assign global default
if [[ -z "$BUILD_SCRIPT" ]]; then
  BUILD_SCRIPT="${INIT_SCRIPT['default']}"
fi

echo "The Following BUILD_SCRIPT would be used : $BUILD_SCRIPT"

#creating branch code from branch name provided by user.
branch_code="${BR_CODE[$BRANCH]}"

if [[ -z "$branch_code" ]]; then
  branch_code="x"
fi

branch_code="b-${branch_code}"


INSTANCE_NAME=$(generate_build_instance_name ${emailid} ${TAG} ${branch_code} ${REFSPEC} ${GIT_TAG} ${BRANCH})

step_file=$WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step
#Validate Inputs
check_build_inputs $INSTANCE_NAME $PROJECT $REFSPEC $BRANCH $GIT_TAG
#Check /home/$USER/.ssh/id_rsa.pub file
check_file_existence "/home/$USER/.ssh/id_rsa.pub"
check_file_existence "$BUILD_SCRIPT"


# If "continue" switch has been given then do following steps
#   a. Get the last successfully completed step.
#   b. Start the build process from step next to last completed step.
if [[ $GIVEN_ST == "0" && $CONTINUE == "1" ]] ; then
  #Continue only if file exists
  if [[ ! -f $step_file ]]; then
    echo "No last successful step, cannot resume. Exiting"
    exit 1
  fi
  # Get the last successfull step from $WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step
  LAST_SUCCESSFULL_STEP=( $(<${step_file}) )
  STEP_ST=$((LAST_SUCCESSFULL_STEP+1))
fi

#Only get the IP address if the instance has already been created.
if [[ $STEP_ST -gt "3" ]]; then
  INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
else
  check_instance_limit
  #Check if the snapshots already exist
  retval=0
  check_snapshot_exists ${INSTANCE_NAME}-ssd1 1 || ((++retval))
  check_snapshot_exists ${INSTANCE_NAME}-ssd2 1 || ((++retval))
  if [[ $retval != "2" ]]; then
    echo "Snapshots for ${INSTANCE_NAME} already exist. Use aurora rm build to remove snapshots or use a different tag."
    exit 1
  fi
fi

# If "step-end" switch has NOT been given then do the following steps
#   a. Decrement step-end by 1 if KEEP_RUNNING switch has been used
if [[ $GIVEN_ED == "0" && $KEEP_RUNNING == "1" ]]; then
  #keep_running equalling 1 means -k was specified, end step should be 1 less.
  STEP_ED=`expr $STEP_ED - 1`

fi

# TODO: SN_ID variable should hold the "v3-d1" part as well.
# This way we will not need to change v3 manually.
SN_ID=$(get_latest_snapshot_id)
SNAP1=${PRIM_INST_NAME}-d1-${SN_ID}
SNAP2=${PRIM_INST_NAME}-d2-${SN_ID}

echo "Copying the branch translations"
#Branch translations are located in builder
if [[ ! -d ${WORKSPACE}/builder/.git ]]; then
  tryexec git clone --depth=1 ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/builder ${WORKSPACE}/builder
fi



#Create file to ensure continue works if run/build is aborted before 1st step completes
touch $step_file

function build_image() {
  local step=$1
  case "$step" in

  1)
    echo "Creating the disk[${INSTANCE_NAME}-d1] for the instance in the cloud"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d1" \
      --source-snapshot "${SNAP1}" --type "$DISK_TYPE" --size="$DISK1_SIZE" -q
    ;;

  2)
    echo "Creating the disk[${INSTANCE_NAME}-d2] for the instance in the cloud"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d2" \
      --source-snapshot "${SNAP2}" --type "$DISK_TYPE" --size="$DISK2_SIZE" -q
    ;;

  3)
    local key_file=$(mktemp $WORKSPACE/keys-XXXXX)
    echo plumgrid:$(cat /home/${USER}/.ssh/id_rsa.pub) > ${key_file}
    echo plumgrid:$(echo ${COMMON_KEY}) >> ${key_file}
    echo "Creating the instance[$INSTANCE_NAME] in the cloud"
    tryexec exec_gcloud_cmd instances create "${INSTANCE_NAME}" \
      --machine-type "$MACHINE_TYPE" --network "$NETWORK" --maintenance-policy \
      "MIGRATE" --scopes "$SCOPES" -q \
      --disk "name=${INSTANCE_NAME}-d1,mode=rw,boot=yes,auto-delete=yes" \
      --disk "name=${INSTANCE_NAME}-d2,mode=rw,boot=no,auto-delete=yes" --no-address --tags "no-ip" \
      --metadata-from-file sshKeys=$key_file
    rm $key_file
    ;;

  4)
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
    echo "Waiting for the machine to boot up and allow ssh access"
    tryexec wait_for_instance ${INSTANCE_IP}
    ;;

  5)
    echo "Changing MTU on the instance"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo ifconfig eth0 mtu 1400"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo bash -c 'echo \"interface \\\"eth0\\\" {supersede interface-mtu 1400;}\" >> /etc/dhcp/dhclient.conf'"
    tryexec run_cmd_gci ${INSTANCE_IP} "DT=\$(ifconfig eth0 | grep 'inet addr' | cut -d: -f2|cut -d' ' -f 1); sudo bash -c 'echo \"'\$DT'  \`hostname\`\" >> /etc/hosts'"
    ;;

  6)
    GIT_SYNC_SCRIPT=$(mktemp /tmp/gitsync.sh-XXXXX)
    echo "Generate script for syncing the gerrit repo"
    tryexec write_gitsync.sh "${GIT_SYNC_SCRIPT}" "${BRANCH}" "${PROJECT}" "${REFSPEC}" "${WORKSPACE}/builder/branch_translations"
    retryexec upload ${INSTANCE_IP} ${GIT_SYNC_SCRIPT} /tmp/
    GIT_SYNC_BASE=$(basename ${GIT_SYNC_SCRIPT} )
    tryexec run_cmd_gci ${INSTANCE_IP} "mv /tmp/${GIT_SYNC_BASE} /tmp/gitsync.sh"
    rm ${GIT_SYNC_SCRIPT}
    ;;

  7)
    echo "Execute the gitsynch script"
    echo "gitsync Step1: Perform cleanup on the setup"
    tryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh cleanup"
    ;;

  8)
    echo "gitsync Step2: Installing gcloud on the instance"
    tryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh install_gcloud"
    echo "Copying aurora conf file to the instance"
    #Adding aurora related configuration
    upload ${INSTANCE_IP} ~/.aurora.conf /home/${_USER}/.aurora.conf
    tryexec run_cmd_gci ${INSTANCE_IP} "gcloud config set compute/zone $ZONE"
    tryexec run_cmd_gci ${INSTANCE_IP} "gcloud config set compute/region $REGION"
    record_step $step $step_file
    ;;


  9)
    # Run Step2: Fetch tools
    echo "gitsync Step2: Fetching latest tools, esper and builder"
    retryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh tools"
    ;;

  10)
    # Run Step3: Fetch repos to be cloned based on the component
    # Default branch according to branch translations in the builder
    default_branch=$(translate_branch "${BRANCH}" "${PROJECT}" "default" "${WORKSPACE}/builder/branch_translations")
    component=${BRANCH_TO_COMPONENT[${default_branch}]}
    echo "The default branch for ${PROJECT} is ${default_branch} with component ${component}"
    # Returns a list of projects to be cloned based on the component provided
    project_list=$(projects_to_clone "${component}")
    echo "gitsync Step3: Fetching repos (${project_list[@]})"
    for p in ${project_list[@]}; do
      if [[ ${p} == ${PROJECT} ]]; then
        retryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh all_repos $p $BRANCH $GIT_TAG"
      else
        translated_branch=$(translate_branch "${BRANCH}" "${PROJECT}" "${p}" "${WORKSPACE}/builder/branch_translations")
        retryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh all_repos $p $translated_branch $GIT_TAG"
      fi
    done
    #Delete the cloned builder files
    rm -rf ${WORKSPACE}/builder
    ;;

  11)
    # Run Step4: Checkout the required changes for specified project
    echo "gitsync Step4: Checking out required code on ${PROJECT}"
    retryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh checkout"
    ;;

  12)
    # Run Step5: Fetch iovisor
    echo "gitsync Step5: Fetching latest iovisor"
    retryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh iovisor"
    ;;


  13)
    # Get the build info
    echo "Getting build info for ${PROJECT}"
    tryexec get_build_info ${INSTANCE_IP} ${PROJECT}
    ;;

  14)
    # Extract Corelib Version from Alps
    if [[ ${PROJECT} == "corelib" || ( ${component} != "unstable" && ${component} != "unstable-bnp" ) ]]; then
      echo "Main project is corelib no need to extract version"
    else
      echo "Extracting corelib version from alps"
      tryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "bash /tmp/gitsync.sh corelib"
    fi
    ;;

  15)
    #Install tools and iovisor in the background
    echo "Installing tools, esper and iovisor"
    tryexec make_tools_iovisor_esper ${INSTANCE_IP} "/tmp/make_tools_iovisor.log"
    ;;

  16)
    # Adding polling as a separate step, so that if the connection broke at the previous step,
    # this step can be run directly to see if the previous command is still running
    echo "Polling for tools install"
    tryexec run_poll_cmd ${INSTANCE_IP} "make_tools_iovisor.sh" "/tmp/make_tools_iovisor.log" "1"
    retryexec download ${INSTANCE_IP} "/tmp/make_tools_iovisor.log" "${WORKSPACE}/logs/"
    ;;

  17)
    # Corelib build is required for alps cmake..
    echo "Corelib Build Step"
    tryexec corelib_build ${INSTANCE_IP} "/tmp/corelib_build.log"
    ;;

  18)
    #Polling for corelib build step
    echo "Polling for corelib build"
    tryexec run_poll_cmd ${INSTANCE_IP} "corelib_build.sh" "/tmp/corelib_build.log" "1"
    retryexec download ${INSTANCE_IP} "/tmp/corelib_build.log" "${WORKSPACE}/logs/"
    ;;

  19)
    #run cmake on the repos
    echo "running cmake on the repos"
    retryexec run_cmd_gci ${INSTANCE_IP} "bash /tmp/gitsync.sh cmake_repos"
    ;;

  20)
    # Checks the elfsurgeon files, but only if we are testing an alps commit
    if [[ "${PROJECT}" == 'alps' ]]; then
      echo "make alps and check elfsurgeon files"
      tryexec check_elfsurgeon ${INSTANCE_IP} "/tmp/check_elfsurgeon.log"
    else
      echo "Skipping check_elfsurgeon since the current project is ${PROJECT}"
    fi
    ;;

  21)
    # Adding polling as a separate step, so that if the connection broke at the previous step.
    if [[ "${PROJECT}" == 'alps' ]]; then
      echo "Polling make for alps and checking elfsurgeon files (tailing \"/tmp/check_elfsurgeon.log\" for complete logs)"
      tryexec run_poll_cmd ${INSTANCE_IP} "check_elfsurgeon.sh" "/tmp/check_elfsurgeon.log" "1"
      retryexec download ${INSTANCE_IP} "/tmp/check_elfsurgeon.log" "${WORKSPACE}/logs/"
    else
      echo "check_elfsurgeon was skipped since the current project is ${PROJECT}"
    fi
    ;;

  22)
    run_cmd_gci ${INSTANCE_IP} "ln -s /opt/pg/web/temp /opt/pg/var/www/"
     run_cmd_gci ${INSTANCE_IP} "sudo bash -c \"echo 'proxy=http://10.10.163.162:3128' >> /etc/yum/yum.conf\""
    ;;

  23)
    echo "Running the build-init script"
    retryexec upload ${INSTANCE_IP} ${BUILD_SCRIPT} /tmp/build-init.sh
    tryexec run_bg_cmd ${INSTANCE_IP} "/tmp/build-init.sh" "/bin/bash /tmp/build-init.sh $PROJECT $BRANCH" "/tmp/build-init.log"
    ;;

  24)
    echo "Poll the build-init logs (tailing \"/tmp/build-init.log\")"
    tryexec run_poll_cmd ${INSTANCE_IP} "/tmp/build-init.sh" "/tmp/build-init.log" "1"
    retryexec download ${INSTANCE_IP} "/tmp/build-init.log" "${WORKSPACE}/logs/build-init.log"
    ;;

  25)
    BUILD_ID=`echo ${INSTANCE_NAME} | sed "s/${emailid}-//"`
    echo "Creating a snapshot of VM for BUILD-ID=${BUILD_ID}"

    # Flushing the disk buffers only if -K is not set
    if [[ "${KEEP_RUNNING}" != "1" ]]; then
      tryexec run_cmd_gci ${INSTANCE_IP} "sudo sync"
      tryexec run_cmd_gci ${INSTANCE_IP} "sudo fsfreeze -f /opt || true"
    fi

    tryexec exec_gcloud_cmd disks snapshot ${INSTANCE_NAME}-d2 --snapshot-names ${INSTANCE_NAME}-ssd2
    ;;

  26)

    # Flushing the disk buffers only if -K is not set
    if [[ "${KEEP_RUNNING}" != "1" ]]; then
      echo "Flushing the disk buffers"
      tryexec run_cmd_gci ${INSTANCE_IP} "sudo sync"
      tryexec run_cmd_gci ${INSTANCE_IP} "sudo fsfreeze -f / || true"
    fi

    tryexec exec_gcloud_cmd disks snapshot ${INSTANCE_NAME}-d1 --snapshot-names ${INSTANCE_NAME}-ssd1

    echo "BUILD-ID=${BUILD_ID}" | tee $WORKSPACE/logs/build_id
    ;;

  27)
    echo "Shutting down the Instance ${INSTANCE_NAME}"
    tryexec exec_gcloud_cmd instances delete ${INSTANCE_NAME} --delete-disks all  -q
    printf "\n\n *********************** BUILD-ID = ${BUILD_ID} *********************** \n\n"
    ;;

  *)
    echo "NOP - $step"
  ;;
  esac
}

script_start_time=$(date +%s)
for STEP in `seq ${STEP_ST} ${STEP_ED}`; do
  printf "\n    === Starting STEP $STEP === \n"
  start_time=$(date +%s)
  build_image $STEP
  end_time=$(date +%s)
  record_step $STEP $step_file
  print_time_taken $start_time $end_time "[$STEP]"
  if [[ $STEP == $TOTAL_BUILD_STEPS ]]; then
    rm $step_file
  fi
done

script_end_time=$(date +%s)
print_time_taken $script_start_time $script_end_time "[BUILD]"

