#!/bin/bash -e
source help.sh

echo "aurora_run.sh started with [aurora_run.sh  $@]"

export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
. gc_helpers.sh
. aurora_utils.sh
source /home/$USER/.aurora.conf
source aurora_infra_settings.conf

#Show help
if [[ $1 == "help" ]]; then
  show_run_help
  exit 1
fi
#Starting and ending steps
declare -A MINOR_STEPS_ST
declare -A MINOR_STEPS_ED
MAJOR_STEPS="run"
MINOR_STEPS_ST[$MAJOR_STEPS]=1
MINOR_STEPS_ED[$MAJOR_STEPS]=15

UUID=`uuidgen`
SUUID_="${UUID##*-}"
SUUID="${SUUID_,,}"

#Set default values for optional arguments
LOG_DIR="${WORKSPACE}/logs/"
SKIP_AUTOMATON_INIT=0
CONTINUE=0
KEEP_RUNNING=0
LOCAL_CHANGES=0


# read the options
TEMP=`getopt -o l:s:o:n:W:CSKhLc:a:R:E: --long buildid:,script:,log_dir:,runid:,WORKSPACE:,\continue,skip-automaton,keep-running,\help,\local-changes,commit:,alps-path:,minor_st:,minor_end: -n 'aurora.sh' -- "$@"`
eval set -- "$TEMP"
while true ; do
  case "$1" in
#Basic Funtionality
    -l| --buildid ) BUILD_ID=$2; shift 2 ;;
    -s| --script ) TEST_SCRIPT=$2; shift 2 ;;
    -o| --log_dir) LOG_DIR=$2; shift 2 ;;
    -n| --runid ) RUNID=$2 ; shift 2 ;;
    -W| --WORKSPACE) export WORKSPACE=$2 ; shift 2 ;;
    -C| --continue ) CONTINUE=1; shift ;;
    -S| --skip-automaton ) SKIP_AUTOMATON_INIT=1; shift ;;
    -K| --keep-running ) KEEP_RUNNING=1; shift ;;
    -h| --help ) show_run_help;exit 0; shift ;;
#Local changes flags
    -L| --local-changes) LOCAL_CHANGES=1; shift ;;
    -c| --commit) COMMIT_ID=$2; shift 2;;
    -a| --alps-path) ALPS_PATH=$2; shift 2;;
#Start-End steps
    -R| --minor_st ) MINOR_STEPS_ST[$MAJOR_STEPS]="$2"; shift 2 ;;
    -E| --minor_end ) MINOR_STEPS_ED[$MAJOR_STEPS]="$2"; shift 2 ;;
    --) shift ; break ;;
    *) exit 1 ;;
  esac
done
#Check required Arguments
if [[ -z "$BUILD_ID" || -z "$TEST_SCRIPT" ]]; then
  echo "Required argument -l(--buildid) or -s(--script)"
  show_run_help
  exit 1
fi

BUILD_ID=${gerritid_lower}-${BUILD_ID}
INSTANCE_NAME=`echo ${BUILD_ID}-${SUUID} | sed 's/bld/run/'`

if [[ $KEEP_RUNNING == "1" ]]; then
      MINOR_STEPS_ED[$MAJOR_STEPS]=14
fi
#Validate Inputs
check_run_inputs $BUILD_ID $TEST_SCRIPT
#Check /home/$USER/.ssh/id_rsa.pub file
check_file_existence "/home/$USER/.ssh/id_rsa.pub"

printf "\n\n********* RUNID= ${SUUID} *********\n\n"

# If "continue" switch has been given then do following steps
#   a. Get the RUN-ID provided by user.
#   b. Get the last successfully completed step.
#   c. Start the run process from step next to last completed step.
if [[ $CONTINUE == "1" ]] ; then
  # User must give the run-id(SUUID generated during first time execution of run process.)
  # along with continue such that we can know that which "aurora run" he needs to resume.
  # TODO: Exit if user does not give the run-id.
  if [ -z ${RUNID+x} ]; then
    echo "Please provide the RUN-ID which you want to continue e.g. f82ba2b78256"
    exit
  fi
  INSTANCE_NAME=`echo ${BUILD_ID}-${RUNID} | sed 's/bld/run/'`
  step_rec_file=$WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step
  LAST_SUCCESSFULL_STEP=( $(<${step_rec_file}) )
  MINOR_STEPS_ST[$MAJOR_STEPS]=$((LAST_SUCCESSFULL_STEP+1))
else
  check_instance_limit
fi

step_file=$WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step
DOCK_NAME="pg_dev_${BUILD_ID}:latest"
INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})

function run_test() {
  local step=$1

  case "$step" in
  1)
    echo "Creating the disk[${INSTANCE_NAME}-d1] and [${INSTANCE_NAME}-d2] for the instance in the cloud from ${BUILD_ID}"
    exec_gcloud_cmd disks create "${INSTANCE_NAME}-d1" -q \
      --source-snapshot "${BUILD_ID}-ssd1" --type "$DISK_TYPE" --size="$DISK1_SIZE"
    exec_gcloud_cmd disks create "${INSTANCE_NAME}-d2" -q \
      --source-snapshot "${BUILD_ID}-ssd2" --type "$DISK_TYPE" --size="$DISK2_SIZE"
    record_step $step $step_file
    ;;

  2)
    echo ${USER}:$(cat /home/${USER}/.ssh/id_rsa.pub) > /tmp/keys
    echo plumgrid:$(echo ${COMMON_KEY}) >> /tmp/keys
    echo "Creating the instance[$INSTANCE_NAME] in the cloud"
    exec_gcloud_cmd instances create "${INSTANCE_NAME}" -q\
      --machine-type "$MACHINE_TYPE" --network "$NETWORK" --maintenance-policy \
      "MIGRATE" --scopes "$SCOPES" \
      --disk "name=${INSTANCE_NAME}-d1" "mode=rw" "boot=yes" "auto-delete=yes" \
      --disk "name=${INSTANCE_NAME}-d2" "mode=rw" "boot=no" "auto-delete=yes" --no-address --tags "no-ip" \
      --metadata-from-file sshKeys=/tmp/keys  --metadata email="$emailid"
    record_step $step $step_file
    ;;

  3)
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
    ssh-keygen -R ${INSTANCE_IP}
    echo "Waiting for the machine to boot up and allow ssh access"
    tryexec wait_for_instance ${INSTANCE_IP}
    record_step $step $step_file
    ;;

  4)
    echo "starting the pgdev container ${DOCK_NAME}"
    tryexec run_dock_container ${INSTANCE_IP} ${DOCK_NAME} "./local_docker_id" "./local_docker_ip"
    record_step $step $step_file
    ;;

  5)
    echo "Copy build-instance key to pgdev container"
    run_cmd_gci ${INSTANCE_IP} "rm -f ~/.ssh/id_rsa*"
    run_cmd_gci ${INSTANCE_IP} "ssh-keygen -t rsa -N \"\" -f ~/.ssh/id_rsa"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo su -c \"cat /home/${USER}/.ssh/id_rsa.pub >> \
      /var/lib/docker/btrfs/subvolumes/\`cat local_docker_id\`/home/plumgrid/.ssh/authorized_keys\""
    record_step $step $step_file
    ;;

  6)
    echo "Copy local key to pgdev container"
    tryexec scp -o StrictHostKeyChecking=no ~/.ssh/id_rsa.pub ${USER}@${INSTANCE_IP}:./auth-key.pub
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo su -c \"cat /home/${USER}/auth-key.pub >> \
      /var/lib/docker/btrfs/subvolumes/\`cat local_docker_id\`/home/plumgrid/.ssh/authorized_keys\""
    record_step $step $step_file
    ;;

  7)
    check_ssh_server_status ${INSTANCE_IP}
    if [[ $retval == 1 ]]; then
      run_cmd_gci ${INSTANCE_IP} "sudo docker ps"
      echo "Dokcer stopped.. Please run aurora build with --continue to retry!!"
      record_step 3 $step_file
      exit $retval
    fi

    record_step $step $step_file
    ;;
  8)
    if [[ $LOCAL_CHANGES == 1 ]]; then
      tryexec push_local_changes ${INSTANCE_IP} ${COMMIT_ID} ${ALPS_PATH}
      tryexec make_install_alps ${INSTANCE_IP} "/tmp/make_install_alps.log"
      tryexec run_poll_cmd ${INSTANCE_IP} "make_install_alps.sh" "/tmp/make_install_alps.log" "1"
      record_step $step $step_file
    fi
    ;;
  9)
    # This is here only untill https://gerrit:8443/#/c/10751/ gets merged.
    echo "Execute the pre run-automaton on docker container"
    local local_file=$(mktemp /tmp/container_preinit.sh-XXXXX)
    cat /dev/null > ${local_file}
    echo "#!/bin/bash" >> ${local_file}
    echo "sed -i '/restart_lxc lvm/a tryexec lxc-attach -n lvm -- /bin/bash -c \"echo 'NOZEROCONF=true' >> /etc/sysconfig/network\"' /opt/pg/systest/lxc/automaton/automaton-helpers.sh" >> ${local_file}
    echo "rm -f /opt/pg/var/www/temp" >> ${local_file}
    echo "ln -s  /opt/pg/web/temp /opt/pg/var/www/" >> ${local_file}
    if [[ $SKIP_AUTOMATON_INIT == 1 ]]; then
      echo "sudo cp /etc/hosts /tmp" >> ${local_file}
      echo "sudo umount /etc/hosts" >> ${local_file}
      echo "sudo mv /tmp/hosts /etc/hosts" >> ${local_file}
      echo "sudo cp /etc/resolv.conf /tmp" >> ${local_file}
      echo "sudo umount /etc/resolv.conf" >> ${local_file}
      echo "sudo mv /tmp/resolv.conf /etc/resolv.conf" >> ${local_file}
    fi
    tryexec upload_to_docker ${INSTANCE_IP}  ${local_file} ${local_file}
    rm ${local_file}
    tryexec run_cmd_docker ${INSTANCE_IP} "/bin/bash ${local_file}"
    record_step $step $step_file
    ;;

  10)
    if [[ $SKIP_AUTOMATON_INIT != 1 ]]; then
      echo "Execute the run-automaton script on docker container"
      tryexec run_automaton_init ${INSTANCE_IP} "/tmp/automaton_init.log"
      record_step $step $step_file
    fi
    ;;

  11)
    if [[ $SKIP_AUTOMATON_INIT != 1 ]]; then
      echo "Poll the automaton-init cmd (tailing \"/tmp/automaton_init.log\" for complete logs)"
      tryexec run_poll_cmd ${INSTANCE_IP} "run_automaton_init.sh" "/tmp/automaton_init.log" "1"
      download_from_docker ${INSTANCE_IP} "/tmp/automaton_init.log" "${WORKSPACE}/logs/automaton_init_${INSTANCE_NAME}.log"
      record_step $step $step_file
    fi
    ;;

  12)
    tryexec upload_to_docker ${INSTANCE_IP} ${TEST_SCRIPT} /tmp/user_test_script.sh
    # tryexec is not needed because test can fail as well
    run_cmd_docker_bg ${INSTANCE_IP} "/bin/bash /tmp/user_test_script.sh" "/tmp/test.logs"
    record_step $step $step_file
    ;;

  13)
    echo "Poll the test logs (tailing \"/tmp/test.log\")"
    tryexec run_poll_cmd ${INSTANCE_IP} "/tmp/user_test_script.sh" "/tmp/test.logs" "0"
    tryexec download_from_docker ${INSTANCE_IP} "/tmp/test.logs" "${WORKSPACE}/logs/${INSTANCE_NAME}.log"
    record_step $step $step_file
    ;;

  14)
    echo "Downloading logs in ${LOG_DIR} directory"
    tryexec get_latest_logs ${INSTANCE_IP} ${INSTANCE_NAME} ${LOG_DIR}
    record_step $step $step_file
    ;;

  15)
    echo "Shutting down the Instance ${INSTANCE_NAME}"
    exec_gcloud_cmd instances delete ${INSTANCE_NAME} --delete-disks all  -q
    rm $step_file
    printf "\n\n********* Run has been completed successfully. Please see all logs in ${LOG_DIR} direcotry *********\n\n"
    ;;

  *)
    echo "NOP - $step"
  ;;
  esac
}

for MAJOR_STEP in $MAJOR_STEPS; do
  echo " ====== Starting STEP [$MAJOR_STEP] Number of Steps ::${MINOR_STEPS_ST[$MAJOR_STEP]} -> ${MINOR_STEPS_ED[$MAJOR_STEP]}  ======"
  for MINOR_STEP in `seq ${MINOR_STEPS_ST[$MAJOR_STEP]} ${MINOR_STEPS_ED[$MAJOR_STEP]}`; do
    echo "    === Starting STEP [$MAJOR_STEP][$MINOR_STEP] ==="
    case "$MAJOR_STEP" in
      run)
        start_time=$(date +%s)
        run_test $MINOR_STEP
        end_time=$(date +%s)
        print_time_taken $start_time $end_time "[$MAJOR_STEP][$MINOR_STEP]"
      ;;
      *)
        echo "UNKNOWN STEP $MAJOR_STEP.$MINOR_STEP"
      ;;
    esac
    if [ -n "$STOP" ] ; then
      exit
    fi
  done
done
