#!/bin/bash -e
source help.sh

echo "aurora_run.sh started with [aurora_run.sh  $@]"
ARGS="$@"

export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
. gc_helpers.sh
. aurora_utils.sh
source /home/$USER/.aurora.conf
source aurora_infra_settings.conf

#Show help
if [[ $1 == "help" ]]; then
  show_run_help
  exit 1
fi
#Starting and ending steps
STEP_ST=1
STEP_ED=13

UUID=`uuidgen`
SUUID_="${UUID##*-}"
SUUID="${SUUID_,,}"
TAG="none"
CONTINUE=0
KEEP_RUNNING=0
LOCAL_CHANGES=0

# read the options
TEMP=`getopt -o l:s:o:n:W:t:CKc:e:a:R:E:h --long buildid:,script:,log_dir:,runid:,WORKSPACE:,tag:,\continue,keep-running,local_commit:,existing_commit_hash:,alps-path:,minor_st:,minor_end:,\help -n 'aurora.sh' -- "$@"`
eval set -- "$TEMP"
while true ; do
  case "$1" in
    #Basic Funtionality
    -l| --buildid ) BUILD_ID=$2; shift 2 ;;
    -s| --script ) TEST_SCRIPT=$2; shift 2 ;;
    -o| --log_dir) LOG_DIR=$2; shift 2 ;;
    -n| --runid ) RUNID=$2 ; shift 2 ;;
    -W| --WORKSPACE) export WORKSPACE=$2 ; shift 2 ;;
    -t| --tag) TAG=$2 ; shift 2 ;;
    -C| --continue ) CONTINUE=1; shift ;;
    -K| --keep-running ) KEEP_RUNNING=1; shift ;;
    #Local changes flags
    -c| --local_commit) COMMIT_ID=$2; shift 2;;
    -e|--existing_commit_hash) EXISTING_COMMIT_HASH=$2 ; shift 2 ;;
    -a| --alps-path) ALPS_PATH=$2; shift 2;;
    #Start-End steps
    -R| --minor_st ) MINOR_STEPS_ST[$MAJOR_STEPS]="$2"; shift 2 ;;
    -E| --minor_end ) MINOR_STEPS_ED[$MAJOR_STEPS]="$2"; shift 2 ;;
    -h| --help ) show_run_help;exit 0; shift ;;
    --) shift ; break ;;
    *) exit 1 ;;
  esac
done
#Check required Arguments
if [[ -z "$BUILD_ID" ]]; then
  echo "Required argument -l(--buildid)"
  show_run_help
  exit 1
fi

if [[ -z "$LOG_DIR" ]]; then
  LOG_DIR="${WORKSPACE}/logs/"
fi

mkdir -p $LOG_DIR
echo "Logs will be stored in $LOG_DIR"
echo "aurora_run.sh started with [aurora_run.sh  $ARGS]" > $LOG_DIR/aurora_run_command_$SUUID

BUILD_ID=${emailid}-${BUILD_ID}
MOD_BUILD_ID=$(echo ${BUILD_ID} | sed 's/bld/run/')
INSTANCE_NAME=${MOD_BUILD_ID}
#Append tag if provided
if [[ $TAG != "none" ]]; then
  #Only keeping alphanumeric characters
  TAG=${TAG//[^[:alnum:]]/}
  #Converting to lowercase since instance name cannot contain uppercase characters
  TAG=${TAG,,}
  INSTANCE_NAME=${INSTANCE_NAME}-${TAG}
fi

INSTANCE_NAME=${INSTANCE_NAME}-${SUUID}
if [ ${#INSTANCE_NAME} -gt "58" ]; then
    echo "Instance name is too long, try a shorter TAG, exiting."
    exit 1
fi

if [[ $KEEP_RUNNING == "1" ]]; then
  STEP_ED=`expr $STEP_ED - 1`
fi
#Validate Inputs
check_run_inputs $BUILD_ID
#Check test script file
if [[ -n $TEST_SCRIPT ]]; then
  check_file_existence $TEST_SCRIPT
else
  STEP_ED=9
fi
#Check /home/$USER/.ssh/id_rsa.pub file
check_file_existence "/home/$USER/.ssh/id_rsa.pub"

step_file=$LOG_DIR/${INSTANCE_NAME}-last-successful-step

# If "continue" switch has been given then do following steps
#   a. Get the RUN-ID provided by user.
#   b. Get the last successfully completed step.
#   c. Start the run process from step next to last completed step.
if [[ $CONTINUE == "1" ]] ; then
  # User must give the run-id(SUUID generated during first time execution of run process.)
  # along with continue such that we can know that which "aurora run" he needs to resume.
  # TODO: Exit if user does not give the run-id.
  if [ -z ${RUNID+x} ]; then
    echo "Please provide the RUN-ID which you want to continue e.g. f82ba2b78256"
    exit
  fi
  INSTANCE_NAME=$(echo "${INSTANCE_NAME}" | sed "s/[^-]*$//")
  INSTANCE_NAME=${INSTANCE_NAME}${RUNID}
  step_file=$LOG_DIR/${INSTANCE_NAME}-last-successful-step
  #Continue only if file exists
  if [[ ! -f $step_file ]]; then
    echo "No last successful step file ${step_file}, cannot resume. Exiting"
    exit 1
  fi
  LAST_SUCCESSFULL_STEP=( $(<${step_file}) )
  STEP_ST=$((LAST_SUCCESSFULL_STEP+1))
  SUUID=$RUNID
  #Only get the IP address if the instance has already been created.
  if [[ $LAST_SUCCESSFULL_STEP -gt 2 ]]; then
    #Get the IP address of the instances, needed incase continue is specified.
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
  fi
else
  check_instance_limit
fi

#Create file to ensure continue works if run/build is aborted before 1st step completes
touch $step_file

printf "\n\n********* RUNID= ${SUUID} *********\n\n"

if [[ $EXISTING_COMMIT_HASH != "null" ]]; then
  VALID_COMMIT_HASH="true"
  #VALID_COMMIT_HASH=$(valid_commit_hash $ALPS_PATH $EXISTING_COMMIT_HASH)
  #if [[ $VALID_COMMIT_HASH == "false" ]];then
  #  exit 1
  #fi
fi

function run_test() {
  local step=$1

  case "$step" in
  1)
    echo "Creating the disk[${INSTANCE_NAME}-d1] for the instance in the cloud from ${BUILD_ID}"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d1" -q \
      --source-snapshot "${BUILD_ID}-ssd1" --type "$DISK_TYPE" --size="$DISK1_SIZE"
    record_step $step $step_file
    ;;

  2)
    echo "Creating the disk[${INSTANCE_NAME}-d2] for the instance in the cloud from ${BUILD_ID}"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d2" -q \
      --source-snapshot "${BUILD_ID}-ssd2" --type "$DISK_TYPE" --size="$DISK2_SIZE"
    record_step $step $step_file
    ;;

  3)
    local key_file=$(mktemp $WORKSPACE/keys-XXXXX)
    echo plumgrid:$(cat /home/${USER}/.ssh/id_rsa.pub) > ${key_file}
    echo plumgrid:$(echo ${COMMON_KEY}) >> ${key_file}
    echo "Creating the instance[$INSTANCE_NAME] in the cloud"
    tryexec exec_gcloud_cmd instances create "${INSTANCE_NAME}" -q\
      --machine-type "$MACHINE_TYPE" --network "$NETWORK" --maintenance-policy \
      "MIGRATE" --scopes "$SCOPES" \
      --disk "name=${INSTANCE_NAME}-d1" "mode=rw" "boot=yes" "auto-delete=yes" \
      --disk "name=${INSTANCE_NAME}-d2" "mode=rw" "boot=no" "auto-delete=yes" --no-address --tags "no-ip" \
      --metadata-from-file sshKeys=$key_file
    rm $key_file
    record_step $step $step_file
    ;;

  4)
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
    echo "Waiting for the machine to boot up and allow ssh access"
    tryexec wait_for_instance ${INSTANCE_IP}
    record_step $step $step_file
    ;;

  5)
    echo "Changing MTU on the instance"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo ifconfig eth0 mtu 1400"
    tryexec run_cmd_gci ${INSTANCE_IP} "DT=\$(ifconfig eth0 | grep 'inet addr' | cut -d: -f2|cut -d' ' -f 1); sudo bash -c 'echo \"'\$DT'  \`hostname\`\" >> /etc/hosts'"
    record_step $step $step_file
    ;;

  6)
    if [[ -n "$COMMIT_ID" ]]; then
      tryexec push_local_changes ${INSTANCE_IP} ${COMMIT_ID} ${ALPS_PATH}
      tryexec make_install_alps ${INSTANCE_IP} "/tmp/make_install_alps.log"
      retryexec run_poll_cmd ${INSTANCE_IP} "make_install_alps.sh" "/tmp/make_install_alps.log" "1"
      record_step $step $step_file
    fi
    ;;

  7)
    if [[ $VALID_COMMIT_HASH == "true" ]];then
      tryexec checkout_existing_commit ${INSTANCE_IP} ${EXISTING_COMMIT_HASH} /tmp/checkout_existing_commit.log
      retryexec run_poll_cmd ${INSTANCE_IP} "checkout_existing_commit.sh" "/tmp/checkout_existing_commit.log" "1"
    fi
    ;;

  8)
    # This is here only untill https://gerrit:8443/#/c/10751/ gets merged.
    echo "Execute the pre run-automaton"

    local local_file=$(mktemp $WORKSPACE/container_preinit.sh-XXXXX)
    cat /dev/null > ${local_file}
    echo "#!/bin/bash" >> ${local_file}
    echo "sed -i '/restart_lxc lvm/a tryexec lxc-attach -n lvm -- /bin/bash -c \"echo 'NOZEROCONF=true' >> /etc/sysconfig/network\"' /opt/pg/systest/lxc/automaton/automaton-helpers.sh" >> ${local_file}
    echo "rm -f /opt/pg/var/www/temp" >> ${local_file}
    echo "ln -s  /opt/pg/web/temp /opt/pg/var/www/" >> ${local_file}

    file_name=/tmp/$(basename ${local_file})
    tryexec upload ${INSTANCE_IP}  ${local_file} ${file_name}
    rm ${local_file}
    tryexec run_cmd_gci ${INSTANCE_IP} "/bin/bash ${file_name}"
    record_step $step $step_file
    ;;

  9)
    echo "Restarting lxc-net service"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo ifconfig lxcbr0 down"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo brctl delbr lxcbr0"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo pkill dnsmasq || true"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo service lxc-net restart"
    record_step $step $step_file
    ;;

  10)
    tryexec upload ${INSTANCE_IP} ${TEST_SCRIPT} /tmp/user_test_script.sh
    # tryexec is not needed because test can fail as well
    tryexec run_cmd_gci_bg ${INSTANCE_IP} "/bin/bash /tmp/user_test_script.sh" "/tmp/test.logs"
    record_step $step $step_file
    ;;

  11)
    echo "Poll the test logs (tailing \"/tmp/test.log\")"
    tryexec run_poll_cmd ${INSTANCE_IP} "/tmp/user_test_script.sh" "/tmp/test.logs" "0"
    tryexec download ${INSTANCE_IP} "/tmp/test.logs" "${LOG_DIR}/${INSTANCE_NAME}.log"
    record_step $step $step_file
    ;;

  12)
    echo "Downloading logs in ${LOG_DIR} directory"
    tryexec get_latest_logs ${INSTANCE_IP} ${INSTANCE_NAME} ${LOG_DIR}
    printf "\n\n********* Run has been completed successfully. Please see all logs in ${LOG_DIR} direcotry *********\n\n"
    record_step $step $step_file
    ;;

  13)
    echo "Shutting down the Instance ${INSTANCE_NAME}"
    tryexec exec_gcloud_cmd instances delete ${INSTANCE_NAME} --delete-disks all  -q
    rm $step_file
    ;;

  *)
    echo "NOP - $step"
  ;;
  esac
}

script_start_time=$(date +%s)
for STEP in `seq ${STEP_ST} ${STEP_ED}`; do
  printf "\n    === Starting STEP $STEP === \n"
  start_time=$(date +%s)
  run_test $STEP
  end_time=$(date +%s)
  print_time_taken $start_time $end_time "[$STEP]"
done
script_end_time=$(date +%s)
print_time_taken $script_start_time $script_end_time "[run]"
