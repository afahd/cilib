#!/bin/bash -e

echo "aurora_run.sh started with [aurora_run.sh  $@]"

export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
. gc_helpers.sh
. aurora_utils.sh
source /home/$USER/.aurora.conf
source aurora_infra_settings.conf


declare -A MINOR_STEPS_ST
declare -A MINOR_STEPS_ED
MAJOR_STEPS="build"
MINOR_STEPS_ST[run]=1
MINOR_STEPS_ED[run]=15

function usage() {
cat <<EOF
usage: $0
-c | --cleanup : Test Cleanup
-Q | --major : Jump to specific major step in the install process
-R | --minor : Jump to specific minor step in the install process
-E | --minor_end : Stop at this step when in debug
-B | --build_id: Mention the build-id on which you want to test
-T | --test: Test script to run.
-U | --test_uuid: Test unique id to use.
-O | --stop : DONT Continue beyond the specifict step to end of the installation
-h | --help : help
EOF
exit 0
}

# Parsing arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -c|--cleanup ) CLEANUP=1;  ;;
    -Q| --major ) MAJOR_STEPS="$2"; TMP_MAJOR="$2"; shift ;;
    -R| --minor ) MINOR_STEPS_ST[$TMP_MAJOR]="$2"; shift ;;
    -E| --minor ) MINOR_STEPS_ED[$TMP_MAJOR]="$2"; shift ;;
    -B| --build_id ) BUILD_ID=$2; shift ;;
    -T| --test_script ) TEST_SCRIPT=$2; shift ;;
    -I| --instance_name ) INSTANCE_NAME=$2; shift ;;
    -U| --test_uuid ) SUUID=$2; shift ;;
    -O| --stop ) STOP=1; ;;
    -h| --help ) usage; ;;
    --skip-automaton-init ) SKIP_AUTOMATON_INIT="$2"; shift ;;
    -- ) shift; break ;;
    * )
      echo "Unknown parameter: $1";
      usage; break;;
  esac
  shift
done

printf "\n\n********* RUNID= ${SUUID} *********\n\n"
if [ -z ${SUUID+x} ]; then
  echo "Input parameter -U is required"
  exit 1
fi
step_file=/tmp/${INSTANCE_NAME}-last-successful-step

# TODO: Get the latest snapshot id and use that in below variables
DOCK_NAME="pg_dev_${BUILD_ID}:latest"
INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})

function run_test() {
  local step=$1

  case "$step" in
  1)
    echo "Creating the disk[${INSTANCE_NAME}-d1] and [${INSTANCE_NAME}-d2] for the instance in the cloud from ${BUILD_ID}"
    tryexec gcloud -q --verbosity ${VERBOSITY} compute disks create "${INSTANCE_NAME}-d1" \
      --source-snapshot "${BUILD_ID}-ssd1" --type "$DISK_TYPE" --size="$DISK1_SIZE"
    tryexec gcloud -q --verbosity ${VERBOSITY} compute disks create "${INSTANCE_NAME}-d2" \
      --source-snapshot "${BUILD_ID}-ssd2" --type "$DISK_TYPE" --size="$DISK2_SIZE"
    record_step $step $step_file
    ;;

  2)
    echo ${USER}:$(cat /home/${USER}/.ssh/id_rsa.pub) > /tmp/keys
    echo plumgrid:$(echo ${COMMON_KEY}) >> /tmp/keys
    echo "Creating the instance[$INSTANCE_NAME] in the cloud"
    tryexec gcloud -q --verbosity ${VERBOSITY} compute instances create "${INSTANCE_NAME}" \
      --machine-type "$MACHINE_TYPE" --network "$NETWORK" --maintenance-policy \
      "MIGRATE" --scopes "$SCOPES" \
      --disk "name=${INSTANCE_NAME}-d1" "mode=rw" "boot=yes" "auto-delete=yes" \
      --disk "name=${INSTANCE_NAME}-d2" "mode=rw" "boot=no" "auto-delete=yes" --no-address --tags "no-ip" \
      --metadata-from-file sshKeys=/tmp/keys
    record_step $step $step_file
    ;;

  3)
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
    echo "Waiting for the machine to boot up and allow ssh access"
    tryexec wait_for_instance ${INSTANCE_IP}
    record_step $step $step_file
    ;;

  4)
    echo "starting the pgdev container ${DOCK_NAME}"
    tryexec run_dock_container ${INSTANCE_IP} ${DOCK_NAME} "./local_docker_id" "./local_docker_ip"
    record_step $step $step_file
    ;;

  5)
    echo "Copy build-instance key to pgdev container"
    run_cmd_gci ${INSTANCE_IP} "rm -f ~/.ssh/id_rsa*"
    run_cmd_gci ${INSTANCE_IP} "ssh-keygen -t rsa -N \"\" -f ~/.ssh/id_rsa"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo su -c \"cat /home/${USER}/.ssh/id_rsa.pub >> \
      /var/lib/docker/btrfs/subvolumes/\`cat local_docker_id\`/home/plumgrid/.ssh/authorized_keys\""
    record_step $step $step_file
    ;;

  6)
    echo "Copy local key to pgdev container"
    tryexec scp -o StrictHostKeyChecking=no ~/.ssh/id_rsa.pub ${USER}@${INSTANCE_IP}:./auth-key.pub
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo su -c \"cat /home/${USER}/auth-key.pub >> \
      /var/lib/docker/btrfs/subvolumes/\`cat local_docker_id\`/home/plumgrid/.ssh/authorized_keys\""
    record_step $step $step_file
    ;;

  7)
    check_ssh_server_status ${INSTANCE_IP}
    if [[ $retval == 1 ]]; then
      run_cmd_gci ${INSTANCE_IP} "sudo docker ps"
      echo "Dokcer stopped.. Please run aurora build with --continue to retry!!"
      record_step 3 $step_file
      exit $retval
    fi

    record_step $step $step_file
    ;;

  8)
    # This is here only untill https://gerrit:8443/#/c/10751/ gets merged.
    echo "Execute the pre run-automaton on docker container"
    local local_file=$(mktemp /tmp/container_preinit.sh-XXXXX)
    cat /dev/null > ${local_file}
    echo "#!/bin/bash" >> ${local_file}
    echo "sed -i '/restart_lxc lvm/a tryexec lxc-attach -n lvm -- /bin/bash -c \"echo 'NOZEROCONF=true' >> /etc/sysconfig/network\"' /opt/pg/systest/lxc/automaton/automaton-helpers.sh" >> ${local_file}
    echo "rm -f /opt/pg/var/www/temp" >> ${local_file}
    echo "ln -s  /opt/pg/web/temp /opt/pg/var/www/" >> ${local_file}
    if [[ $SKIP_AUTOMATON_INIT == 1 ]]; then
      echo "sudo cp /etc/hosts /tmp" >> ${local_file}
      echo "sudo umount /etc/hosts" >> ${local_file}
      echo "sudo mv /tmp/hosts /etc/hosts" >> ${local_file}
      echo "sudo cp /etc/resolv.conf /tmp" >> ${local_file}
      echo "sudo umount /etc/resolv.conf" >> ${local_file}
      echo "sudo mv /tmp/resolv.conf /etc/resolv.conf" >> ${local_file}
    fi
    tryexec upload_to_docker ${INSTANCE_IP}  ${local_file} ${local_file}
    rm ${local_file}
    tryexec run_cmd_docker ${INSTANCE_IP} "/bin/bash ${local_file}"
    record_step $step $step_file
    ;;

  9)
    if [[ $SKIP_AUTOMATON_INIT != 1 ]]; then
      echo "Execute the run-automaton script on docker container"
      tryexec run_cmd_docker_sshforwarding_bg ${INSTANCE_IP} "/bin/bash run_automaton_init.sh" "/tmp/automaton_init.log"
      record_step $step $step_file
    fi
    ;;

  10)
    if [[ $SKIP_AUTOMATON_INIT != 1 ]]; then
      echo "Poll the automaton-init cmd (tailing \"/tmp/automaton_init.log\" for complete logs)"
      tryexec run_poll_cmd ${INSTANCE_IP} "run_automaton_init.sh" "/tmp/automaton_init.log"
      download_from_docker ${INSTANCE_IP} "/tmp/automaton_init.log" "${WORKSPACE}/logs/"
      record_step $step $step_file
    fi
    ;;

  11)
    tryexec upload_to_docker ${INSTANCE_IP} ${TEST_SCRIPT} /tmp/user_test_script.sh
    # tryexec is not needed because test can fail as well
    run_cmd_docker_bg ${INSTANCE_IP} "/bin/bash /tmp/user_test_script.sh" "/tmp/test.logs"
    record_step $step $step_file
    ;;

  12)
    echo "Poll the test logs (tailing \"/tmp/test.log\")"
    tryexec run_poll_cmd ${INSTANCE_IP} "/tmp/user_test_script.sh" "/tmp/test.logs"
    download_from_docker ${INSTANCE_IP} "/tmp/test.logs" "${WORKSPACE}/logs/${INSTANCE_IP}.log"
    record_step $step $step_file
    ;;

  13)
    tryexec get_latest_logs ${INSTANCE_IP}
    record_step $step $step_file
    ;;

  14)
    echo "Shutting down the Instance ${INSTANCE_NAME}"
    tryexec gcloud compute instances delete ${INSTANCE_NAME} --delete-disks all  -q
    rm $step_file
    ;;

  *)
    echo "NOP - $step"
  ;;
  esac
}

for MAJOR_STEP in $MAJOR_STEPS; do
  echo " ====== Starting STEP [$MAJOR_STEP] Number of Steps ::${MINOR_STEPS_ST[$MAJOR_STEP]} -> ${MINOR_STEPS_ED[$MAJOR_STEP]}  ======"
  for MINOR_STEP in `seq ${MINOR_STEPS_ST[$MAJOR_STEP]} ${MINOR_STEPS_ED[$MAJOR_STEP]}`; do
    echo "    === Starting STEP [$MAJOR_STEP][$MINOR_STEP] ==="
    case "$MAJOR_STEP" in
      # init)
      # build_image $MINOR_STEP
      # ;;
      run)
        start_time=$(date +%s)
        run_test $MINOR_STEP
        end_time=$(date +%s)
        print_time_taken $start_time $end_time "[$MAJOR_STEP][$MINOR_STEP]"
      ;;
      *)
        echo "UNKNOWN STEP $MAJOR_STEP.$MINOR_STEP"
      ;;
    esac
    if [ -n "$STOP" ] ; then
      exit
    fi
  done
done
