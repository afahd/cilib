#!/bin/bash -e
source help.sh

echo "aurora_run.sh started with [aurora_run.sh  $@]"
ARGS="$@"

export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
. gc_helpers.sh
. aurora_utils.sh
source /home/$USER/.aurora.conf
source aurora_infra_settings.conf

#Show help
if [[ $1 == "help" ]]; then
  show_run_help
  exit 1
fi
#Starting and ending steps
declare -A MINOR_STEPS_ST
declare -A MINOR_STEPS_ED
MAJOR_STEPS="run"
MINOR_STEPS_ST[$MAJOR_STEPS]=1
MINOR_STEPS_ED[$MAJOR_STEPS]=13

UUID=`uuidgen`
SUUID_="${UUID##*-}"
SUUID="${SUUID_,,}"
TAG="none"
AUTOMATON_INIT=0
CONTINUE=0
KEEP_RUNNING=0
LOCAL_CHANGES=0

# read the options
TEMP=`getopt -o l:s:o:n:t:W:CAKhc:a:R:E: --long buildid:,tag:,script:,log_dir:,runid:,WORKSPACE:,\continue,automaton-init,keep-running,\help,commit:,alps-path:,minor_st:,minor_end: -n 'aurora.sh' -- "$@"`
eval set -- "$TEMP"
while true ; do
  case "$1" in
#Basic Funtionality
    -l| --buildid ) BUILD_ID=$2; shift 2 ;;
    -s| --script ) TEST_SCRIPT=$2; shift 2 ;;
    -o| --log_dir) LOG_DIR=$2; shift 2 ;;
    -n| --runid ) RUNID=$2 ; shift 2 ;;
    -W| --WORKSPACE) export WORKSPACE=$2 ; shift 2 ;;
    -t| --tag) TAG=$2 ; shift 2 ;;
    -C| --continue ) CONTINUE=1; shift ;;
    -A| --automaton-init ) AUTOMATON_INIT=1; shift ;;
    -K| --keep-running ) KEEP_RUNNING=1; shift ;;
    -h| --help ) show_run_help;exit 0; shift ;;
#Local changes flags
    -c| --commit) COMMIT_ID=$2; shift 2;;
    -a| --alps-path) ALPS_PATH=$2; shift 2;;
#Start-End steps
    -R| --minor_st ) MINOR_STEPS_ST[$MAJOR_STEPS]="$2"; shift 2 ;;
    -E| --minor_end ) MINOR_STEPS_ED[$MAJOR_STEPS]="$2"; shift 2 ;;
    --) shift ; break ;;
    *) exit 1 ;;
  esac
done
#Check required Arguments
if [[ -z "$BUILD_ID" ]]; then
  echo "Required argument -l(--buildid)"
  show_run_help
  exit 1
fi

if [[ -z "$LOG_DIR" ]]; then
  LOG_DIR="${WORKSPACE}/logs/"
fi

mkdir -p $LOG_DIR
echo "Logs will be stored in $LOG_DIR"
echo "aurora_run.sh started with [aurora_run.sh  $ARGS]" > ${WORKSPACE}/logs/aurora_run_command_$SUUID

BUILD_ID=${emailid}-${BUILD_ID}
MOD_BUILD_ID=$(echo ${BUILD_ID} | sed 's/bld/run/')
INSTANCE_NAME=${MOD_BUILD_ID}
#Append tag if provided
if [[ $TAG != "none" ]]; then
  #Only keeping alphanumeric characters
  TAG=${TAG//[^[:alnum:]]/}
  #Converting to lowercase since instance name cannot contain uppercase characters
  TAG=${TAG,,}
  INSTANCE_NAME=${INSTANCE_NAME}-${TAG}
fi

INSTANCE_NAME=${INSTANCE_NAME}-${SUUID}


if [ ${#INSTANCE_NAME} -gt "58" ]; then
    echo "Instance name is too long, try a shorter TAG, exiting."
    exit 1
fi

if [[ $KEEP_RUNNING == "1" ]]; then
  MINOR_STEPS_ED[$MAJOR_STEPS]=12
fi
#Validate Inputs
check_run_inputs $BUILD_ID
#Check test script file
if [[ -n $TEST_SCRIPT ]]; then
  check_file_existence $TEST_SCRIPT
else
  MINOR_STEPS_ED[$MAJOR_STEPS]=9
fi
#Check /home/$USER/.ssh/id_rsa.pub file
check_file_existence "/home/$USER/.ssh/id_rsa.pub"

step_file=$LOG_DIR/${INSTANCE_NAME}-last-successful-step

# If "continue" switch has been given then do following steps
#   a. Get the RUN-ID provided by user.
#   b. Get the last successfully completed step.
#   c. Start the run process from step next to last completed step.
if [[ $CONTINUE == "1" ]] ; then
  # User must give the run-id(SUUID generated during first time execution of run process.)
  # along with continue such that we can know that which "aurora run" he needs to resume.
  # TODO: Exit if user does not give the run-id.
  if [ -z ${RUNID+x} ]; then
    echo "Please provide the RUN-ID which you want to continue e.g. f82ba2b78256"
    exit
  fi
  INSTANCE_NAME=$(echo "${INSTANCE_NAME}" | sed "s/[^-]*$//")
  INSTANCE_NAME=${INSTANCE_NAME}${RUNID}
  step_file=$LOG_DIR/${INSTANCE_NAME}-last-successful-step
  #Continue only if file exists
  if [[ ! -f $step_file ]]; then
    echo "No last successful step file ${step_file}, cannot resume. Exiting"
    exit 1
  fi

  LAST_SUCCESSFULL_STEP=( $(<${step_file}) )
  MINOR_STEPS_ST[$MAJOR_STEPS]=$((LAST_SUCCESSFULL_STEP+1))
  SUUID=$RUNID
else
  check_instance_limit
fi

#Create file to ensure continue works if run/build is aborted before 1st step completes
touch $step_file
INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})

printf "\n\n********* RUNID= ${SUUID} *********\n\n"

function run_test() {
  local step=$1

  case "$step" in
  1)
    echo "Creating the disk[${INSTANCE_NAME}-d1] for the instance in the cloud from ${BUILD_ID}"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d1" -q \
      --source-snapshot "${BUILD_ID}-ssd1" --type "$DISK_TYPE" --size="$DISK1_SIZE"
    record_step $step $step_file
    ;;

  2)
    echo "Creating the disk[${INSTANCE_NAME}-d2] for the instance in the cloud from ${BUILD_ID}"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d2" -q \
      --source-snapshot "${BUILD_ID}-ssd2" --type "$DISK_TYPE" --size="$DISK2_SIZE"
    record_step $step $step_file
    ;;

  3)
    local key_file=$(mktemp $WORKSPACE/keys-XXXXX)
    echo plumgrid:$(cat /home/${USER}/.ssh/id_rsa.pub) > ${key_file}
    echo plumgrid:$(echo ${COMMON_KEY}) >> ${key_file}
    echo "Creating the instance[$INSTANCE_NAME] in the cloud"
    tryexec exec_gcloud_cmd instances create "${INSTANCE_NAME}" -q\
      --machine-type "$MACHINE_TYPE" --network "$NETWORK" --maintenance-policy \
      "MIGRATE" --scopes "$SCOPES" \
      --disk "name=${INSTANCE_NAME}-d1" "mode=rw" "boot=yes" "auto-delete=yes" \
      --disk "name=${INSTANCE_NAME}-d2" "mode=rw" "boot=no" "auto-delete=yes" --no-address --tags "no-ip" \
      --metadata-from-file sshKeys=$key_file
    rm $key_file
    record_step $step $step_file
    ;;

  4)
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
    echo "Waiting for the machine to boot up and allow ssh access"
    tryexec wait_for_instance ${INSTANCE_IP}
    record_step $step $step_file
    ;;

  5)
    check_ssh_server_status ${INSTANCE_IP}
    if [[ $retval == 1 ]]; then
      echo "SSH server is not running on cloud instance"
      exit $retval
    fi
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo ifconfig eth0 mtu 1400"
    tryexec run_cmd_gci ${INSTANCE_IP} "DT=\$(ifconfig eth0 | grep 'inet addr' | cut -d: -f2|cut -d' ' -f 1); sudo bash -c 'echo \"'\$DT'  \`hostname\`\" >> /etc/hosts'"
    record_step $step $step_file
    ;;

  6)
    if [[ -n "$COMMIT_ID" ]]; then
      tryexec push_local_changes ${INSTANCE_IP} ${COMMIT_ID} ${ALPS_PATH}
      tryexec make_install_alps ${INSTANCE_IP} "/tmp/make_install_alps.log"
      retryexec run_poll_cmd ${INSTANCE_IP} "make_install_alps.sh" "/tmp/make_install_alps.log" "1"
      record_step $step $step_file
    fi
    ;;

  7)
    # This is here only untill https://gerrit:8443/#/c/10751/ gets merged.
    echo "Execute the pre run-automaton"
    local local_file=$(mktemp $WORKSPACE/container_preinit.sh-XXXXX)
    cat /dev/null > ${local_file}
    echo "#!/bin/bash" >> ${local_file}
    echo "sed -i '/restart_lxc lvm/a tryexec lxc-attach -n lvm -- /bin/bash -c \"echo 'NOZEROCONF=true' >> /etc/sysconfig/network\"' /opt/pg/systest/lxc/automaton/automaton-helpers.sh" >> ${local_file}
    echo "rm -f /opt/pg/var/www/temp" >> ${local_file}
    echo "ln -s  /opt/pg/web/temp /opt/pg/var/www/" >> ${local_file}
    file_name=/tmp/$(basename ${local_file})
    tryexec upload ${INSTANCE_IP}  ${local_file} ${file_name}
    rm ${local_file}
    tryexec run_cmd_gci ${INSTANCE_IP} "/bin/bash ${file_name}"
    record_step $step $step_file
    ;;

  8)
    if [[ $AUTOMATON_INIT == 1 ]]; then
      echo "Execute the run-automaton script on cloud instance"
      retryexec run_cmd_gci ${INSTANCE_IP} "sudo ifconfig lxcbr0 down"
      retryexec run_cmd_gci ${INSTANCE_IP} "sudo brctl delbr lxcbr0"
      retryexec run_cmd_gci ${INSTANCE_IP} "sudo pkill dnsmasq"
      retryexec run_cmd_gci ${INSTANCE_IP} "sudo service lxc-net restart"

      tryexec run_automaton_init ${INSTANCE_IP} "/tmp/automaton_init.log"
      record_step $step $step_file
    fi
    ;;

  9)
    if [[ $AUTOMATON_INIT == 1 ]]; then
      echo "Poll the automaton-init cmd (tailing \"/tmp/automaton_init.log\" for complete logs)"
      retryexec run_poll_cmd ${INSTANCE_IP} "run_automaton_init.sh" "/tmp/automaton_init.log" "1"
      tryexec download ${INSTANCE_IP} "/tmp/automaton_init.log" "${LOG_DIR}/automaton_init_${INSTANCE_NAME}.log"
      record_step $step $step_file
    fi
    ;;

  10)
    tryexec upload ${INSTANCE_IP} ${TEST_SCRIPT} /tmp/user_test_script.sh
    # tryexec is not needed because test can fail as well
    tryexec run_cmd_gci_bg ${INSTANCE_IP} "/bin/bash /tmp/user_test_script.sh" "/tmp/test.logs"
    record_step $step $step_file
    ;;

  11)
    echo "Poll the test logs (tailing \"/tmp/test.log\")"
    tryexec run_poll_cmd ${INSTANCE_IP} "/tmp/user_test_script.sh" "/tmp/test.logs" "0"
    tryexec download ${INSTANCE_IP} "/tmp/test.logs" "${LOG_DIR}/${INSTANCE_NAME}.log"
    record_step $step $step_file
    ;;

  12)
    echo "Downloading logs in ${LOG_DIR} directory"
    tryexec get_latest_logs ${INSTANCE_IP} ${INSTANCE_NAME} ${LOG_DIR}
    record_step $step $step_file
    ;;

  13)
    echo "Shutting down the Instance ${INSTANCE_NAME}"
    tryexec exec_gcloud_cmd instances delete ${INSTANCE_NAME} --delete-disks all  -q
    rm $step_file
    printf "\n\n********* Run has been completed successfully. Please see all logs in ${LOG_DIR} direcotry *********\n\n"
    ;;

  *)
    echo "NOP - $step"
  ;;
  esac
}

for MAJOR_STEP in $MAJOR_STEPS; do
  echo " ====== Starting STEP [$MAJOR_STEP] Number of Steps ::${MINOR_STEPS_ST[$MAJOR_STEP]} -> ${MINOR_STEPS_ED[$MAJOR_STEP]}  ======"
  run_start_time=$(date +%s)
  for MINOR_STEP in `seq ${MINOR_STEPS_ST[$MAJOR_STEP]} ${MINOR_STEPS_ED[$MAJOR_STEP]}`; do
    printf "\n  === Starting STEP [$MAJOR_STEP][$MINOR_STEP] === \n"
    case "$MAJOR_STEP" in
      run)
        start_time=$(date +%s)
        run_test $MINOR_STEP
        end_time=$(date +%s)
        print_time_taken $start_time $end_time "[$MAJOR_STEP][$MINOR_STEP]"
      ;;
      *)
        echo "UNKNOWN STEP $MAJOR_STEP.$MINOR_STEP"
      ;;
    esac
    if [ -n "$STOP" ] ; then
      exit
    fi
  done
  run_end_time=$(date +%s)
  print_time_taken $run_start_time $run_end_time "[RUN]"
done
