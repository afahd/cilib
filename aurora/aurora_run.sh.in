#!/bin/bash -e
source help.sh

## The purpose of this script is to enable the developer to run scripts on gcloud instances. The instances would be created
## using the build image created. The terminal command "aurora run" translates to running this script. The pre-requisites of
## aurora run is that aurora init and aurora build (a build snaphot) is already run. Aurora run uses the build_id of the
## build snapshot (required argument when running aurora run) and then further runs the script given in the parameters of
## aurora run. Further operational details of aurora run can be seen by running "aurora run help" on the terminal.
## aurora run is a very intergral part of the aurora utilities, mulitple utilites like aurora pipelines, aurora debug-test
## use it complete their own respective objectives.

echo "aurora_run.sh started with [aurora_run.sh  $@]"
ARGS="$@"

export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
. gc_helpers.sh
. aurora_utils.sh
source /home/$USER/.aurora.conf
source aurora_infra_settings.conf

#Show help
if [[ $1 == "help" ]]; then
  show_run_help
  exit 1
fi
#Starting and ending steps
STEP_ST=1
STEP_ED=12

LOG_SRC_DIR=/opt/pg/log
TAG="none"
CONTINUE=0
KEEP_RUNNING=0
LOCAL_CHANGES=0

# read the options
TEMP=`getopt -o l:s:S:o:n:W:t:CKc:e:a:R:E:h --long buildid:,script:,log_dir:,src_log_dir:,runid:,WORKSPACE:,tag:,\continue,keep-running,local_commit:,existing_commit_hash:,alps-path:,cost_pipeline_code:,minor_st:,minor_end:,\help -n 'aurora.sh' -- "$@"`
eval set -- "$TEMP"
while true ; do
  case "$1" in
    #Basic Funtionality
    -l| --buildid ) BUILD_ID=$2; shift 2 ;;
    -s| --script ) TEST_SCRIPT=$2; shift 2 ;;
    -o| --log_dir) LOG_DEST_DIR=$2; shift 2 ;;
    -n| --runid ) RUNID=$2 ; shift 2 ;;
    -W| --WORKSPACE) export WORKSPACE=$2 ; shift 2 ;;
    -t| --tag) TAG=$2 ; shift 2 ;;
    -S| --src_log_dir) LOG_SRC_DIR=$2 ; shift 2 ;;
    -C| --continue ) CONTINUE=1; shift ;;
    -K| --keep-running ) KEEP_RUNNING=1; shift ;;
    #Local changes flags
    -c| --local_commit) COMMIT_ID=$2; shift 2;;
    -e|--existing_commit_hash) EXISTING_COMMIT_HASH=$2 ; shift 2 ;;
    -a| --alps-path) ALPS_PATH=$2; shift 2;;
    --cost_pipeline_code) COST_PIPELINE_CODE=$2; shift 2;;
    #Start-End steps
    -R| --minor_st ) MINOR_STEPS_ST[$MAJOR_STEPS]="$2"; shift 2 ;;
    -E| --minor_end ) MINOR_STEPS_ED[$MAJOR_STEPS]="$2"; shift 2 ;;
    -h| --help ) show_run_help;exit 0; shift ;;
    --) shift ; break ;;
    *) exit 1 ;;
  esac
done
#Check required Arguments
if [[ -z "$BUILD_ID" ]]; then
  echo "Required argument -l(--buildid)"
  show_run_help
  exit 1
fi
if [[ -z "$LOG_DEST_DIR" ]]; then
  LOG_DEST_DIR="${WORKSPACE}/logs/"
fi
mkdir -p $LOG_DEST_DIR
echo "Logs will be stored in $LOG_DEST_DIR"

if [[ $KEEP_RUNNING == "1" ]]; then
  STEP_ED=`expr $STEP_ED - 1`
fi
#Check test script file
if [[ -n $TEST_SCRIPT ]]; then
  check_file_existence $TEST_SCRIPT
else
  STEP_ED=8
fi

BUILD_ID=${emailid}-${BUILD_ID}
#Validate Inputs
check_run_inputs $BUILD_ID
if [[ -z "$COST_PIPELINE_CODE" ]]; then
  COST_PIPELINE_CODE="x"
fi
INSTANCE_NAME=$(generate_instance_name ${BUILD_ID} ${TAG} ${COST_PIPELINE_CODE} ${CONTINUE} ${RUNID})
#Check /home/$USER/.ssh/id_rsa.pub file
check_file_existence "/home/$USER/.ssh/id_rsa.pub"
step_file=$LOG_DEST_DIR/${INSTANCE_NAME}-last-successful-step

# If "continue" switch has been given then do following steps
#   a. Get the RUN-ID provided by user.
#   b. Get the last successfully completed step.
#   c. Start the run process from step next to last completed step.
if [[ $CONTINUE == "1" ]] ; then
  step_file=$LOG_DEST_DIR/${INSTANCE_NAME}-last-successful-step
  #Continue only if file exists
  if [[ ! -f $step_file ]]; then
    echo "No last successful step file ${step_file}, cannot resume. Exiting"
    exit 1
  fi
  LAST_SUCCESSFULL_STEP=( $(<${step_file}) )
  STEP_ST=$((LAST_SUCCESSFULL_STEP+1))
  #Only get the IP address if the instance has already been created.
  if [[ $LAST_SUCCESSFULL_STEP -gt 2 ]]; then
    #Get the IP address of the instances, needed incase continue is specified.
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
  fi
else
  check_instance_limit
fi

#Create file to ensure continue works if run/build is aborted before 1st step completes
touch $step_file
echo "********* RUNID=${INSTANCE_NAME##*-} *********"
if [[ $EXISTING_COMMIT_HASH != "null" ]]; then
  VALID_COMMIT_HASH="true"
fi

function run_test() {
  local step=$1

  case "$step" in
  1)
    echo "Creating the disk[${INSTANCE_NAME}-d1] for the instance in the cloud from ${BUILD_ID}"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d1" -q \
      --source-snapshot "${BUILD_ID}-ssd1" --type "$DISK_TYPE" --size="$DISK1_SIZE"
    record_step $step $step_file
    ;;

  2)
    echo "Creating the disk[${INSTANCE_NAME}-d2] for the instance in the cloud from ${BUILD_ID}"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d2" -q \
      --source-snapshot "${BUILD_ID}-ssd2" --type "$DISK_TYPE" --size="$DISK2_SIZE"
    record_step $step $step_file
    ;;

  3)
    local key_file=$(mktemp $WORKSPACE/keys-XXXXX)
    echo plumgrid:$(cat /home/${USER}/.ssh/id_rsa.pub) > ${key_file}
    echo plumgrid:$(echo ${COMMON_KEY}) >> ${key_file}
    echo "Creating the instance[$INSTANCE_NAME] in the cloud"
    tryexec exec_gcloud_cmd instances create "${INSTANCE_NAME}" -q\
      --machine-type "$MACHINE_TYPE" --network "$NETWORK" --maintenance-policy \
      "MIGRATE" --scopes "$SCOPES" \
      --disk "name=${INSTANCE_NAME}-d1" "mode=rw" "boot=yes" "auto-delete=yes" \
      --disk "name=${INSTANCE_NAME}-d2" "mode=rw" "boot=no" "auto-delete=yes" --no-address --tags "no-ip" \
      --metadata-from-file sshKeys=$key_file
    rm $key_file
    record_step $step $step_file
    ;;

  4)
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
    echo "Waiting for the machine to boot up and allow ssh access"
    tryexec wait_for_instance ${INSTANCE_IP}
    record_step $step $step_file
    ;;

  5)
    echo "Changing MTU on the instance"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo ifconfig eth0 mtu 1400"
    tryexec run_cmd_gci ${INSTANCE_IP} "DT=\$(ifconfig eth0 | grep 'inet addr' | cut -d: -f2|cut -d' ' -f 1); sudo bash -c 'echo \"'\$DT'  \`hostname\`\" >> /etc/hosts'"
    record_step $step $step_file
    ;;

  6)
    if [[ -n "$COMMIT_ID" ]]; then
      tryexec push_local_changes ${INSTANCE_IP} ${COMMIT_ID} ${ALPS_PATH}
      tryexec make_install_alps ${INSTANCE_IP} "/tmp/make_install_alps.log"
      tryexec run_poll_cmd ${INSTANCE_IP} "make_install_alps.sh" "/tmp/make_install_alps.log" "1"
      record_step $step $step_file
    fi
    ;;

  7)
    if [[ $VALID_COMMIT_HASH == "true" ]];then
      tryexec checkout_existing_commit ${INSTANCE_IP} ${EXISTING_COMMIT_HASH} /tmp/checkout_existing_commit.log
      tryexec run_poll_cmd ${INSTANCE_IP} "checkout_existing_commit.sh" "/tmp/checkout_existing_commit.log" "1"
    fi
    ;;

  8)
    echo "Restarting lxc-net service"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo ifconfig lxcbr0 down || true"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo brctl delbr lxcbr0 || true"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo pkill dnsmasq || true"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo service lxc-net restart || true"
    record_step $step $step_file
    ;;

  9)
    retryexec upload ${INSTANCE_IP} ${TEST_SCRIPT} /tmp/user_test_script.sh
    tryexec run_cmd_gci_bg ${INSTANCE_IP} "/bin/bash /tmp/user_test_script.sh" "/tmp/test.logs"
    record_step $step $step_file
    ;;

  10)
    echo "Poll the test logs (tailing \"/tmp/test.log\")"
    tryexec run_poll_cmd ${INSTANCE_IP} "/tmp/user_test_script.sh" "/tmp/test.logs" "0"
    retryexec download ${INSTANCE_IP} "/tmp/test.logs" "${LOG_DEST_DIR}/${INSTANCE_NAME}.log"
    record_step $step $step_file
    ;;

  11)
    echo "Downloading logs in ${LOG_DEST_DIR} directory"
    tryexec get_latest_logs ${INSTANCE_IP} ${INSTANCE_NAME} ${LOG_SRC_DIR} ${LOG_DEST_DIR}
    printf "\n\n********* Run has been completed successfully. Please see all logs in ${LOG_DEST_DIR} direcotry *********\n\n"
    record_step $step $step_file
    ;;

  12)
    echo "Shutting down the Instance ${INSTANCE_NAME}"
    tryexec exec_gcloud_cmd instances delete ${INSTANCE_NAME} --delete-disks all  -q
    rm $step_file
    ;;

  *)
    echo "NOP - $step"
  ;;
  esac
}

script_start_time=$(date +%s)
for STEP in `seq ${STEP_ST} ${STEP_ED}`; do
  printf "\n    === Starting STEP $STEP === \n"
  start_time=$(date +%s)
  run_test $STEP
  end_time=$(date +%s)
  print_time_taken $start_time $end_time "[$STEP]"
done
script_end_time=$(date +%s)
print_time_taken $script_start_time $script_end_time "[run]"
