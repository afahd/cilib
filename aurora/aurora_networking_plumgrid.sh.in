#!/bin/bash -e
source help.sh

# This script runs the networking plumgrid pipeline. The difference from all other pipelines
# is because that the underlying ubuntu snapshot is that of 14.04 and not the usual 12.04. This pipeline
# has no further dependencies on any of the other repos, hence the different usage.

export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
echo "aurora_networking_plumgrid.sh started with [aurora_networking_plumgrid.sh $@]"
ARGS=$@
. gc_helpers.sh
. aurora_utils.sh
source aurora_infra_settings.conf
source /home/$USER/.aurora.conf

BRANCH=""
REFSPEC="none"
TAG="none"
GIT_TAG="none"
PROJECT="networking-plumgrid"

STEP_ST=1

TOTAL_BUILD_STEPS=8
STEP_ED=$TOTAL_BUILD_STEPS

GIVEN_ST=0
GIVEN_ED=0

CONTINUE=0

# read the options
TEMP=`getopt -o Kr:P:t:Cb:W:R:E:h --long keep-running,refspec:,pipeline:,WORKSPACE:,tag:,\continue,branch:,help,step_st:,step_end: -n 'aurora_networking_plumgrid.sh' -- "$@"`

eval set -- "$TEMP"
while true ; do
  case "$1" in
     -K| --keep-running ) KEEP_RUNNING=1; shift ;;
     -P| --pipeline) PIPELINE=$2 ; shift 2 ;;
     -r| --refspec) REFSPEC=$2; shift 2 ;;
     -t| --tag) TAG=$2 ; shift 2 ;;
     -C| --continue) CONTINUE=1 ; shift ;;
     -b| --branch) BRANCH=$2; shift 2 ;;
     -W| --WORKSPACE) export WORKSPACE=$2 ; shift 2 ;;
     -R| --step_st ) STEP_ST="$2"; GIVEN_ST=1; shift 2 ;;
     -E| --step_end ) STEP_ED="$2"; GIVEN_ED=1; shift 2 ;;
     -h| --help ) show_run_tests_help; exit 0; shift;;
     --) shift ; break ;;
     *) exit 1 ;;
  esac
done

mkdir -p ${WORKSPACE}/logs

if [[ $PIPELINE != "networking-plumgrid" ]]; then
  echo "Invalid Pipeline Specified"
  exit 1
fi

MOD_BRANCH=${BRANCH////_}
#creating branch code from branch name provided by user.
branch_code="${BR_CODE[$BRANCH]}"

if [[ -z "$branch_code" ]]; then
  branch_code="x"
fi

branch_code="b-${branch_code}"

INSTANCE_NAME=$(generate_build_instance_name ${emailid} ${TAG} ${branch_code} ${REFSPEC} ${GIT_TAG} ${MOD_BRANCH})

step_file=$WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step
#Validate Inputs
check_build_inputs $INSTANCE_NAME $PROJECT $REFSPEC $BRANCH $GIT_TAG
#Check /home/$USER/.ssh/id_rsa.pub file
check_file_existence "/home/$USER/.ssh/id_rsa.pub"


# If "continue" switch has been given then do following steps
#   a. Get the last successfully completed step.
#   b. Start the build process from step next to last completed step.
if [[ $GIVEN_ST == "0" && $CONTINUE == "1" ]] ; then
  #Continue only if file exists
  if [[ ! -f $step_file ]]; then
    echo "No last successful step, cannot resume. Exiting"
    exit 1
  fi
  # Get the last successfull step from $WORKSPACE/logs/${INSTANCE_NAME}-last-successful-step
  LAST_SUCCESSFULL_STEP=( $(<${step_file}) )
  STEP_ST=$((LAST_SUCCESSFULL_STEP+1))
fi

#Only get the IP address if the instance has already been created.
if [[ ${STEP_ST} -gt "3" ]]; then
  INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
else
  check_instance_limit
fi

# If "step-end" switch has NOT been given then do the following steps
#   a. Decrement step-end by 1 if KEEP_RUNNING switch has been used
if [[ $GIVEN_ED == "0" && $KEEP_RUNNING == "1" ]]; then
  #keep_running equalling 1 means -k was specified, end step should be 1 less.
  STEP_ED=`expr $STEP_ED - 1`
fi

#Create file to ensure continue works if run/build is aborted before 1st step completes
touch $step_file

function build_image() {
  local step=$1
  case "$step" in

  1)
    echo "Creating the disk[${INSTANCE_NAME}-d1] for the instance in the cloud"
    tryexec exec_gcloud_cmd disks create "${INSTANCE_NAME}-d1" \
      --image "${BASE_LINUX1404}" --type "$DISK_TYPE" --size="$DISK1_SIZE" -q
    record_step $step $step_file
    ;;

  2)
    local key_file=$(mktemp $WORKSPACE/keys-XXXXX)
    echo plumgrid:$(cat /home/${USER}/.ssh/id_rsa.pub) > ${key_file}
    echo plumgrid:$(echo ${COMMON_KEY}) >> ${key_file}
    echo "Creating the instance[$INSTANCE_NAME] in the cloud"
    tryexec exec_gcloud_cmd instances create "${INSTANCE_NAME}" \
      --machine-type "$MACHINE_TYPE" --network "$NETWORK" --maintenance-policy \
      "MIGRATE" --scopes "$SCOPES" -q \
      --disk "name=${INSTANCE_NAME}-d1" "mode=rw" "boot=yes" "auto-delete=yes" --no-address --tags "no-ip" \
      --metadata-from-file sshKeys=$key_file
    rm $key_file
    ;;

  3)
    INSTANCE_IP=$(get_instance_ip ${INSTANCE_NAME})
    echo "Waiting for the machine to boot up and allow ssh access"
    tryexec wait_for_instance ${INSTANCE_IP}
    ;;

  4)
    echo "Changing MTU on the instance"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo ifconfig eth0 mtu 1400"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo apt-get install git -y"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo apt-get update"
    tryexec run_cmd_gci ${INSTANCE_IP} "sudo apt-get install python-pip -y"
    tryexec run_cmd_gci ${INSTANCE_IP} "ssh-keyscan -t rsa -p ${GERRIT_PORT} -H ${GERRIT_IP} >> ~/.ssh/known_hosts"
    tryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "git clone ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/networking-plumgrid.git ~/work/networking-plumgrid"
    ;;

  5)
    if [[ "$REFSPEC" != "none" ]]; then
      tryexec run_cmd_gci_sshforwarding ${INSTANCE_IP} "cd ~/work/networking-plumgrid; git fetch ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/networking-plumgrid ${REFSPEC}; git checkout FETCH_HEAD"
    else
      tryexec run_cmd_gci ${INSTANCE_IP} "cd ~/work/networking-plumgrid/; git checkout $BRANCH"
    fi
    ;;

  6)
    echo "Entering Directory: ~/work/networking-plumgrid/jenkins and running pre-init.sh"
    tryexec run_cmd_gci ${INSTANCE_IP} "cd ~/work/networking-plumgrid/jenkins; ./preinit.sh"
    ;;

  7)
    echo "Entering Directory: ~/work/networking-plumgrid/jenkins and running init.sh"
    tryexec run_cmd_gci ${INSTANCE_IP} "cd ~/work/networking-plumgrid/jenkins; sudo ./init.sh"
    ;;

  8)
    echo "Shutting down the Instance ${INSTANCE_NAME}"
    tryexec exec_gcloud_cmd instances delete ${INSTANCE_NAME} --delete-disks all  -q
    ;;

  *)
    echo "NOP - $step"
  ;;
  esac
}

script_start_time=$(date +%s)
for STEP in `seq ${STEP_ST} ${STEP_ED}`; do
  printf "\n    === Starting STEP $STEP === \n"
  start_time=$(date +%s)
  build_image $STEP
  end_time=$(date +%s)
  record_step $STEP $step_file
  print_time_taken $start_time $end_time "[$STEP]"
  if [[ $STEP == $TOTAL_BUILD_STEPS ]]; then
    rm $step_file
  fi
done

script_end_time=$(date +%s)
print_time_taken $script_start_time $script_end_time "[BUILD]"

