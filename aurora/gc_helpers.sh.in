#!/bin/bash -e
export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
source aurora_infra_settings.conf
source help.sh

function init_id() {
  conf_file="/home/$USER/.aurora.conf"
  echo "Please enter your gerrit id: "
  read gerritid
  echo "gerritid=${gerritid}" > ${conf_file}
  gcloud config set project $PROJECT
  gcloud config set compute/zone $ZONE
  gcloud config set compute/region $REGION

  ## Set the SSH keys for google compute cloud engine
  echo "Generate the ssh-keys for Google compute cloud engine."
  ssh-keygen -N "" -t rsa -f $HOME/.ssh/google_compute_engine
}

# *****************************************************************************
# Function: run_cmd_gci
# Purpose : Run command on Google Cloud instance.
# Usage   : run_cmd_gci <cloud_instance_name>
# *****************************************************************************
function run_cmd_gci() {
  local INSTANCE_NAME=$1
  local CMD=$2
  local SSH_FLAGS=${3:-t}
  #echo "gcloud compute -q ssh ${USER}@${INSTANCE_NAME} --ssh-flag=\"-${SSH_FLAGS}\" --ssh-flag=\"-o ServerAliveInterval=5\" --command \"$CMD\""
  gcloud compute -q ssh ${USER}@${INSTANCE_NAME} --ssh-flag="-${SSH_FLAGS}" --ssh-flag="-o ServerAliveInterval=5" --command "$CMD"
}

# *****************************************************************************
# Function: run_cmd_gci_sshforwarding
# Purpose : Run command on Google Cloud instance with ssh forwarding.
# Usage   : run_cmd_gci <cloud_instance_name>
# *****************************************************************************
function run_cmd_gci_sshforwarding() {
  local INSTANCE_NAME=$1
  local CMD=$2

  if [ -z "$SSH_AUTH_SOCK" ] ; then
    echo "running ssh-add"
    eval `ssh-agent -s`
    ssh-add
  fi

  run_cmd_gci ${INSTANCE_NAME} "${CMD}" tA
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker() {
  local INSTANCE_NAME=$1
  local DOCKER_CMD=$2

  echo run_cmd_gci ${INSTANCE_NAME} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
  run_cmd_gci ${INSTANCE_NAME} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
}


# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_bg() {
  local INSTANCE_NAME=$1
  local DOCKER_CMD=$2
  local LOG_FILE=$3

  run_cmd_gci ${INSTANCE_NAME} "ssh -t -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` \" nohup bash -c '${DOCKER_CMD} > ${LOG_FILE} 2>&1 &' \""
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_sshforwarding() {
  local INSTANCE_NAME=$1
  local DOCKER_CMD=$2

  run_cmd_gci_sshforwarding ${INSTANCE_NAME} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_sshforwarding_bg() {
  local INSTANCE_NAME=$1
  local DOCKER_CMD=$2
  local LOG_FILE=$3

  run_cmd_gci_sshforwarding ${INSTANCE_NAME} "ssh -t -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` \" nohup bash -c '${DOCKER_CMD} > ${LOG_FILE} 2>&1 &' \""
}

# *****************************************************************************
# Function: wait_for_instance
# Purpose : Wait Cloud instance to come up.
# Usage   : wait_for_instance <cloud_instance_name>
# *****************************************************************************
function wait_for_instance() {
  local INSTANCE_NAME=$1
  local RESULT=1
  for i in `seq 1 60`;
    do
      echo "Trying to ssh to ${INSTANCE_NAME} Iteration [$i]"
      gcloud compute -q ssh ${USER}@${INSTANCE_NAME} --ssh-flag='-t' --ssh-flag="-o ServerAliveInterval=5" --command "ls" >> /tmp/build_image.2.log 2>&1  && RESULT=0 && break
      sleep 1
    done
  return $RESULT
}

# *****************************************************************************
# Purpose : Check whether ssh server is up and running.
# Usage   : wait_for_instance <cloud_instance_name>
# *****************************************************************************
function check_ssh_server_status() {
  local INSTANCE_NAME=$1
  local RESULT=1
  echo "check if ssh server is up and running"
  if [ -z "$SSH_AUTH_SOCK" ] ; then
    echo "running ssh-add"
    eval `ssh-agent -s`
    ssh-add
  fi

  for i in `seq 1 60`;
    do
      echo "Trying to ssh to ${DOCK_NAME} Iteration [$i]"
      gcloud compute -q ssh  ${USER}@${INSTANCE_NAME} --ssh-flag='-tA' --ssh-flag="-o ServerAliveInterval=5" --command "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ls" >> /tmp/build_image.3.log  2>&1 && RESULT=0 && break
      sleep 1
    done
  return $RESULT
}

# *****************************************************************************
# Purpose : Run docker container inside given instance
# *****************************************************************************
function run_dock_container() {
  local INSTANCE_NAME=$1
  local DOCK_NAME=$2
  local DOCK_ID_FILE=$3
  local DOCK_IP_FILE=$4

  run_cmd_gci ${INSTANCE_NAME} "DID=\$(sudo docker run  --cap-add=all  --cap-add=SYS_ADMIN \
    --lxc-conf='lxc.aa_profile=unconfined' --privileged -d ${DOCK_NAME} /home/plumgrid/startup.sh) && \
    echo \$DID > ${DOCK_ID_FILE} && \
    sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}' \$DID > ${DOCK_IP_FILE}"
}

# *****************************************************************************
# Purpose : Check whether docker is running fine.
# Usage   : verify_docker_running <cloud_instance_name> <docker_name>
# *****************************************************************************
function verify_docker_running() {
  local INSTANCE_NAME=$1
  local DOCKER_NAME=$2

  for i in `seq 1 5`; do
    echo "Try$i: Checking whether ${DOCKER_NAME} is running ....?"
    run_cmd_gci ${INSTANCE_NAME} "sudo docker ps | grep ${DOCK_NAME} &> /dev/null"
    if [[ $? == 0 ]]; then
      echo "Docker container is running"
      return 0
    fi
    sleep 3
  done
  echo "Docker $DOCKER_NAME is not running.."
  return 1
}

# *****************************************************************************
# Purpose : Configure docker according to PG requirements.
# *****************************************************************************
function configure_docker() {
  local INSTANCE_NAME=$1

  run_cmd_gci ${INSTANCE_NAME} "echo 'DOCKER_OPTS=\"--mtu 1400 --insecure-registry pg-docker-repo:5000\"' | sudo tee /etc/default/docker && sudo service docker restart"
}

# *****************************************************************************
# Purpose : Check whether docker is successfully committed.
# Usage   : verify_docker_commited <cloud_instance_name> <docker_name>
# *****************************************************************************
function verify_docker_commited() {
  local INSTANCE_NAME=$1
  local DOCK_NAME=$2

  for i in `seq 1 5`; do
    echo "Try$i: Checking whether ${DOCK_NAME} is committed ....?"
    run_cmd_gci ${INSTANCE_NAME} "sudo docker images | grep ${DOCK_NAME} &> /dev/null"
    if [[ $? == 0 ]]; then
      echo "Docker container is committed"
      return 0
    fi
    sleep 3
  done
  echo "Docker $DOCKER_NAME is not committed.."
  return 1
}

function setup_forwarding() {
  local INSTANCE_NAME=$1

  run_cmd_gci ${INSTANCE_NAME} "echo 'host *' > ~/.ssh/config; echo '    ForwardAgent yes'>>~/.ssh/config"
}

# *****************************************************************************
# Purpose : ADD key to authroized keys of docker container running on instance
# Usage   :
# KEY_PATH:       KEY path on cloud insctance machine.
# DOCKER_ID_FILE: File which holds the docker id on instance
# TODO: Not tested much
# *****************************************************************************
function add_to_dock_authorized_keys() {
  local INSTANCE_NAME=$1
  local KEY_PATH=$2
  local DOCK_ID_FILE=$3

  run_cmd_gci ${INSTANCE_NAME} "sudo su -c \"cat ${KEY_PATH} >> \
    /var/lib/docker/btrfs/subvolumes/\`cat ${DOCK_ID_FILE}\`/home/plumgrid/.ssh/authorized_keys\""
}

# *****************************************************************************
# Function: get_lastest_snapshot_id
# Purpose : Lists the snapshot with the highest time stamp.
# Usage   : get_lastest_snapshot_id
# *****************************************************************************
function get_latest_snapshot_id() {
  #The snapshots are sorted in desencding order by name. Sorting by name also works for numbers.
  local latest_ss=$(gcloud compute snapshots list --sort-by=~NAME --regexp=plumgrid-builder-v1-d1-.* --limit=1 | grep plumgrid-builder-v1-d1- | cut  -d ' ' -f 1)
  local ssid="${latest_ss##*-}"

  echo $ssid
}

# *****************************************************************************
# Function: modify_git_config
# Purpose : Modify the git config inside docker acc to current user in order to
#           checkout/clone commits/repos
# Usage   : modify_git_config <repo_name> <gerrit_id> <write_to_script>
# *****************************************************************************
function modify_git_config() {
  local repo_name=$1
  local gerrit_id=$2
  local write_to_script=$3
  if [[ $# -ne 3 ]]; then
    log "BUG: $# args received by ${FUNCNAME}"
    exit 100
  fi

  echo "cd /home/plumgrid/work/${repo_name}/.git && sed -i \"/url = ssh:/ c\        url = ssh://${gerrit_id}@192.168.10.77:29418/${repo_name}.git\" config" >> ${write_to_script}
}

# *****************************************************************************
# Function: get_latest_logs
# Purpose : Gets the latest test logs from docker in a .tar file.
#           User might run several tests in on the instance, the funtion gets
#           only the latest results.
# Usage   : get_latest_logs
# *****************************************************************************
function get_latest_logs() {
  local INSTANCE_NAME=$1
  local local_file=$(mktemp /tmp/collect_log-XXXXX)
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "ls -rtd /opt/pg/log/*/ | tail -1 > /tmp/latest_log_dir" >> ${local_file}
  echo "LOG_FNAME=\$(cat /tmp/latest_log_dir |cut -d '/' -f 5)" >> ${local_file}
  echo "tar -zcf /tmp/\${LOG_FNAME}.tar \`cat /tmp/latest_log_dir\`" >> ${local_file}
  echo "echo \${LOG_FNAME} > /tmp/latest_log_filename"  >> ${local_file}
  upload_to_docker ${INSTANCE_NAME} ${local_file} ${local_file}
  rm ${local_file}
  run_cmd_docker ${INSTANCE_NAME} "bash ${local_file}"
  download_from_docker ${INSTANCE_NAME} /tmp/latest_log_filename /tmp/latest_log_filename
  local log_tar=$(cat /tmp/latest_log_filename)
  download_from_docker ${INSTANCE_NAME} /tmp/${log_tar}.tar /tmp/${INSTANCE_NAME}-logs.tar
  echo "Logs have been placed at /tmp/${INSTANCE_NAME}-logs.tar"
}

# ******************************************************************************
# Function: run_poll_cmd
# Purpose : Poll the given gcloud command running in the background on the basis
#           of pid to see if the command is completed. On completion, create an
#           empty file in /tmp
# Usage   : run_poll_cmd <cloud_instance_name> <process_to_poll_for> <ssh_flag>
# ******************************************************************************
function run_poll_cmd() {
  local INSTANCE_NAME=$1
  local process=$2
  local LOG_FILE=$3
  local SSH_FLAGS=${4:-t}
  local local_file=$(mktemp /tmp/poll_gcloud_cmd-XXXXX)

  # Create a script that will constantly poll for the running process and exit only when it has ended
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "echo \"Waiting for command to finish ... (Log will be tailed below) \"" >> ${local_file}
  echo "tail -f $LOG_FILE &" >> ${local_file}
  echo "while [[ ! -z \`pgrep -f ${process}\` ]]; do sleep 5; done;" >> ${local_file}
  echo "echo \"$process completely successfully, exiting\"" >> ${local_file}
  upload_to_docker ${INSTANCE_NAME} ${local_file} ${local_file}
  rm ${local_file}
  run_cmd_docker ${INSTANCE_NAME} "bash ${local_file}"
}

# *****************************************************************************
# Function: create_snapshot
# Purpose : Creates a snapshot from disk.
#           After issuing the request for snapshot creation, it will start
#           polling that whether creation is successfull or not? If unsuccessful
#           for 450 seconds, then another request will be issued for creation.
#           Function also handles the situation where "false alarm" of error
#           is raised by system.
# Usage   : create_snapshot <diskname> <snapshotname>
# *****************************************************************************
function create_snapshot {
  local DISK_NAME=$1
  local SNAPSHOT_NAME=$2
  local success=0
  local retval=0
  # Check if snapshot already exists
  gcloud compute snapshots list ${SNAPSHOT_NAME} | grep "${SNAPSHOT_NAME}" || retval=$?
  if [ $retval -eq 0 ]; then
    echo "Snapshot already exists"
    exit 1
  fi

  for i in `seq 1 5`;
  do
    echo "Try-$i: Request for snapshot creation"
    # Issue snapshot creation command.
    retval=0
    gcloud compute disks snapshot ${DISK_NAME} --snapshot-names ${SNAPSHOT_NAME} || retval=$?
    if [ $retval -eq 0 ]; then
      return 0;
    fi
    for j in `seq 1 15`;
    do
      echo "$j: checking snapshot ${SNAPSHOT_NAME} creation...."
      # Make sure snapshot is in READY state (not in UPLOADING or anyother state).
      retval=0
      gcloud compute snapshots list ${SNAPSHOT_NAME} | grep "${SNAPSHOT_NAME}" | grep "READY"|| retval=$?
      if [ $retval -eq 0 ]; then
        success=1
        break
      fi
      sleep 1
    done

    # Check whether Snapshot creation remains successfull? If so, then exit from loop.
    # Otherwise, issue a fresh request for it.
    if [ ${success} -eq 1 ]; then
      echo "SNAPSHOT:${SNAPSHOT_NAME} creation successful: exiting outer loop"
      return 0
    fi
    sleep 30
  done
}
# *****************************************************************************
# Function: cleanup
# Purpose : Cleans up the instances and disks in case of failure.
# Usage   : cleanup
# Prereq  :
# *****************************************************************************
function cleanup() {
  gcloud compute instances delete $INSTANCE_NAME -q --delete-disks all
}

# *****************************************************************************
# Function: tryexec
# Purpose : Try to execute a command. If the command returns success, this
#           function returns 0. Otherwise, the script is aborted with the status
#           code of the failed command.
# Usage   : tryexec <command>
# Prereq  :
# *****************************************************************************
function tryexec() {
  local retval=0;
  "$@" || retval=$?
  [[ $retval -eq 0 ]] && return 0

  echo 'A command has failed:'
  echo "  $@"
  echo "Value returned: ${retval}"
  echo "$(basename $0) Failed, do you want to cleanup the instances?"
  read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with cleanup..."
      cleanup
      exit $retval
    else
      exit $retval
    fi
}
# *****************************************************************************
# Function: check_build_inputs
# Purpose : Checks if the inputs provided to aurora build are correct.
# Usage   : check_build_inputs <PROJECT> <REFSPEC> <BRANCH>
# Prereq  :
# *****************************************************************************
function check_build_inputs() {
  local PROJECT=$1
  local REFSPEC=$2
  local BRANCH=$3
  local RESULT=1
  #Check project name
  local project_list=$(ssh -p ${GERRIT_PORT} ${gerritid}@${GERRIT_IP} gerrit ls-projects)
  for project_name in ${project_list}; do
    if [[ $project_name =~ $PROJECT ]]; then
      RESULT=0
      break
    fi
  done

  if [[ $RESULT -eq 1 ]]; then
    echo "Invalid project name: ${PROJECT}"
    show_build_help
    exit 1
  fi

  #Check refspec format
  if [[ ! $REFSPEC =~ ^refs/changes/[0-9]+/[0-9]+/[0-9]+$ ]]; then
    echo "Invalid refspec format"
    show_build_help
    exit 1
  fi
  #Check if refespec exists for the project
  git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/${PROJECT} "${REFSPEC}" | grep "${REFSPEC}" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Refspec: $REFSPEC does not exist for the project: ${PROJECT}"
    show_build_help
    exit 1
  fi
  #Check if branch exists
  git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/${PROJECT} "${BRANCH}" | grep "${BRANCH}" || RESULT=$?
    if [[ $RESULT -ne 0 ]];then
    echo "Branch: $BRANCH does not exist for the project: ${PROJECT}"
    show_build_help
    exit 1
  fi
}
# *****************************************************************************
# Function: check_run_inputs
# Purpose : Checks if the inputs provided to aurora run are correct.
# Usage   : check_run_inputs <BUILDID> <TESTNAME>
# Prereq  :
# *****************************************************************************
function check_run_inputs() {
  local BUILDID=$1
  local TESTNAME=$2
  local RESULT

  gcloud compute snapshots list ${BUILDID}-ssd1 | grep "${BUILDID}-ssd1" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Snapshot ${BUILDID}-ssd1 does not exist, wrong Build-ID"
    show_run_help
    exit 1
  fi

  gcloud compute snapshots list ${BUILDID}-ssd2 | grep "${BUILDID}-ssd2" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Snapshot ${BUILDID}-ssd2 does not exist, wrong Build-ID"
    show_run_help
    exit 1
  fi

  if [ ! -f "$TESTNAME" ]; then
    echo "Test file \"$TESTNAME\" not found!"
    show_run_help
    exit 1
  fi
}

function record_step() {
  echo $1 > /tmp/${INSTANCE_NAME}-last-successful-step
}
