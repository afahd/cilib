#!/bin/bash -e
export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
source aurora_infra_settings.conf
source help.sh

if [[ -z "${WORKSPACE}" ]]; then
  if [[ ! -d /tmp/logs ]]; then
    mkdir /tmp/logs
  fi
  WORKSPACE=/tmp
fi
if [[ ! -d "${WORKSPACE}/logs" ]] ; then
  mkdir -p ${WORKSPACE}/logs
fi

function init_id() {
  conf_file="/home/$USER/.aurora.conf"
  echo "Please enter your gerrit id: "
  read gerritid
  echo "gerritid=${gerritid}" > ${conf_file}
  echo "gerritid_lower=${gerritid,,}" >> ${conf_file}
  echo "Please enter your plumgrid email: "
  read emailid
  echo "emailid=${emailid }" >> ${conf_file}
  gcloud config set project $GCLOUD_PROJECT
  gcloud config set compute/zone $ZONE
  gcloud config set compute/region $REGION
}

# *****************************************************************************
# Function: run_cmd_gci
# Purpose : Run command on Google Cloud instance.
# Usage   : run_cmd_gci <cloud_instance_ip>
# *****************************************************************************
function run_cmd_gci() {
  local INSTANCE_IP=$1
  local CMD=$2
  local SSH_FLAGS=${3:-t}

  ssh -${SSH_FLAGS} -o StrictHostKeyChecking=no -o ServerAliveInterval=5 ${USER}@${INSTANCE_IP} "$CMD"
}

# *****************************************************************************
# Function: check_and_start_ssh_agent
# Purpose : check if ssh agent is running, if not start it and add keys to it
# Usage   : check_and_start_ssh_agent
# *****************************************************************************
function check_and_start_ssh_agent() {
  PFOUND="0"
  AGENT_PID=$(pgrep ssh-agent) && PFOUND="1"
  if [[ -z "$SSH_AUTH_SOCK" ]] ; then
     PFOUND="0"
  fi
  if [[ "$PFOUND" == "0" ]] ; then
    echo "running ssh-add"
    eval `ssh-agent -s`
  fi
  # always refresh the keys in case they where timedout
  PFOUND="0"
  if [[ -f ${HOME}/.ssh/jenkins-slave-gerrit ]]; then
    ssh-add ${HOME}/.ssh/jenkins-slave-gerrit && PFOUND="1"
  else
    ssh-add && PFOUND="1"
  fi
  if [[ "$PFOUND" == "0" ]] ; then
      # if ssh add failed
      # Re star the ssh agent and re-add the keys
      pkill ssh-agent
      eval `ssh-agent -s`
      if [[ -f ${HOME}/.ssh/jenkins-slave-gerrit ]]; then
        ssh-add ${HOME}/.ssh/jenkins-slave-gerrit
      else
        ssh-add
      fi
  fi
}

# *****************************************************************************
# Function: run_cmd_gci_sshforwarding
# Purpose : Run command on Google Cloud instance with ssh forwarding.
# Usage   : run_cmd_gci_sshforwarding <cloud_instance_ip>
# *****************************************************************************
function run_cmd_gci_sshforwarding() {
  local INSTANCE_IP=$1
  local CMD=$2
  check_and_start_ssh_agent
  run_cmd_gci ${INSTANCE_IP} "${CMD}" tA
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker() {
  local INSTANCE_IP=$1
  local DOCKER_CMD=$2

  echo run_cmd_gci ${INSTANCE_IP} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
  run_cmd_gci ${INSTANCE_IP} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
}


# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_bg() {
  local INSTANCE_IP=$1
  local DOCKER_CMD=$2
  local LOG_FILE=$3

  run_cmd_gci ${INSTANCE_IP} "ssh -t -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` \" nohup bash -c '${DOCKER_CMD} > ${LOG_FILE} 2>&1 &' \""
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_sshforwarding() {
  local INSTANCE_IP=$1
  local DOCKER_CMD=$2

  run_cmd_gci_sshforwarding ${INSTANCE_IP} "ssh -tA -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_sshforwarding_bg() {
  local INSTANCE_IP=$1
  local DOCKER_CMD=$2
  local LOG_FILE=$3

  run_cmd_gci_sshforwarding ${INSTANCE_IP} "ssh -t -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` \" nohup bash -c '${DOCKER_CMD} > ${LOG_FILE} 2>&1 &' \""
}

# *****************************************************************************
# Function: wait_for_instance
# Purpose : Wait Cloud instance to come up.
# Usage   : wait_for_instance <cloud_instance_ip>
# *****************************************************************************
function wait_for_instance() {
  local INSTANCE_IP=$1
  local RESULT=1
  for i in `seq 1 60`;
    do
      echo "Trying to ssh to ${INSTANCE_NAME} Iteration [$i]"
      run_cmd_gci ${INSTANCE_IP} "ls" >> ${WORKSPACE}/logs/build_image.2.log 2>&1  && RESULT=0 && break
      sleep 1
    done
  return $RESULT
}
# *****************************************************************************
# Purpose : Check whether ssh server is up and running.
# Usage   : wait_for_instance <cloud_instance_ip>
# *****************************************************************************
function check_ssh_server_status() {
  local INSTANCE_IP=$1
  local RESULT=1
  echo "check if ssh server is up and running"
  #check_and_start_ssh_agent

  for i in `seq 1 60`;
    do
      echo "Trying to ssh to ${DOCK_NAME} Iteration [$i]"
      run_cmd_gci ${INSTANCE_IP} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ls" "tA" >> ${WORKSPACE}/logs/build_image.3.log  2>&1 && RESULT=0 && break
      sleep 1
    done
  return $RESULT
}

# *****************************************************************************
# Purpose : Run docker container inside given instance
# *****************************************************************************
function run_dock_container() {
  local INSTANCE_IP=$1
  local DOCK_NAME=$2
  local DOCK_ID_FILE=$3
  local DOCK_IP_FILE=$4

  local local_file=$(mktemp /tmp/fix_docker_startup-XXXXX)
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "sudo ifconfig eth0 mtu 1400" >> ${local_file}
  echo "sudo docker inspect --format '{{json .Id}}' ${DOCK_NAME} | tr -d '\\\"' > /tmp/docker_image_id_t" >> ${local_file}
  echo 'sudo sed -i "s/sudo rsyslogd$/sudo rsyslogd\&/" /var/lib/docker/btrfs/subvolumes/`cat /tmp/docker_image_id_t`/home/plumgrid/startup.sh' >> ${local_file}
  echo 'sudo sed -i "s/\/usr\/sbin\/sshd -D$/while :; do \/usr\/sbin\/sshd -D;sleep 1; done/" /var/lib/docker/btrfs/subvolumes/`cat /tmp/docker_image_id_t`/home/plumgrid/startup.sh' >> ${local_file}

  #retval=0
  #while :; do
  #  /usr/bin/pgrep apache2 > /dev/null || retval=$?
  #  if [[ $retval -ne 0 ]]
  #  then
  #    echo "Going to restart apache"
  #    sudo /etc/init.d/apache2 restart > /dev/null
  #    retval=0
  #  fi
  #  sleep 5;
  #done &
  echo 'sudo sed -i "s/sudo \/etc\/init.d\/apache2 start/retval=0 \n \
    while :; do \n \
    \/usr\/bin\/pgrep apache2 \> \/dev\/null \|\| retval=\$? \n \
    if [[ \$retval -ne 0 ]] \n \
    then \n \
      echo \"Going to restart apache\" \n \
      sudo \/etc\/init.d\/apache2 restart \> \/dev\/null \n \
      retval=0 \n \
    fi \n \
    sleep 5; \n \
  done \&/" /var/lib/docker/btrfs/subvolumes/`cat /tmp/docker_image_id_t`/home/plumgrid/startup.sh' >> ${local_file}
  echo 'sudo /etc/init.d/apparmor stop' >> ${local_file}
  echo 'sudo /etc/init.d/apparmor teardown' >> ${local_file}
  echo 'echo 1 | sudo tee /proc/sys/net/ipv6/conf/all/disable_ipv6' >> ${local_file}
  echo 'rm /tmp/docker_image_id_t' >> ${local_file}
  echo "if sudo lsmod | grep '^bonding' ; then" >> ${local_file}
  echo "  log 'Removing bonding module'" >> ${local_file}
  echo "  sudo rmmod bonding" >> ${local_file}
  echo "fi" >> ${local_file}
  echo "sudo modprobe bonding mode=2" >> ${local_file}
  scp -o StrictHostKeyChecking=no ${local_file} ${USER}@${INSTANCE_IP}:${local_file}
  rm ${local_file}
  run_cmd_gci ${INSTANCE_IP} "bash ${local_file}"
  run_cmd_gci ${INSTANCE_IP} "DID=\$(sudo docker run  --cap-add=all  --cap-add=SYS_ADMIN \
    --lxc-conf='lxc.aa_profile=unconfined' --privileged -d ${DOCK_NAME} /home/plumgrid/startup.sh) && \
    echo \$DID > ${DOCK_ID_FILE} && \
    sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}' \$DID > ${DOCK_IP_FILE}"
  run_cmd_gci ${INSTANCE_IP} "sudo docker inspect -f '{{.State.Pid}}' \`cat ${DOCK_ID_FILE}\` > ${DOCK_ID_FILE}.pid"
  run_cmd_gci ${INSTANCE_IP} "sudo ip link set bond0 netns \`cat ${DOCK_ID_FILE}.pid\`"
}

# *****************************************************************************
# Purpose : Check whether docker is running fine.
# Usage   : verify_docker_running <cloud_instance_ip> <docker_name>
# *****************************************************************************
function verify_docker_running() {
  local INSTANCE_IP=$1
  local DOCKER_NAME=$2

  for i in `seq 1 5`; do
    echo "Try$i: Checking whether ${DOCKER_NAME} is running ....?"
    run_cmd_gci ${INSTANCE_IP} "sudo docker ps | grep ${DOCK_NAME} &> /dev/null"
    if [[ $? == 0 ]]; then
      echo "Docker container is running"
      return 0
    fi
    sleep 3
  done
  echo "Docker $DOCKER_NAME is not running.."
  return 1
}

# *****************************************************************************
# Purpose : Configure docker according to PG requirements.
# *****************************************************************************
function configure_docker() {
  local INSTANCE_IP=$1

  run_cmd_gci ${INSTANCE_IP} "echo 'DOCKER_OPTS=\"--mtu 1400 --insecure-registry pg-docker-repo:5000\"' | sudo tee /etc/default/docker && sudo service docker restart"
}

# *****************************************************************************
# Purpose : Check whether docker is successfully committed.
# Usage   : verify_docker_commited <cloud_instance_ip> <docker_name>
# *****************************************************************************
function verify_docker_commited() {
  local INSTANCE_IP=$1
  local DOCK_NAME=$2

  for i in `seq 1 5`; do
    echo "Try$i: Checking whether ${DOCK_NAME} is committed ....?"
    run_cmd_gci ${INSTANCE_IP} "sudo docker images | grep ${DOCK_NAME} &> /dev/null"
    if [[ $? == 0 ]]; then
      echo "Docker container is committed"
      return 0
    fi
    sleep 3
  done
  echo "Docker $DOCKER_NAME is not committed.."
  return 1
}

function setup_forwarding() {
  local INSTANCE_IP=$1

  run_cmd_gci ${INSTANCE_IP} "echo 'host *' > ~/.ssh/config; echo '    ForwardAgent yes'>>~/.ssh/config"
}

# *****************************************************************************
# Purpose : ADD key to authroized keys of docker container running on instance
# Usage   :
# KEY_PATH:       KEY path on cloud insctance machine.
# DOCKER_ID_FILE: File which holds the docker id on instance
# TODO: Not tested much
# *****************************************************************************
function add_to_dock_authorized_keys() {
  local INSTANCE_IP=$1
  local KEY_PATH=$2
  local DOCK_ID_FILE=$3

  run_cmd_gci ${INSTANCE_IP} "sudo su -c \"cat ${KEY_PATH} >> \
    /var/lib/docker/btrfs/subvolumes/\`cat ${DOCK_ID_FILE}\`/home/plumgrid/.ssh/authorized_keys\""
}

# *****************************************************************************
# Function: get_lastest_snapshot_id
# Purpose : Lists the snapshot with the highest time stamp.
# Usage   : get_lastest_snapshot_id
# *****************************************************************************
function get_latest_snapshot_id() {
  #The snapshots are sorted in desencding order by name. Sorting by name also works for numbers.
  local latest_ss=$(gcloud compute snapshots list --sort-by=~NAME --regexp=plumgrid-builder-v1-d1-.* --limit=1 | grep plumgrid-builder-v1-d1- | cut  -d ' ' -f 1)
  local ssid="${latest_ss##*-}"

  echo $ssid
}
# *****************************************************************************
# Function: get_instance_ip
# Purpose : Gets the internal IP address of the instance.
# Usage   : get_instance_ip <instance name>
# *****************************************************************************
function get_instance_ip() {
  local INSTANCE_NAME=$1
  local internal_ip=$(gcloud compute instances list ${INSTANCE_NAME} --zones=${ZONE} | grep ${INSTANCE_NAME} | cut -d ' ' -f 4)

  echo $internal_ip
}

# *****************************************************************************
# Function: modify_git_config
# Purpose : Modify the git config inside docker acc to current user in order to
#           checkout/clone commits/repos
# Usage   : modify_git_config <repo_name> <gerrit_id> <write_to_script>
# *****************************************************************************
function modify_git_config() {
  local repo_name=$1
  local gerrit_id=$2
  local write_to_script=$3
  if [[ $# -ne 3 ]]; then
    log "BUG: $# args received by ${FUNCNAME}"
    exit 100
  fi

  echo "cd /home/plumgrid/work/${repo_name}/.git && sed -i \"/url = ssh:/ c\        url = ssh://${gerrit_id}@192.168.10.77:29418/${repo_name}.git\" config" >> ${write_to_script}
}

# *****************************************************************************
# Function: get_latest_logs
# Purpose : Gets the latest test logs from docker in a .tar file.
#           User might run several tests in on the instance, the funtion gets
#           only the latest results.
# Usage   : get_latest_logs
# *****************************************************************************
function get_latest_logs() {
  local instance_ip=$1
  local instance_name=$2
  local log_dir=$3

  local local_file=$(mktemp /tmp/collect_log-XXXXX)
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "ls -rtd /opt/pg/log/*/ | tail -1 > /tmp/latest_log_dir" >> ${local_file}
  echo "LOG_FNAME=\$(cat /tmp/latest_log_dir |cut -d '/' -f 5)" >> ${local_file}
  echo "tar -zcf /tmp/\${LOG_FNAME}.tar \`cat /tmp/latest_log_dir\`" >> ${local_file}
  echo "echo \${LOG_FNAME} > /tmp/latest_log_filename"  >> ${local_file}
  upload_to_docker ${instance_ip} ${local_file} ${local_file}
  rm ${local_file}
  run_cmd_docker ${instance_ip} "bash ${local_file}"
  download_from_docker ${instance_ip} /tmp/latest_log_filename ${log_dir}/latest_log_filename
  local log_tar=$(cat ${log_dir}/latest_log_filename)
  download_from_docker ${instance_ip} /tmp/${log_tar}.tar ${log_dir}/${instance_name}-logs.tar
  echo "Logs have been placed at ${log_dir}/${instance_name}-logs.tar"
}

# ******************************************************************************
# Function: run_poll_cmd
# Purpose : Poll the given gcloud command running in the background on the basis
#           of pid to see if the command is completed. On completion, create an
#           empty file in /tmp
# Usage   : run_poll_cmd <cloud_instance_ip> <process_to_poll_for> <check for failure>
# ******************************************************************************
function run_poll_cmd() {
  local INSTANCE_IP=$1
  local process=$2
  local LOG_FILE=$3
  local ERROR_CHECK=$4
  local local_file=$(mktemp /tmp/poll_gcloud_cmd-XXXXX)

  # Create a script that will constantly poll for the running process and exit only when it has ended
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "echo \"Waiting for command to finish ... (Log will be tailed below) \"" >> ${local_file}
  echo "tail -f $LOG_FILE &" >> ${local_file}
  echo "while [[ ! -z \`pgrep -f ${process}\` ]]; do sleep 5; done;" >> ${local_file}
  echo "pkill tail" >> ${local_file}

  # If error checking is enabled checking for the return value of the script.
  if [ $ERROR_CHECK -eq 1 ]; then
    echo "return_value=\$(tail -1 $LOG_FILE)" >> ${local_file}
    #The last line contains the return value of the script.
    echo "if [[ \$return_value == \"Return Value=0\" ]]; then" >> ${local_file}
    echo "echo \"$process completely successfully, exiting\"" >> ${local_file}
    #Any value other than zero means either the script did not complete or encountered an error
    echo "else echo \"$process did not complete successfully, exiting\"" >> ${local_file}
    echo "exit 1" >> ${local_file}
    echo "fi" >> ${local_file}
  else
    #Exit true if no error checking is enabled
    echo "echo \"$process completely successfully, exiting\"" >> ${local_file}
  fi

  tryexec upload_to_docker ${INSTANCE_IP} ${local_file} ${local_file}
  rm ${local_file}
  tryexec run_cmd_docker ${INSTANCE_IP} "bash ${local_file}"
}
# ******************************************************************************
# Function: run_bg_cmd
# Purpose : Takes a script located on the docker and appends the return value checking
#           to the script. The script is then run in the background
# Usage   : run_bg_cmd <cloud_instance_ip> <path to docker file> <command to run> <log file>
# ******************************************************************************
function run_bg_cmd() {
  local INSTANCE_IP=$1
  local docker_file=$2
  local CMD=$3
  local LOG_FILE=$4
  #Append error checking to the file.
  tryexec run_cmd_docker ${INSTANCE_IP} "\"sed -i '$ a\retval=\\\$?' ${docker_file}\""
  tryexec run_cmd_docker ${INSTANCE_IP} "\"sed -i '$ a\echo \\\"Return Value=\\\$retval\\\"\' ${docker_file}\""
  #Run the command in the background
  tryexec run_cmd_docker_sshforwarding_bg ${INSTANCE_IP} "$CMD" "$LOG_FILE"

}
# ******************************************************************************
# Function: run_build_all
# Purpose : Creates a script for running build-all, uploads and runs the script
#           on the docker container. The return value for build-all is echoed to
#            check for failure.
# Usage   : run_build_all <cloud_instance_ip> <APT_COMPONENT> <log file>
# ******************************************************************************
function run_build_all() {
  local INSTANCE_IP=$1
  local APT_COMPONENT=$2
  local LOG_FILE=$3
  local local_file=$(mktemp /tmp/run_build_all-XXXXX)
  cat /dev/null > ${local_file}
  echo "apt_component=$1" >> ${local_file}
  echo "export APT_COMPONENT=${apt_component}" >> ${local_file}
  echo "source /opt/pg/env/alps.bashrc" >> ${local_file}
  echo "cd /home/plumgrid/work/pkg/build" >> ${local_file}
  echo "../scripts/build-all.sh --useallcpus" >> ${local_file}

  tryexec upload_to_docker ${INSTANCE_IP}  ${local_file} ${local_file}
  #File name needs to be constant for continue functionality, thus renaming.
  local docker_file=$(dirname $local_file)
  docker_file="${docker_file}/run_build_all.sh"
  tryexec run_cmd_docker ${INSTANCE_IP} "mv ${local_file} ${docker_file}"
  rm ${local_file}
  tryexec run_bg_cmd ${INSTANCE_IP} ${docker_file} "/bin/bash ${docker_file} ${APT_COMPONENT}" "$LOG_FILE"

}
# ******************************************************************************
# Function: run_automaton_init
# Purpose : Creates a script for running automaton-init, uploads and runs the script
#           on the docker container. The return value for automaton-init is echoed to
#           check for failure.
# Usage   : run_automaton_init <cloud_instance_ip> <log file>
# ******************************************************************************
function run_automaton_init() {
  local INSTANCE_IP=$1
  local LOG_FILE=$2
  local local_file=$(mktemp /tmp/run_automaton_init-XXXXX)
  cat /dev/null > ${local_file}
  echo "sudo cp /etc/hosts /tmp;" >> ${local_file}
  echo "sudo umount /etc/hosts;" >> ${local_file}
  echo "sudo mv /tmp/hosts /etc/hosts;" >> ${local_file}
  echo "sudo cp /etc/resolv.conf /tmp;" >> ${local_file}
  echo "sudo umount /etc/resolv.conf;" >> ${local_file}
  echo "sudo mv /tmp/resolv.conf /etc/resolv.conf;" >> ${local_file}
  echo "cd /opt/pg/systest/lxc/automaton;" >> ${local_file}
  echo "sudo ./automaton-init.sh" >> ${local_file}

  tryexec upload_to_docker ${INSTANCE_IP}  ${local_file} ${local_file}
  #File name needs to be constant for continue functionality, thus renaming.
  local docker_file=$(dirname $local_file)
  docker_file="${docker_file}/run_automaton_init.sh"
  tryexec run_cmd_docker ${INSTANCE_IP} "mv ${local_file} ${docker_file}"
  rm ${local_file}
  tryexec run_bg_cmd ${INSTANCE_IP} ${docker_file} "/bin/bash ${docker_file}" "$LOG_FILE"
}


# *****************************************************************************
# Function: create_snapshot
# Purpose : Creates a snapshot from disk.
#           After issuing the request for snapshot creation, it will start
#           polling that whether creation is successfull or not? If unsuccessful
#           for 450 seconds, then another request will be issued for creation.
#           Function also handles the situation where "false alarm" of error
#           is raised by system.
# Usage   : create_snapshot <diskname> <snapshotname>
# *****************************************************************************
function create_snapshot {
  local DISK_NAME=$1
  local SNAPSHOT_NAME=$2
  local success=0
  local retval=0
  # Check if snapshot already exists
  gcloud compute snapshots list ${SNAPSHOT_NAME} | grep "${SNAPSHOT_NAME}" || retval=$?
  if [ $retval -eq 0 ]; then
    echo "Snapshot already exists"
    exit 1
  fi

  for i in `seq 1 5`;
  do
    echo "Try-$i: Request for snapshot creation"
    # Issue snapshot creation command.
    retval=0
    gcloud compute disks snapshot ${DISK_NAME} --snapshot-names ${SNAPSHOT_NAME} || retval=$?
    if [ $retval -eq 0 ]; then
      return 0;
    fi
    for j in `seq 1 15`;
    do
      echo "$j: checking snapshot ${SNAPSHOT_NAME} creation...."
      # Make sure snapshot is in READY state (not in UPLOADING or anyother state).
      retval=0
      gcloud compute snapshots list ${SNAPSHOT_NAME} | grep "${SNAPSHOT_NAME}" | grep "READY"|| retval=$?
      if [ $retval -eq 0 ]; then
        success=1
        break
      fi
      sleep 2
    done

    # Check whether Snapshot creation remains successfull? If so, then exit from loop.
    # Otherwise, issue a fresh request for it.
    if [ ${success} -eq 1 ]; then
      echo "SNAPSHOT:${SNAPSHOT_NAME} creation successful: exiting outer loop"
      return 0
    fi
    sleep 30
  done
}
# *****************************************************************************
# Function: cleanup
# Purpose : Cleans up the instances and disks in case of failure.
# Usage   : cleanup
# Prereq  :
# *****************************************************************************
function cleanup() {
  gcloud compute instances delete $INSTANCE_NAME -q --delete-disks all
}

# *****************************************************************************
# Function: tryexec
# Purpose : Try to execute a command. If the command returns success, this
#           function returns 0. Otherwise, the script is aborted with the status
#           code of the failed command.
# Usage   : tryexec <command>
# Prereq  :
# *****************************************************************************
function tryexec() {
  local retval=0;
  "$@" || retval=$?
  [[ $retval -eq 0 ]] && return 0

  echo 'A command has failed:'
  echo "  $@"
  echo "Value returned: ${retval}"
  echo "$(basename $0) Failed, do you want to cleanup the instances?"
  read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with cleanup..."
      cleanup
      exit $retval
    else
      exit $retval
    fi
}
# *****************************************************************************
# Function: check_build_inputs
# Purpose : Checks if the inputs provided to aurora build are correct.
# Usage   : check_build_inputs <PROJECT> <REFSPEC> <BRANCH>
# Prereq  :
# *****************************************************************************
function check_build_inputs() {
  local INSTANCE_NAME=$1
  local PROJECT=$2
  local REFSPEC=$3
  local BRANCH=$4
  local RESULT=1

  #Check instance name length
  #GCE allows a maximum of 62 characters for disks and instances.
  #13 characters are appended when the instance a run instance is created.
  #Leaving a room for 20 characters for run in case it  is changed later.
  if [ ${#INSTANCE_NAME} -gt "42" ]; then
    echo "Instace name is too long, exiting."
    exit 1
  fi

  #Check project name
  local project_list=$(ssh -p ${GERRIT_PORT} ${gerritid}@${GERRIT_IP} gerrit ls-projects)
  for project_name in ${project_list}; do
    if [[ $project_name =~ $PROJECT ]]; then
      RESULT=0
      break
    fi
  done

  if [[ $RESULT -eq 1 ]]; then
    echo "Invalid project name: ${PROJECT}"
    show_build_help
    exit 1
  fi
  if [[ "$REFSPEC" != "none" ]]; then
    #Check refspec format
    if [[ ! $REFSPEC =~ ^refs/changes/[0-9]+/[0-9]+/[0-9]+$ ]]; then
      echo "Invalid refspec format"
      show_build_help
      exit 1
    fi
    #Check if refespec exists for the project
    git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/${PROJECT} "${REFSPEC}" | grep "${REFSPEC}" || RESULT=$?
    if [[ $RESULT -ne 0 ]];then
      echo "Refspec: $REFSPEC does not exist for the project: ${PROJECT}"
      show_build_help
      exit 1
    fi
  fi
  #Check if branch exists
  git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/${PROJECT} "${BRANCH}" | grep -q "${BRANCH}" || RESULT=$?
    if [[ $RESULT -ne 0 ]];then
    echo "Branch: $BRANCH does not exist for the project: ${PROJECT}"
    show_build_help
    exit 1
  fi
}
# *****************************************************************************
# Function: check_run_inputs
# Purpose : Checks if the inputs provided to aurora run are correct.
# Usage   : check_run_inputs <BUILDID> <TESTNAME>
# Prereq  :
# *****************************************************************************
function check_run_inputs() {
  local BUILDID=$1
  local TESTNAME=$2
  local RESULT

  gcloud compute snapshots list ${BUILDID}-ssd1 | grep "${BUILDID}-ssd1" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Snapshot ${BUILDID}-ssd1 does not exist, wrong Build-ID"
    show_run_help
    exit 1
  fi

  gcloud compute snapshots list ${BUILDID}-ssd2 | grep "${BUILDID}-ssd2" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Snapshot ${BUILDID}-ssd2 does not exist, wrong Build-ID"
    show_run_help
    exit 1
  fi

  if [ ! -f "$TESTNAME" ]; then
    echo "Test file \"$TESTNAME\" not found!"
    show_run_help
    exit 1
  fi
}

function record_step() {
  local step=$1
  local step_file=$2
  echo $step > ${step_file}
}

# ***********************************************************************************
# Function: upload_to_docker
# Purpose : Upload a file/folder from your local machine to Docker container
# Usage   : upload_to_docker <Cloud instance IP where docker container is running>
#                            <Local file which needs to be uploaded>
#                            <path to destination directory>
# Prereq: Your laptop's key must be already in docker container before this operation
# Test function by giving relative path.
# ***********************************************************************************
function upload_to_docker() {
  local INSTANCE_IP=$1
  local FILE=$2
  local DESTINATION=$3

  echo "** $INSTANCE_NAME $FILE $DESTINATION **"
  local FILE_NAME="${FILE##*/}"
  scp -o StrictHostKeyChecking=no -r $FILE "${USER}@${INSTANCE_IP}:/tmp/"
  run_cmd_gci ${INSTANCE_IP} "scp -r -o StrictHostKeyChecking=no /tmp/${FILE_NAME} plumgrid@\`cat local_docker_ip\`:$DESTINATION" "tA"
}

# *****************************************************************************
# Function: download_from_docker
# Purpose : Download a file/folder from docker container to your local machine.
# Usage   : download_from_docker <Cloud instance IP where docker container is running>
#                                <Location of file which needs to be downloaded>
#                                <Local machine's path where you need to download>
# Prereq: Your laptop's key must be already in docker container before this operation.
# *****************************************************************************
function download_from_docker() {
  local INSTANCE_IP=$1
  local FILE=$2
  local DESTINATION=$3

  local FILE_NAME="${FILE##*/}"
  run_cmd_gci ${INSTANCE_IP} "scp -r -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\`:$FILE /tmp/$FILE_NAME" "tA"
  scp -o StrictHostKeyChecking=no "${USER}@${INSTANCE_IP}:/tmp/$FILE_NAME" ${DESTINATION}
}
# *****************************************************************************
# Function: check_instance_limit
# Purpose : Checks if the number of currently running is less than the MAX number of
#           instances allowed.
# Usage   : check_instance_limit
# Prereq  : aurora init has been called
# *****************************************************************************
 function check_instance_limit() {
  local CURRENT_INSTANCES=$(gcloud compute instances list --regexp "${gerritid_lower}-.*" --zones $ZONE | grep "${gerritid_lower}-" | wc -l)
  #Check against max instances allowed.
  if [[ $CURRENT_INSTANCES -lt $MAX_USER_INSTANCES ]]; then
    return 0
  else
    echo "Currently running instances (${CURRENT_INSTANCES}) for user:${gerritid} exceeds maximum allowed (${MAX_USER_INSTANCES})"
    echo "Please delete existing instances to continue."
    exit 1
  fi
 }
# *****************************************************************************
# Function: print_time_taken
# Purpose : Prints the time duration between two intervals in HH:MM:SS format
# Usage   : print_time_taken <start time> <end time> <step>
# *****************************************************************************
 function print_time_taken() {
  local start_time=$1
  local end_time=$2
  local step=$3
  local time_diff=$(( ${end_time}- ${start_time} ))
  printf "Time taken in ${step}: %02d:%02d:%02d\n" "$(( time_diff/3600 ))" "$(( (time_diff%3600)/60 ))" "$(( time_diff%60 ))"

  }
