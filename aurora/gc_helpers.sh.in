#!/bin/bash -e
export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
source aurora_infra_settings.conf
source help.sh

if [[ -z "${WORKSPACE}" ]]; then
  if [[ ! -d /tmp/logs ]]; then
    mkdir /tmp/logs
  fi
  WORKSPACE=/tmp
fi
if [[ ! -d "${WORKSPACE}/logs" ]] ; then
  mkdir -p ${WORKSPACE}/logs
fi

function init_id() {
  if [[ $1 == "help" ]] ; then
    show_init_help
    exit 1
  fi
  conf_file="/home/$USER/.aurora.conf"
  echo "Please enter your gerrit id: "
  read gerritid
  echo "gerritid=${gerritid}" > ${conf_file}
  echo "gerritid_lower=${gerritid,,}" >> ${conf_file}
  echo "Please enter your plumgrid email: "
  read emailid
  echo "emailid=${emailid}" >> ${conf_file}
  echo "MAX_USER_INSTANCES=15" >> ${conf_file}
  gcloud config set project $GCLOUD_PROJECT
  gcloud config set compute/zone $ZONE
  gcloud config set compute/region $REGION
}

# *****************************************************************************
# Function: run_cmd_gci
# Purpose : Run command on Google Cloud instance.
# Usage   : run_cmd_gci <cloud_instance_ip>
# *****************************************************************************
function run_cmd_gci() {
  local INSTANCE_IP=$1
  local CMD=$2
  local SSH_FLAGS=${3:-t}

  ssh -${SSH_FLAGS} -o UserKnownHostsFile=/dev/null -o CheckHostIP=no -o StrictHostKeyChecking=no -o ServerAliveInterval=5 ${USER}@${INSTANCE_IP} "$CMD"
}

# *****************************************************************************
# Function: check_and_start_ssh_agent
# Purpose : check if ssh agent is running, if not start it and add keys to it
# Usage   : check_and_start_ssh_agent
# *****************************************************************************
function check_and_start_ssh_agent() {
  PFOUND="0"
  AGENT_PID=$(pgrep ssh-agent) && PFOUND="1"
  if [[ -z "$SSH_AUTH_SOCK" ]] ; then
     PFOUND="0"
  fi
  if [[ "$PFOUND" == "0" ]] ; then
    echo "running ssh-add"
    eval `ssh-agent -s`
  fi
  # always refresh the keys in case they where timedout
  PFOUND="0"
  if [[ -f ${HOME}/.ssh/jenkins-slave-gerrit ]]; then
    ssh-add ${HOME}/.ssh/jenkins-slave-gerrit && PFOUND="1"
  else
    ssh-add && PFOUND="1"
  fi
  if [[ "$PFOUND" == "0" ]] ; then
      # if ssh add failed
      # Re star the ssh agent and re-add the keys
      pkill ssh-agent
      eval `ssh-agent -s`
      if [[ -f ${HOME}/.ssh/jenkins-slave-gerrit ]]; then
        ssh-add ${HOME}/.ssh/jenkins-slave-gerrit
      else
        ssh-add
      fi
  fi
}

# *****************************************************************************
# Function: run_cmd_gci_sshforwarding
# Purpose : Run command on Google Cloud instance with ssh forwarding.
# Usage   : run_cmd_gci_sshforwarding <cloud_instance_ip>
# *****************************************************************************
function run_cmd_gci_sshforwarding() {
  local INSTANCE_IP=$1
  local CMD=$2
  check_and_start_ssh_agent
  run_cmd_gci ${INSTANCE_IP} "${CMD}" tA
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker() {
  local INSTANCE_IP=$1
  local DOCKER_CMD=$2

  echo run_cmd_gci ${INSTANCE_IP} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
  run_cmd_gci ${INSTANCE_IP} "ssh -t -o ServerAliveInterval=5 -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
}


# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_bg() {
  local INSTANCE_IP=$1
  local DOCKER_CMD=$2
  local LOG_FILE=$3

  run_cmd_gci ${INSTANCE_IP} "ssh -t -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` \" nohup bash -c '${DOCKER_CMD} > ${LOG_FILE} 2>&1 &' \""
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_sshforwarding() {
  local INSTANCE_IP=$1
  local DOCKER_CMD=$2

  run_cmd_gci_sshforwarding ${INSTANCE_IP} "ssh -tA -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_sshforwarding_bg() {
  local INSTANCE_IP=$1
  local DOCKER_CMD=$2
  local LOG_FILE=$3

  run_cmd_gci_sshforwarding ${INSTANCE_IP} "ssh -t -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` \" nohup bash -c '${DOCKER_CMD} > ${LOG_FILE} 2>&1 &' \""
}


# *****************************************************************************
# Function: push_local_changes
# Purpose : Pushes the specified local changes to the docker container.
# Usage   : push_local_changes
# Prereq: Aurora init has been called.
# *****************************************************************************
function push_local_changes() {
  local INSTANCE_IP=$1
  local COMMIT_ID=$2
  local ALPS_PATH=$3

  cd $ALPS_PATH
  #Get branch name from commit
  local BRANCH=$(git branch --contains $COMMIT_ID | cut -d ' ' -f 2)
  local DOCKER_IP=$(get_docker_ip ${INSTANCE_IP})
  run_cmd_docker ${INSTANCE_IP} "git config  -f /home/plumgrid/work/alps/.git/config receive.denyCurrentBranch ignore"
  local local_file=$(mktemp /tmp/ssh-command-XXXXX)
  #Proxy command to SSH directly into the docker container
  echo "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no  -o \"ProxyCommand ssh ${INSTANCE_IP} nc ${DOCKER_IP} 22\" \$*" > ${local_file}
  #Has to be executable
  chmod +x $local_file
  #Push the changes
  cd $ALPS_PATH;GIT_SSH="${local_file}" git push plumgrid@${DOCKER_IP}:/home/plumgrid/work/alps $COMMIT_ID:$BRANCH
  #Checkout the branch
  run_cmd_docker ${INSTANCE_IP} "git --git-dir=/home/plumgrid/work/alps/.git --work-tree=/home/plumgrid/work/alps checkout $BRANCH"
  rm ${local_file}
}

# *****************************************************************************
# Function: wait_for_instance
# Purpose : Wait Cloud instance to come up.
# Usage   : wait_for_instance <cloud_instance_ip>
# *****************************************************************************
function wait_for_instance() {
  local INSTANCE_IP=$1
  local RESULT=1
  for i in `seq 1 60`;
    do
      echo "Trying to ssh to ${INSTANCE_NAME} Iteration [$i]"
      run_cmd_gci ${INSTANCE_IP} "ls" >> ${WORKSPACE}/logs/build_image.2.log 2>&1  && RESULT=0 && break
      sleep 1
    done
  return $RESULT
}
# *****************************************************************************
# Purpose : Check whether ssh server is up and running.
# Usage   : wait_for_instance <cloud_instance_ip>
# *****************************************************************************
function check_ssh_server_status() {
  local INSTANCE_IP=$1
  local RESULT=1
  echo "check if ssh server is up and running"
  #check_and_start_ssh_agent

  for i in `seq 1 60`;
    do
      echo "Trying to ssh to ${DOCK_NAME} Iteration [$i]"
      run_cmd_gci ${INSTANCE_IP} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ls" "tA" >> ${WORKSPACE}/logs/build_image.3.log  2>&1 && RESULT=0 && break
      sleep 1
    done
  return $RESULT
}

# *****************************************************************************
# Purpose : Run docker container inside given instance
# *****************************************************************************
function run_dock_container() {
  local INSTANCE_IP=$1
  local DOCK_NAME=$2
  local DOCK_ID_FILE=$3
  local DOCK_IP_FILE=$4

  local local_file=$(mktemp /tmp/fix_docker_startup-XXXXX)
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "sudo ifconfig eth0 mtu 1400" >> ${local_file}
  echo "sudo docker inspect --format '{{json .Id}}' ${DOCK_NAME} | tr -d '\\\"' > /tmp/docker_image_id_t" >> ${local_file}
  echo 'sudo sed -i "s/sudo rsyslogd$/sudo rsyslogd\&/" /var/lib/docker/btrfs/subvolumes/`cat /tmp/docker_image_id_t`/home/plumgrid/startup.sh' >> ${local_file}
  echo 'sudo sed -i "s/\/usr\/sbin\/sshd -D$/while :; do \/usr\/sbin\/sshd -D;sleep 1; done/" /var/lib/docker/btrfs/subvolumes/`cat /tmp/docker_image_id_t`/home/plumgrid/startup.sh' >> ${local_file}

  #retval=0
  #while :; do
  #  /usr/bin/pgrep apache2 > /dev/null || retval=$?
  #  if [[ $retval -ne 0 ]]
  #  then
  #    echo "Going to restart apache"
  #    sudo /etc/init.d/apache2 restart > /dev/null
  #    retval=0
  #  fi
  #  sleep 5;
  #done &
  echo 'sudo sed -i "s/sudo \/etc\/init.d\/apache2 start/retval=0 \n \
    while :; do \n \
    \/usr\/bin\/pgrep apache2 \> \/dev\/null \|\| retval=\$? \n \
    if [[ \$retval -ne 0 ]] \n \
    then \n \
      echo \"Going to restart apache\" \n \
      sudo \/etc\/init.d\/apache2 restart \> \/dev\/null \n \
      retval=0 \n \
    fi \n \
    sleep 5; \n \
  done \&/" /var/lib/docker/btrfs/subvolumes/`cat /tmp/docker_image_id_t`/home/plumgrid/startup.sh' >> ${local_file}
  echo 'sudo /etc/init.d/apparmor stop' >> ${local_file}
  echo 'sudo /etc/init.d/apparmor teardown' >> ${local_file}
  echo 'echo 1 | sudo tee /proc/sys/net/ipv6/conf/all/disable_ipv6' >> ${local_file}
  echo 'rm /tmp/docker_image_id_t' >> ${local_file}
  echo "if sudo lsmod | grep '^bonding' ; then" >> ${local_file}
  echo "  log 'Removing bonding module'" >> ${local_file}
  echo "  sudo rmmod bonding" >> ${local_file}
  echo "fi" >> ${local_file}
  echo "sudo modprobe bonding mode=2" >> ${local_file}
  scp -o StrictHostKeyChecking=no ${local_file} ${USER}@${INSTANCE_IP}:${local_file}
  rm ${local_file}
  run_cmd_gci ${INSTANCE_IP} "bash ${local_file}"
  run_cmd_gci ${INSTANCE_IP} "DID=\$(sudo docker run  --cap-add=all  --cap-add=SYS_ADMIN \
    --lxc-conf='lxc.aa_profile=unconfined' --privileged -d ${DOCK_NAME} /home/plumgrid/startup.sh) && \
    echo \$DID > ${DOCK_ID_FILE} && \
    sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}' \$DID > ${DOCK_IP_FILE}"
  run_cmd_gci ${INSTANCE_IP} "sudo docker inspect -f '{{.State.Pid}}' \`cat ${DOCK_ID_FILE}\` > ${DOCK_ID_FILE}.pid"
  run_cmd_gci ${INSTANCE_IP} "sudo ip link set bond0 netns \`cat ${DOCK_ID_FILE}.pid\`"
}

# *****************************************************************************
# Purpose : Check whether docker is running fine.
# Usage   : verify_docker_running <cloud_instance_ip> <docker_name>
# *****************************************************************************
function verify_docker_running() {
  local INSTANCE_IP=$1
  local DOCKER_NAME=$2

  for i in `seq 1 5`; do
    echo "Try$i: Checking whether ${DOCKER_NAME} is running ....?"
    run_cmd_gci ${INSTANCE_IP} "sudo docker ps | grep ${DOCK_NAME} &> /dev/null"
    if [[ $? == 0 ]]; then
      echo "Docker container is running"
      return 0
    fi
    sleep 3
  done
  echo "Docker $DOCKER_NAME is not running.."
  return 1
}

# *****************************************************************************
# Purpose : Configure docker according to PG requirements.
# *****************************************************************************
function configure_docker() {
  local INSTANCE_IP=$1

  run_cmd_gci ${INSTANCE_IP} "echo 'DOCKER_OPTS=\"--mtu 1400 --insecure-registry pg-docker-repo:5000\"' | sudo tee /etc/default/docker && sudo service docker restart"
}

# *****************************************************************************
# Purpose : Check whether docker is successfully committed.
# Usage   : verify_docker_commited <cloud_instance_ip> <docker_name>
# *****************************************************************************
function verify_docker_commited() {
  local INSTANCE_IP=$1
  local DOCK_NAME=$2

  for i in `seq 1 5`; do
    echo "Try$i: Checking whether ${DOCK_NAME} is committed ....?"
    run_cmd_gci ${INSTANCE_IP} "sudo docker images | grep ${DOCK_NAME} &> /dev/null"
    if [[ $? == 0 ]]; then
      echo "Docker container is committed"
      return 0
    fi
    sleep 3
  done
  echo "Docker $DOCKER_NAME is not committed.."
  return 1
}

function setup_forwarding() {
  local INSTANCE_IP=$1

  run_cmd_gci ${INSTANCE_IP} "echo 'host *' > ~/.ssh/config; echo '    ForwardAgent yes'>>~/.ssh/config"
}

# *****************************************************************************
# Purpose : ADD key to authroized keys of docker container running on instance
# Usage   :
# KEY_PATH:       KEY path on cloud insctance machine.
# DOCKER_ID_FILE: File which holds the docker id on instance
# TODO: Not tested much
# *****************************************************************************
function add_to_dock_authorized_keys() {
  local INSTANCE_IP=$1
  local KEY_PATH=$2
  local DOCK_ID_FILE=$3

  run_cmd_gci ${INSTANCE_IP} "sudo su -c \"cat ${KEY_PATH} >> \
    /var/lib/docker/btrfs/subvolumes/\`cat ${DOCK_ID_FILE}\`/home/plumgrid/.ssh/authorized_keys\""
}

# *****************************************************************************
# Function: get_lastest_snapshot_id
# Purpose : Lists the snapshot with the highest time stamp.
# Usage   : get_lastest_snapshot_id
# *****************************************************************************
function get_latest_snapshot_id() {
  #The snapshots are sorted in desencding order by name. Sorting by name also works for numbers.
  local latest_ss=$(gcloud compute snapshots list --sort-by=~NAME --regexp=${PRIM_INST_NAME}-d1-.* --limit=1 | grep ${PRIM_INST_NAME}-d1- | cut  -d ' ' -f 1)
  local ssid="${latest_ss##*-}"

  echo $ssid
}
# *****************************************************************************
# Function: get_docker_ip
# Purpose : Gets the  IP address of the docker container.
# Usage   : get_docker_ip <instance IP>
# *****************************************************************************
function get_docker_ip() {
local INSTANCE_IP=$1
local DOCKER_IP=$(run_cmd_gci ${INSTANCE_IP} "cat /home/$USER/local_docker_ip")

echo -n "$DOCKER_IP"
}
# *****************************************************************************
# Function: get_instance_ip
# Purpose : Gets the internal IP address of the instance.
# Usage   : get_instance_ip <instance name>
# *****************************************************************************
function get_instance_ip() {
  local INSTANCE_NAME=$1
  local internal_ip=$(gcloud compute instances list ${INSTANCE_NAME} --zones=${ZONE} | grep ${INSTANCE_NAME})
  internal_ip=$(echo "$internal_ip" | cut -d ' ' -f 4)

  echo $internal_ip
}

# *****************************************************************************
# Function: modify_git_config
# Purpose : Modify the git config inside docker acc to current user in order to
#           checkout/clone commits/repos
# Usage   : modify_git_config <repo_name> <gerrit_id> <write_to_script>
# *****************************************************************************
function modify_git_config() {
  local repo_name=$1
  local gerrit_id=$2
  local write_to_script=$3
  if [[ $# -ne 3 ]]; then
    log "BUG: $# args received by ${FUNCNAME}"
    exit 100
  fi

  echo "cd /home/plumgrid/work/${repo_name}/.git && sed -i \"/url = ssh:/ c\        url = ssh://${gerrit_id}@192.168.10.77:29418/${repo_name}.git\" config" >> ${write_to_script}
}

# *****************************************************************************
# Function: get_latest_logs
# Purpose : Gets the latest test logs from docker in a .tar file.
#           User might run several tests in on the instance, the funtion gets
#           only the latest results.
# Usage   : get_latest_logs
# *****************************************************************************
function get_latest_logs() {
  local instance_ip=$1
  local instance_name=$2
  local log_dir=$3

  local local_file=$(mktemp /tmp/collect_log-XXXXX)
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "ls -rtd /opt/pg/log/*/ | tail -1 > /tmp/latest_log_dir" >> ${local_file}
  echo "LOG_FNAME=\$(cat /tmp/latest_log_dir |cut -d '/' -f 5)" >> ${local_file}
  echo "tar -zcf /tmp/\${LOG_FNAME}.tar \`cat /tmp/latest_log_dir\`" >> ${local_file}
  echo "echo \${LOG_FNAME} > /tmp/latest_log_filename"  >> ${local_file}
  upload_to_docker ${instance_ip} ${local_file} ${local_file}
  rm ${local_file}
  run_cmd_docker ${instance_ip} "bash ${local_file}"
  download_from_docker ${instance_ip} /tmp/latest_log_filename ${log_dir}/latest_log_filename
  local log_tar=$(cat ${log_dir}/latest_log_filename)
  download_from_docker ${instance_ip} /tmp/${log_tar}.tar ${log_dir}/${instance_name}-logs.tar
  echo "Logs have been placed at ${log_dir}/${instance_name}-logs.tar"
}

# ******************************************************************************
# Function: run_poll_cmd
# Purpose : Poll the given gcloud command running in the background on the basis
#           of pid to see if the command is completed. On completion, create an
#           empty file in /tmp
# Usage   : run_poll_cmd <cloud_instance_ip> <process_to_poll_for> <check for failure>
# ******************************************************************************
function run_poll_cmd() {
  local INSTANCE_IP=$1
  local process=$2
  local LOG_FILE=$3
  local ERROR_CHECK=$4
  local local_file=$(mktemp /tmp/poll_gcloud_cmd-XXXXX)

  # Create a script that will constantly poll for the running process and exit only when it has ended
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "echo \"Waiting for command to finish ... (Log will be tailed below) \"" >> ${local_file}
  echo "tail -f $LOG_FILE &" >> ${local_file}
  echo "while [[ ! -z \`pgrep -f ${process}\` ]]; do sleep 5; done;" >> ${local_file}
  echo "pkill tail" >> ${local_file}

  # If error checking is enabled checking for the return value of the script.
  if [ $ERROR_CHECK -eq 1 ]; then
    echo "return_value=\$(tail -1 $LOG_FILE)" >> ${local_file}
    #The last line contains the return value of the script.
    echo "if [[ \$return_value == \"Return Value=0\" ]]; then" >> ${local_file}
    echo "echo \"$process completely successfully, exiting\"" >> ${local_file}
    #Any value other than zero means either the script did not complete or encountered an error
    echo "else echo \"$process did not complete successfully, exiting\"" >> ${local_file}
    echo "exit 1" >> ${local_file}
    echo "fi" >> ${local_file}
  else
    #Exit true if no error checking is enabled
    echo "echo \"$process completely successfully, exiting\"" >> ${local_file}
  fi

  tryexec upload_to_docker ${INSTANCE_IP} ${local_file} ${local_file}
  rm ${local_file}
  tryexec run_cmd_docker ${INSTANCE_IP} "bash ${local_file}"
}
# ******************************************************************************
# Function: run_bg_cmd
# Purpose : Takes a script located on the docker and appends the return value checking
#           to the script. The script is then run in the background
# Usage   : run_bg_cmd <cloud_instance_ip> <path to docker file> <command to run> <log file>
# ******************************************************************************
function run_bg_cmd() {
  local INSTANCE_IP=$1
  local docker_file=$2
  local CMD=$3
  local LOG_FILE=$4
  #Append error checking to the file.
  tryexec run_cmd_docker ${INSTANCE_IP} "\"sed -i '$ a\retval=\\\$?' ${docker_file}\""
  tryexec run_cmd_docker ${INSTANCE_IP} "\"sed -i '$ a\echo \\\"Return Value=\\\$retval\\\"\' ${docker_file}\""
  #Run the command in the background
  tryexec run_cmd_docker_sshforwarding_bg ${INSTANCE_IP} "$CMD" "$LOG_FILE"

}
# ******************************************************************************
# Function: make_install_alps
# Purpose : Creates a script for running building alps, uploads and runs the script
#           on the docker container. The return value for the install is echoed to
#           check for failure.
# Usage   : make_install_alps <cloud_instance_ip> <log file>
# ******************************************************************************
function make_install_alps() {
  local INSTANCE_IP=$1
  local LOG_FILE=$2
  local local_file=$(mktemp /tmp/make_install_alps-XXXXX)
  cat /dev/null > ${local_file}
  echo "cd /home/plumgrid/work/alps/build;" >> ${local_file}
  echo "cmake ..;" >> ${local_file}
  echo "make -j4 install" >> ${local_file}
  tryexec upload_to_docker ${INSTANCE_IP}  ${local_file} ${local_file}
  #File name needs to be constant for continue functionality, thus renaming.
  local docker_file=$(dirname $local_file)
  docker_file="${docker_file}/make_install_alps.sh"
  tryexec run_cmd_docker ${INSTANCE_IP} "mv ${local_file} ${docker_file}"
  rm ${local_file}
  tryexec run_bg_cmd ${INSTANCE_IP} ${docker_file} "/bin/bash ${docker_file}" "$LOG_FILE"
}
# ******************************************************************************
# Function: run_build_all
# Purpose : Creates a script for running build-all, uploads and runs the script
#           on the docker container. The return value for build-all is echoed to
#            check for failure.
# Usage   : run_build_all <cloud_instance_ip> <APT_COMPONENT> <log file>
# ******************************************************************************
function run_build_all() {
  local INSTANCE_IP=$1
  local APT_COMPONENT=$2
  local LOG_FILE=$3
  local local_file=$(mktemp /tmp/run_build_all-XXXXX)
  cat /dev/null > ${local_file}
  echo "apt_component=$1" >> ${local_file}
  echo "export APT_COMPONENT=${apt_component}" >> ${local_file}
  echo "source /opt/pg/env/alps.bashrc" >> ${local_file}
  echo "cd /home/plumgrid/work/pkg/build" >> ${local_file}
  echo "../scripts/build-all.sh --useallcpus" >> ${local_file}

  tryexec upload_to_docker ${INSTANCE_IP}  ${local_file} ${local_file}
  #File name needs to be constant for continue functionality, thus renaming.
  local docker_file=$(dirname $local_file)
  docker_file="${docker_file}/run_build_all.sh"
  tryexec run_cmd_docker ${INSTANCE_IP} "mv ${local_file} ${docker_file}"
  rm ${local_file}
  tryexec run_bg_cmd ${INSTANCE_IP} ${docker_file} "/bin/bash ${docker_file} ${APT_COMPONENT}" "$LOG_FILE"

}
# ******************************************************************************
# Function: run_automaton_init
# Purpose : Creates a script for running automaton-init, uploads and runs the script
#           on the docker container. The return value for automaton-init is echoed to
#           check for failure.
# Usage   : run_automaton_init <cloud_instance_ip> <log file>
# ******************************************************************************
function run_automaton_init() {
  local INSTANCE_IP=$1
  local LOG_FILE=$2
  local local_file=$(mktemp /tmp/run_automaton_init-XXXXX)
  cat /dev/null > ${local_file}
  echo "sudo cp /etc/hosts /tmp;" >> ${local_file}
  echo "sudo umount /etc/hosts;" >> ${local_file}
  echo "sudo mv /tmp/hosts /etc/hosts;" >> ${local_file}
  echo "sudo cp /etc/resolv.conf /tmp;" >> ${local_file}
  echo "sudo umount /etc/resolv.conf;" >> ${local_file}
  echo "sudo mv /tmp/resolv.conf /etc/resolv.conf;" >> ${local_file}
  echo "cd /opt/pg/systest/lxc/automaton;" >> ${local_file}
  echo "sudo ./automaton-init.sh" >> ${local_file}

  tryexec upload_to_docker ${INSTANCE_IP}  ${local_file} ${local_file}
  #File name needs to be constant for continue functionality, thus renaming.
  local docker_file=$(dirname $local_file)
  docker_file="${docker_file}/run_automaton_init.sh"
  tryexec run_cmd_docker ${INSTANCE_IP} "mv ${local_file} ${docker_file}"
  rm ${local_file}
  tryexec run_bg_cmd ${INSTANCE_IP} ${docker_file} "/bin/bash ${docker_file}" "$LOG_FILE"
}

# *****************************************************************************
# Function: exec_gcloud_instances
# Purpose : Wrapper for gcloud instances commands, retries the command if an error is encountered.
# Usage   : exec_gcloud_instances <operation> <name> <options>
# *****************************************************************************
function exec_gcloud_instances() {
  local operation=$1
  local name=$2
  local options=${@:3}

  case $operation in
    create)
      # Check if the instance already exists
      gcloud compute instances list ${name} --zones $ZONE | grep -q "${name}" || retval=$?
      if [ $retval -eq 0 ]; then
        echo "Instance:$name already exists."
        exit 1
      fi
      ;;
    delete)
        # Check if the instance is already deleted
        gcloud compute instances list ${name} --zones $ZONE | grep -q "${name}" || retval=$?
        if [ $retval -ne 0 ]; then
          echo "Instance:$name does not exist."
          exit 1
        fi
      ;;
    *)
      echo "Operation:$operation on Entity:Instances is invalid, Exiting"
      exit 1
  esac

  for i in `seq 1 5`;
  do
    echo "Try-$i: gcloud compute instances $operation $name $options"
    # Execute the command.
    retval=0
    gcloud compute instances $operation $name $options || retval=$?
    if [ $retval -eq 0 ]; then
      return 0;
    fi

    for j in `seq 1 15`;
    do
      case $operation in
        create)
          gcloud compute instances list $name | grep "${name}" | grep "RUNNING" || retval=$?
          if [ $retval -eq 0 ]; then
            success=1
            break
          fi
          ;;
        delete)
          gcloud compute instances list $name | grep "${name}" || retval=$?
          if [ $retval -ne 0 ]; then
            success=1
            break
          fi
          ;;
      esac
      sleep 5
    done
    if [ ${success} -eq 1 ]; then
      echo "SUCCESS"
      return 0
    fi
    sleep 30
  done
  return 1
}
# *****************************************************************************
# Function: exec_gcloud_snapshots
# Purpose : Wrapper for gcloud snapshots commands, retries the command if an error is encountered.
# Usage   : exec_gcloud_snapshots <operation> <name> <options>
# *****************************************************************************
function exec_gcloud_snapshots() {
  local operation=$1
  local name=$2
  local options=${@:3}
  case $operation in
  delete)
    # Check if the snapshot is already deleted
    gcloud compute snapshots list ${name} | grep -q "${name}" || retval=$?
    if [ $retval -ne 0 ]; then
      echo "Snapshot:$name does not exist."
      exit 1
    fi
    ;;
  *)
    echo "Operation:$operation on Entity:snapshot is invalid, Exiting"
    exit 1
  esac

  for i in `seq 1 5`;
  do
    echo "Try-$i: gcloud compute snapshot $operation $name $options"
    # Execute the command.
    retval=0
    gcloud compute snapshots $operation $name $options || retval=$?
    if [ $retval -eq 0 ]; then
      return 0;
    fi

    for j in `seq 1 15`;
    do
      echo "$j: Checking if $operation snapshots:$name succeeded"
      retval=0

      gcloud compute snapshots list $name | grep "${name}" || retval=$?
      if [ $retval -ne 0 ]; then
        success=1
        break
      fi
    sleep 5
    done
    if [ ${success} -eq 1 ]; then
      echo "SUCCESS"
      return 0
    fi
    sleep 30
  done
  return 1
}
# *****************************************************************************
# Function: exec_gcloud_disks
# Purpose : Wrapper for gcloud disks commands, retries the command if an error is encountered.
# Usage   : exec_gcloud_disks <operation> <name> <options>
# *****************************************************************************
function exec_gcloud_disks() {
  local operation=$1
  local name=$2
  local options=${@:3}
  case $operation in
    create)
      # Check if disk already exists
      gcloud compute disks list ${name} --zones $ZONE | grep -q "${name}" || retval=$?
      if [ $retval -eq 0 ]; then
        echo "Disk:$name already exists."
        exit 1
      fi
      ;;
    delete)
      # Check if disk already deleted
      gcloud compute disks list ${name} --zones $ZONE | grep -q "${name}" || retval=$?
      if [ $retval -ne 0 ]; then
        echo "Disk:$name does not exist."
        exit 1
      fi
      ;;
    snapshot)
      local snapshot_name=$4
      # Check if disk already deleted
      gcloud compute snapshots list ${snapshot_name} | grep -q "${snapshot_name}" || retval=$?
      if [ $retval -eq 0 ]; then
        echo "Snapshot:$snapshot_name already exists."
        exit 1
      fi
      ;;
    *)
      echo "Operation:$operation on Entity:disks is invalid, Exiting"
      exit 1
  esac

  for i in `seq 1 5`;
  do
    echo "Try-$i: gcloud compute disks $operation $name $options"
    # Execute the command.
    retval=0
    gcloud compute disks $operation $name $options || retval=$?
    if [ $retval -eq 0 ]; then
      return 0;
    fi

    for j in `seq 1 15`;
    do
      echo "$j: Checking if $operation disks:$name succeeded"
      retval=0
      case $operation in
        create)
          gcloud compute disks list $name | grep "${name}" | grep "READY" || retval=$?
          if [ $retval -eq 0 ]; then
            success=1
            break
          fi
          ;;
        delete)
          gcloud compute disks list $name | grep "${name}" || retval=$?
          if [ $retval -ne 0 ]; then
            success=1
            break
          fi
          ;;
        snapshot)
          gcloud compute snapshots list $snapshot_name | grep "${snapshot_name}" | grep "READY" || retval=$?
          if [ $retval -eq 0 ]; then
            success=1
            break
          fi
          ;;
      esac
      sleep 5
    done
    if [ ${success} -eq 1 ]; then
      echo "SUCCESS"
      return 0
    fi
    sleep 30
  done
  return 1
}

# *****************************************************************************
# Function: exec_gcloud_cmd
# Purpose : Wrapper for gcloud commands, retries the command if an error is encountered.
# Usage   : exec_gcloud_cmd <entity> <operation> <name> <options>
# *****************************************************************************
function exec_gcloud_cmd {
  local entity=$1
  local operation=$2
  local name=$3
  local options=${@:4}
  local retval=0
  local success=0
  #Check if the operation is valid on the entity
  case $entity in
    disks)
      exec_gcloud_disks $operation $name $options
      ;;
    instances)
      exec_gcloud_instances $operation $name $options
      ;;
    snapshots)
      exec_gcloud_snapshots $operation $name $options
      ;;
  *)
    echo "Entity:$entity is invalid. Exiting"
    exit 1
  esac

}

# *****************************************************************************
# Function: cleanup
# Purpose : Cleans up the instances and disks in case of failure.
# Usage   : cleanup
# Prereq  :
# *****************************************************************************
function cleanup() {
  gcloud compute instances delete $INSTANCE_NAME -q --delete-disks all
}

# *****************************************************************************
# Function: tryexec
# Purpose : Try to execute a command. If the command returns success, this
#           function returns 0. Otherwise, the script is aborted with the status
#           code of the failed command.
# Usage   : tryexec <command>
# Prereq  :
# *****************************************************************************
function tryexec() {
  local retval=0;
  "$@" || retval=$?
  [[ $retval -eq 0 ]] && return 0

  echo 'A command has failed:'
  echo "  $@"
  echo "Value returned: ${retval}"
  echo "$(basename $0) Failed, do you want to cleanup the instances?"
  read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with cleanup..."
      cleanup
      exit $retval
    else
      exit $retval
    fi
}

# *****************************************************************************
# Function: retryexec
# Purpose : Try to execute a command. If the command returns success, this
#           function returns 0. Otherwise, the script retries for a while. If
#           it still fails, its then aborted with the status code of the failed
#           command.
# Usage   : retryexec <command>
# Prereq  :
# *****************************************************************************
function retryexec() {
  retry=1
  until [[ $retry == "5" ]]
  do
     echo "Try $retry for command "
     echo "  $@"
     "$@"
     if [[ $? == "0" ]]; then
       break
     fi
     let retry++
     if [[ $retry == "5" ]]; then
       echo "Command $@ failed"
       echo "$(basename $0) Failed, do you want to cleanup the instances?"
       read -r -p "Are you sure you want to continue? (y/N)" response
       response=${response,,}    # tolower
       if [[ $response =~ ^(yes|y)$ ]]; then
         echo "Proceeding with cleanup..."
         cleanup
         exit 1
       else
         exit 1
       fi
     fi
     echo "Command $@ Failed on try $retry : Will try again, restarting ssh-agent befor retrying"
     pkill "ssh-agent" || true
  done
}

# *****************************************************************************
# Function: check_file_existence
# Purpose : Checks if the file exists.
# Usage   : check_file_existence <Path with filename>
# Prereq  :
# *****************************************************************************
function check_file_existence() {
  if [ ! -f "$1" ] ; then
    echo "$1 does not exist!"
    exit 1
  fi
}
# *****************************************************************************
# Function: check_build_inputs
# Purpose : Checks if the inputs provided to aurora build are correct.
# Usage   : check_build_inputs <PROJECT> <REFSPEC> <BRANCH>
# Prereq  :
# *****************************************************************************
function check_build_inputs() {
  local INSTANCE_NAME=$1
  local PROJECT=$2
  local REFSPEC=$3
  local BRANCH=$4
  local RESULT=1

  #Check instance name length
  #GCE allows a maximum of 62 characters for disks and instances.
  #13 characters are appended when the instance a run instance is created.
  #Leaving a room for 20 characters for run in case it  is changed later.
  if [ ${#INSTANCE_NAME} -gt "42" ]; then
    echo "Instace name is too long, exiting."
    exit 1
  fi

  #Check project name
  local project_list=$(ssh -p ${GERRIT_PORT} ${gerritid}@${GERRIT_IP} gerrit ls-projects)
  for project_name in ${project_list}; do
    if [[ $project_name =~ $PROJECT ]]; then
      RESULT=0
      break
    fi
  done
  if [[ $RESULT -eq 1 ]]; then
    echo "Invalid project name: ${PROJECT}"
    show_build_help
    exit 1
  fi
  if [[ "$REFSPEC" != "none" ]]; then
    #Check if refespec exists for the project
    git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/${PROJECT} "${REFSPEC}" | grep "${REFSPEC}" || RESULT=$?
    if [[ $RESULT -ne 0 ]];then
      echo "Refspec: $REFSPEC does not exist for the project: ${PROJECT}"
      show_build_help
      exit 1
    fi
  fi
  #Check if branch exists
  git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/${PROJECT} "${BRANCH}" | grep -q "${BRANCH}" || RESULT=$?
    if [[ $RESULT -ne 0 ]];then
    echo "Branch: $BRANCH does not exist for the project: ${PROJECT}"
    show_build_help
    exit 1
  fi
}
# *****************************************************************************
# Function: check_run_inputs
# Purpose : Checks if the inputs provided to aurora run are correct.
# Usage   : check_run_inputs <BUILDID> <TESTNAME>
# Prereq  :
# *****************************************************************************
function check_run_inputs() {
  local BUILDID=$1
  local TESTNAME=$2
  local RESULT

  gcloud compute snapshots list ${BUILDID}-ssd1 | grep "${BUILDID}-ssd1" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Snapshot ${BUILDID}-ssd1 does not exist, wrong Build-ID"
    show_run_help
    exit 1
  fi

  gcloud compute snapshots list ${BUILDID}-ssd2 | grep "${BUILDID}-ssd2" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Snapshot ${BUILDID}-ssd2 does not exist, wrong Build-ID"
    show_run_help
    exit 1
  fi

  if [ ! -f "$TESTNAME" ]; then
    echo "Test file \"$TESTNAME\" not found!"
    show_run_help
    exit 1
  fi
}

function record_step() {
  local step=$1
  local step_file=$2
  echo $step > ${step_file}
}

# ***********************************************************************************
# Function: upload_to_docker
# Purpose : Upload a file/folder from your local machine to Docker container
# Usage   : upload_to_docker <Cloud instance IP where docker container is running>
#                            <Local file which needs to be uploaded>
#                            <path to destination directory>
# Prereq: Your laptop's key must be already in docker container before this operation
# Test function by giving relative path.
# ***********************************************************************************
function upload_to_docker() {
  local INSTANCE_IP=$1
  local FILE=$2
  local DESTINATION=$3

  echo "** $INSTANCE_NAME $FILE $DESTINATION **"
  local FILE_NAME="${FILE##*/}"
  scp -o StrictHostKeyChecking=no -r $FILE "${USER}@${INSTANCE_IP}:/tmp/"
  run_cmd_gci ${INSTANCE_IP} "scp -r -o StrictHostKeyChecking=no /tmp/${FILE_NAME} plumgrid@\`cat local_docker_ip\`:$DESTINATION" "tA"
}

# *****************************************************************************
# Function: download_from_docker
# Purpose : Download a file/folder from docker container to your local machine.
# Usage   : download_from_docker <Cloud instance IP where docker container is running>
#                                <Location of file which needs to be downloaded>
#                                <Local machine's path where you need to download>
# Prereq: Your laptop's key must be already in docker container before this operation.
# *****************************************************************************
function download_from_docker() {
  local INSTANCE_IP=$1
  local FILE=$2
  local DESTINATION=$3

  local FILE_NAME="${FILE##*/}"
  run_cmd_gci ${INSTANCE_IP} "scp -r -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\`:$FILE /tmp/$FILE_NAME" "tA"
  scp -o StrictHostKeyChecking=no "${USER}@${INSTANCE_IP}:/tmp/$FILE_NAME" ${DESTINATION}
}
# *****************************************************************************
# Function: check_instance_limit
# Purpose : Checks if the number of currently running is less than the MAX number of
#           instances allowed.
# Usage   : check_instance_limit
# Prereq  : aurora init has been called
# *****************************************************************************
 function check_instance_limit() {
  local CURRENT_INSTANCES=$(gcloud compute instances list --regexp "${gerritid_lower}-.*" --zones $ZONE | grep "${gerritid_lower}-" | wc -l)
  #Check against max instances allowed.
  if [[ $CURRENT_INSTANCES -lt $MAX_USER_INSTANCES ]]; then
    return 0
  else
    echo "Currently running instances (${CURRENT_INSTANCES}) for user:${gerritid} exceeds maximum allowed (${MAX_USER_INSTANCES})"
    echo "Please delete existing instances to continue."
    exit 1
  fi
 }
# *****************************************************************************
# Function: print_time_taken
# Purpose : Prints the time duration between two intervals in HH:MM:SS format
# Usage   : print_time_taken <start time> <end time> <step>
# *****************************************************************************
 function print_time_taken() {
  local start_time=$1
  local end_time=$2
  local step=$3
  local time_diff=$(( ${end_time}- ${start_time} ))
  printf "Total Time taken in ${step}: %02d:%02d:%02d\n" "$(( time_diff/3600 ))" "$(( (time_diff%3600)/60 ))" "$(( time_diff%60 ))"

  }
