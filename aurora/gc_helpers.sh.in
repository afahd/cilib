#!/bin/bash -e
export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH

# *****************************************************************************
# Function: run_cmd_gci
# Purpose : Run command on Google Cloud instance.
# Usage   : run_cmd_gci <cloud_instance_name>
# *****************************************************************************
function run_cmd_gci() {
  local INSTANCE_NAME=$1
  local CMD=$2
  local SSH_FLAGS=${3:-t}
  gcloud compute -q ssh ${USER}@${INSTANCE_NAME} --ssh-flag="-${SSH_FLAGS}" --ssh-flag="-o ServerAliveInterval=5" --command "$CMD"
}

# *****************************************************************************
# Function: run_cmd_gci_sshforwarding
# Purpose : Run command on Google Cloud instance with ssh forwarding.
# Usage   : run_cmd_gci <cloud_instance_name>
# *****************************************************************************
function run_cmd_gci_sshforwarding() {
  local INSTANCE_NAME=$1
  local CMD=$2

  if [ -z "$SSH_AUTH_SOCK" ] ; then
    echo "running ssh-add"
    eval `ssh-agent -s`
    ssh-add
  fi

  run_cmd_gci ${INSTANCE_NAME} "${CMD}" tA
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker() {
  local INSTANCE_NAME=$1
  local DOCKER_CMD=$2

  run_cmd_gci ${INSTANCE_NAME} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_sshforwarding() {
  local INSTANCE_NAME=$1
  local DOCKER_CMD=$2

  run_cmd_gci_sshforwarding ${INSTANCE_NAME} "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ${DOCKER_CMD}"
}

# *****************************************************************************
# Function: run_cmd_docker
# Purpose : Ran a command inside docker container
# Usage   : run_cmd_docker <Instance Name on which docker is running>
# /_\ Caution: Not tested.
# *****************************************************************************
function run_cmd_docker_sshforwarding_bg() {
  local INSTANCE_NAME=$1
  local DOCKER_CMD=$2
  local LOG_FILE=$3

  run_cmd_gci_sshforwarding ${INSTANCE_NAME} "ssh -t -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` \" nohup bash -c '${DOCKER_CMD} > ${LOG_FILE} 2>&1 &' \""
}

# *****************************************************************************
# Function: wait_for_instance
# Purpose : Wait Cloud instance to come up.
# Usage   : wait_for_instance <cloud_instance_name>
# *****************************************************************************
function wait_for_instance() {
  local INSTANCE_NAME=$1
  for i in `seq 1 60`;
    do
      echo "Trying to ssh to ${INSTANCE_NAME} Iteration [$i]"
      gcloud compute -q ssh ${USER}@${INSTANCE_NAME} --ssh-flag='-t' --ssh-flag="-o ServerAliveInterval=5" --command "ls" >> /tmp/build_image.2.log 2>&1  && break
      sleep 1
    done
}

# *****************************************************************************
# Purpose : Check whether ssh server is up and running.
# Usage   : wait_for_instance <cloud_instance_name>
# *****************************************************************************
function check_ssh_server_status() {
  local INSTANCE_NAME=$1

  echo "check if ssh server is up and running"
  if [ -z "$SSH_AUTH_SOCK" ] ; then
    echo "running ssh-add"
    eval `ssh-agent -s`
    ssh-add
  fi

  for i in `seq 1 60`;
    do
      echo "Trying to ssh to ${DOCK_NAME} Iteration [$i]"
      gcloud compute -q ssh  ${USER}@${INSTANCE_NAME} --ssh-flag='-tA' --ssh-flag="-o ServerAliveInterval=5" --command "ssh -t  -o StrictHostKeyChecking=no plumgrid@\`cat local_docker_ip\` ls" >> /tmp/build_image.3.log  2>&1 && break
      sleep 1
    done
}

# *****************************************************************************
# Purpose : Run docker container inside given instance
# *****************************************************************************
function run_dock_container() {
  local INSTANCE_NAME=$1
  local DOCK_NAME=$2
  local DOCK_ID_FILE=$3
  local DOCK_IP_FILE=$4

  run_cmd_gci ${INSTANCE_NAME} "DID=\$(sudo docker run  --cap-add=all  --cap-add=SYS_ADMIN \
    --lxc-conf='lxc.aa_profile=unconfined' --privileged -d ${DOCK_NAME} /home/plumgrid/startup.sh) && \
    echo \$DID > ${DOCK_ID_FILE} && \
    sudo docker inspect --format '{{ .NetworkSettings.IPAddress }}' \$DID > ${DOCK_IP_FILE}"
}

# *****************************************************************************
# Purpose : Configure docker according to PG requirements.
# *****************************************************************************
function configure_docker() {
  local INSTANCE_NAME=$1

  run_cmd_gci ${INSTANCE_NAME} "echo 'DOCKER_OPTS=\"--mtu 1400 --insecure-registry pg-docker-repo:5000\"' | sudo tee /etc/default/docker && sudo service docker restart"
}

function setup_forwarding() {
  local INSTANCE_NAME=$1

  run_cmd_gci ${INSTANCE_NAME} "echo 'host *' > ~/.ssh/config; echo '    ForwardAgent yes'>>~/.ssh/config"
}

# *****************************************************************************
# Purpose : ADD key to authroized keys of docker container running on instance
# Usage   :
# KEY_PATH:       KEY path on cloud insctance machine.
# DOCKER_ID_FILE: File which holds the docker id on instance
# TODO: Not tested much
# *****************************************************************************
function add_to_dock_authorized_keys() {
  local INSTANCE_NAME=$1
  local KEY_PATH=$2
  local DOCK_ID_FILE=$3

  run_cmd_gci ${INSTANCE_NAME} "sudo su -c \"cat ${KEY_PATH} >> \
    /var/lib/docker/btrfs/subvolumes/\`cat ${DOCK_ID_FILE}\`/home/plumgrid/.ssh/authorized_keys\""
}

# *****************************************************************************
# Function: get_lastest_snapshot_id
# Purpose : Lists the snapshot with the highest time stamp.
# Usage   : get_lastest_snapshot_id
# *****************************************************************************
function get_latest_snapshot_id() {
  #The snapshots are sorted in desencding order by name. Sorting by name also works for numbers.
  local latest_ss=$(gcloud compute snapshots list --sort-by=~NAME --regexp=plumgrid-builder-v1-d1-.* --limit=1 | grep plumgrid-builder-v1-d1- | cut  -d ' ' -f 1)
  local ssid="${latest_ss##*-}"

  echo $ssid
}

# *****************************************************************************
# Function: modify_git_config
# Purpose : Modify the git config inside docker acc to current user in order to
#           checkout/clone commits/repos
# Usage   : modify_git_config <repo_name> <gerrit_id> <write_to_script>
# *****************************************************************************
function modify_git_config() {
  local repo_name=$1
  local gerrit_id=$2
  local write_to_script=$3
  if [[ $# -ne 3 ]]; then
    log "BUG: $# args received by ${FUNCNAME}"
    exit 100
  fi

  echo "cd /home/plumgrid/work/${repo_name}/.git && sed -i \"/url = ssh:/ c\        url = ssh://${gerrit_id}@192.168.10.77:29418/${repo_name}.git\" config" >> ${write_to_script}
}

# *****************************************************************************
# Function: get_latest_logs
# Purpose : Gets the latest test logs from docker in a .tar file.
# Usage   : get_latest_logs
# *****************************************************************************
function get_latest_logs() {
  local INSTANCE_NAME=$1
  echo "Donwloading PG logs to local machine"
  #Get the latest directory created and save it in a file
  run_cmd_docker ${INSTANCE_NAME} "ls /opt/pg/log -rt | tail -1 > latest_log_dir"
  gcloud compute copy-files "${INSTANCE_NAME}:/home/plumgrid/latest_log_dir" /tmp/
  #Extract the directory name from the local file
  log_dir=$(cat /tmp/latest_log_dir | tr -d '\r')
  log_dir_base="/opt/pg/log/$log_dir"
  #tar the directory
  run_cmd_docker ${INSTANCE_NAME} "/bin/bash -c \'tar -cvf ${log_dir_base}.tar ${log_dir_base}/*\'"
  #Copy the tar file to the local machine
  download_from_docker ${INSTANCE_NAME} $log_dir_base.tar /tmp/${INSTANCE_NAME}-logs.tar
  echo "Logs have been placed at /tmp/${INSTANCE_NAME}-logs.tar"
  #Deleting the .tar file
  run_cmd_docker ${INSTANCE_NAME} "/bin/bash -c \'rm $log_dir_base.tar \'"
}

# ******************************************************************************
# Function: run_poll_cmd
# Purpose : Poll the given gcloud command running in the background on the basis
#           of pid to see if the command is completed. On completion, create an
#           empty file in /tmp
# Usage   : run_poll_cmd <cloud_instance_name> <process_to_poll_for> <ssh_flag>
# ******************************************************************************
function run_poll_cmd() {
  local INSTANCE_NAME=$1
  local process=$2
  local SSH_FLAGS=${3:-t}
  local temp_file="/tmp/run_process.txt"
  local local_file=$(mktemp /tmp/poll_gcloud_cmd-XXXXX.sh)

  # Check that the file to be created at the completion of this command does not already exists
  if [ -f ${temp_file} ]; then
    rm ${temp_file}
  fi

  # Create a script that will constantly poll for the running process and exit only when it has ended
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "echo \"Waiting for command to finish \"" >> ${local_file}
  echo "while [[ ! -z \`pidof -x ${process}\` ]]; do echo -n \"..\"; sleep 5; done; echo \"$process completely successfully, exiting\"" >> ${local_file}
  gcloud compute copy-files ${local_file} $USER@${INSTANCE_NAME}:/tmp
  rm ${local_file}
  run_cmd_docker ${INSTANCE_NAME} "'bash -s' < ${local_file}"

}


