#!/bin/bash -e
export PATH=@CMAKE_BINARY_DIR@/:/opt/pg/scripts:$PATH
source aurora_infra_settings.conf
source help.sh

_USER=plumgrid
if [[ -z "${WORKSPACE}" ]]; then
  if [[ ! -d /tmp/logs ]]; then
    mkdir /tmp/logs
  fi
  export WORKSPACE=/tmp
fi
if [[ ! -d "${WORKSPACE}/logs" ]] ; then
  mkdir -p ${WORKSPACE}/logs
fi

function init_id() {
  if [[ $1 == "help" ]] ; then
    show_init_help
    exit 1
  fi
  conf_file="/home/$USER/.aurora.conf"
  echo "Please enter your gerrit id: "
  read gerritid
  echo "gerritid=${gerritid}" > ${conf_file}
  echo "Please enter your plumgrid email: "
  read emailid
  if [[ $emailid =~ ^.*\@plumgrid\.com$ ]];then
    emailid=$(echo "$emailid" | sed 's/@plumgrid.com//')
    echo "emailid=${emailid,,}" >> ${conf_file}
  else
    echo "Wrong email format. Please enter your complete plumgrid.com email"
    exit 1
  fi
  echo "MAX_USER_INSTANCES=15" >> ${conf_file}
  gcloud config set project $GCLOUD_PROJECT
  gcloud config set compute/zone $ZONE
  gcloud config set compute/region $REGION
}

# *****************************************************************************
# Function: run_cmd_gci
# Purpose : Run command on Google Cloud instance.
# Usage   : run_cmd_gci <cloud_instance_ip>
# *****************************************************************************
function run_cmd_gci() {
  local INSTANCE_IP=$1
  local CMD=$2
  local SSH_FLAGS=${3:-t}

  ssh -${SSH_FLAGS} -o UserKnownHostsFile=/dev/null -o CheckHostIP=no -o StrictHostKeyChecking=no -o ServerAliveInterval=50 \
  -o ConnectionAttempts=3 -o ServerAliveCountMax=5 ${_USER}@${INSTANCE_IP} "$CMD"
}

# *****************************************************************************
# Function: check_and_start_ssh_agent
# Purpose : check if ssh agent is running, if not start it and add keys to it
# Usage   : check_and_start_ssh_agent
# *****************************************************************************
function check_and_start_ssh_agent() {
  PFOUND="0"
  # start a new agent only if the agent env variables are not
  # available, or if the agent is not around for whatever reason
  [[ -n "$SSH_AUTH_SOCK" && -n "$SSH_AGENT_PID" ]] && kill -0 "$SSH_AGENT_PID" &>/dev/null && PFOUND="1"

  if [[ "$PFOUND" == "0" ]] ; then
    echo "running ssh-add"
    eval `ssh-agent -s`
  fi
  # always refresh the keys in case they where timedout
  PFOUND="0"
  if [[ -f ${HOME}/.ssh/jenkins-slave-gerrit ]]; then
    ssh-add ${HOME}/.ssh/jenkins-slave-gerrit && PFOUND="1"
  else
    ssh-add && PFOUND="1"
  fi
  if [[ "$PFOUND" == "0" ]] ; then
      # if ssh add failed
      # Re star the ssh agent and re-add the keys
      eval `ssh-agent -k`
      echo "Restarting ssh-add"
      eval `ssh-agent -s`
      if [[ -f ${HOME}/.ssh/jenkins-slave-gerrit ]]; then
        ssh-add ${HOME}/.ssh/jenkins-slave-gerrit
      else
        ssh-add
      fi
  fi
  echo "Currently represented identities:"
  ssh-add -l
}

# *****************************************************************************
# Function: run_cmd_gci_sshforwarding
# Purpose : Run command on Google Cloud instance with ssh forwarding.
# Usage   : run_cmd_gci_sshforwarding <cloud_instance_ip>
# *****************************************************************************
function run_cmd_gci_sshforwarding() {
  local INSTANCE_IP=$1
  local CMD=$2

  check_and_start_ssh_agent
  run_cmd_gci ${INSTANCE_IP} "${CMD}" tA
}

# *****************************************************************************
# Function: run_cmd_gci_bg
# Purpose : Run a command on instance in background
# Usage   : run_cmd<Instance Name>
# *****************************************************************************
function run_cmd_gci_bg() {
  local INSTANCE_IP=$1
  local CMD=$2
  local LOG_FILE=$3

  ssh -t  -o UserKnownHostsFile=/dev/null -o CheckHostIP=no -o StrictHostKeyChecking=no -o ServerAliveInterval=50 \
  -o ConnectionAttempts=3 -o ServerAliveCountMax=5 ${_USER}@${INSTANCE_IP}  "nohup bash -c '${CMD} > ${LOG_FILE} 2>&1 &'"
}

# *****************************************************************************
# Function: push_local_changes
# Purpose : Pushes the specified local changes
# Usage   : push_local_changes
# Prereq: Aurora init has been called.
# *****************************************************************************
function push_local_changes() {
  local INSTANCE_IP=$1
  local COMMIT_ID=$2
  local ALPS_PATH=$3

  cd $ALPS_PATH
  #Get branch name from commit
  local BRANCH=$(git branch --contains $COMMIT_ID | cut -d ' ' -f 2)
  run_cmd_gci ${INSTANCE_IP} "git config  -f ${INSTANCE_ALPS_PATH}/.git/config receive.denyCurrentBranch ignore"
  local local_file=$(mktemp /tmp/ssh-command-XXXXX)
  echo "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o CheckHostIP=no \$*" > ${local_file}
  #Has to be executable
  chmod +x $local_file
  #Push the changes
  #Checkout the branch
  run_cmd_gci ${INSTANCE_IP} "git --git-dir=${INSTANCE_ALPS_PATH}/.git --work-tree=${INSTANCE_ALPS_PATH} checkout $BRANCH"
  #Need to reset to update the working-tree
  run_cmd_gci ${INSTANCE_IP} "git --git-dir=${INSTANCE_ALPS_PATH}/.git --work-tree=${INSTANCE_ALPS_PATH} reset --hard HEAD"
  cd $ALPS_PATH;GIT_SSH="${local_file}" git push -f plumgrid@${INSTANCE_IP}:${INSTANCE_ALPS_PATH} $COMMIT_ID:$BRANCH
  run_cmd_gci ${INSTANCE_IP} "git --git-dir=${INSTANCE_ALPS_PATH}/.git --work-tree=${INSTANCE_ALPS_PATH} reset --hard"
  rm ${local_file}
}

# *****************************************************************************
# Function: checkout_existing_commit
# Purpose : Checkout specific existing commit.
# Usage   : checkout_existing_commit existing_commit_hash
# *****************************************************************************
function checkout_existing_commit() {
  local INSTANCE_IP=$1
  local EXISTING_COMMIT_HASH=$2
  local LOG_FILE=$3

  local local_file=$(mktemp /$WORKSPACE/checkout_existing_commit_XXXXX)
  local file_name=$(basename ${local_file})
  local instance_file=/tmp/checkout_existing_commit.sh

  cat >> ${local_file} <<DELIM__
    #!/bin/bash -e
    . /opt/pg/env/alps.bashrc
    cd /home/plumgrid/work/alps/
    git checkout $EXISTING_COMMIT_HASH
    rm -rf /opt/pg/bin/*
    rm -rf /opt/pg/systest/*
    git clean -fdx
    mkdir build
    cd build
    export PATH="/usr/lib/ccache/:\${PATH}"
    cmake ..
    make -j4 install
DELIM__

  tryexec upload ${INSTANCE_IP}  ${local_file} /tmp
  tryexec run_cmd_gci ${INSTANCE_IP} "mv /tmp/$file_name ${instance_file}"
  tryexec run_bg_cmd ${INSTANCE_IP} "${instance_file}" "/bin/bash ${instance_file}" "$LOG_FILE"
  rm ${local_file}
}

# *****************************************************************************
# Function: get_build_info
# Purpose : Get build description of the run
# Usage   : get_build_info INSTANCE_IP PROJECT_NAME
# *****************************************************************************
function get_build_info() {
  local INSTANCE_IP=$1
  local project=$2
  local local_file=$(mktemp /$WORKSPACE/get_build_info_XXXXX)
  local file_name=$(basename ${local_file})

  cat >> ${local_file} <<DELIM__
  #!/bin/bash -e
  cd /home/plumgrid/work/$project/
  # Print the build-info about the current run
  headrev="\$(git rev-parse HEAD)"
  headrev_short="\${headrev:0:8}"
  logmsg="\$(git show HEAD --format='format:%s' | head -1)"
  if [[ \${#logmsg} -gt 40 ]] ; then
    # truncate the logmsg if it is too long
    logmsg="\${logmsg:0:37}..."
  fi
  headauthor="\$(git show HEAD --format='format:%an' | head -1)"

  echo "JENKINS_BUILD_DESCRIPTION_TEXT: \${headrev_short} by \${headauthor}: \${logmsg}"
DELIM__

  tryexec upload ${INSTANCE_IP} ${local_file} /tmp
  run_cmd_gci ${INSTANCE_IP} "/bin/bash /tmp/${file_name}"
  rm ${local_file}
}

# *****************************************************************************
# Function: wait_for_instance
# Purpose : Wait Cloud instance to come up.
# Usage   : wait_for_instance <cloud_instance_ip>
# *****************************************************************************
function wait_for_instance() {
  local INSTANCE_IP=$1
  local RESULT=1
  for i in `seq 1 60`;
    do
      echo "Trying to ssh to ${INSTANCE_NAME} Iteration [$i]"
      run_cmd_gci ${INSTANCE_IP} "exit" 2>&1  && RESULT=0 && break
      sleep 1
    done
  return $RESULT
}

# *****************************************************************************
# Function: get_lastest_snapshot_id
# Purpose : Lists the snapshot with the highest time stamp.
# Usage   : get_lastest_snapshot_id
# *****************************************************************************
function get_latest_snapshot_id() {
  #The snapshots are sorted in desencding order by name. Sorting by name also works for numbers.
  local ssid=""
  local success=0
  #Retry to be safe
  for i in `seq 1 5`;do
    latest_ss=$(gcloud compute snapshots list --sort-by=~NAME --regexp=${PRIM_INST_NAME}-d1-.* --limit=1 | grep ${PRIM_INST_NAME}-d1- | cut  -d ' ' -f 1)
    ssid="${latest_ss##*-}"
	#Break if non empty
    if [[ -n $ssid ]]; then
      success=1
      break;
    fi
  done
  #Exit if retries failed.
  if [[ $success -eq 0 ]]; then
    echo "Snapshot not found. Exiting" >&2
    return 1
  fi

  echo $ssid
}

# *****************************************************************************
# Function: get_instance_ip
# Purpose : Gets the internal IP address of the instance.
# Usage   : get_instance_ip <instance name>
# *****************************************************************************
function get_instance_ip() {
  local INSTANCE_NAME=$1
  local internal_ip=""
  local success=0
  #Retry to be safe
  for i in `seq 1 5`; do
    internal_ip=$(gcloud compute instances list ${INSTANCE_NAME} --zones=${ZONE} | grep ${INSTANCE_NAME})
    internal_ip=$(echo "$internal_ip" | awk '{ print $4}')
    #Break if non-empty
    if [[ -n $internal_ip ]];then
      success=1
      break
    fi
  done
  #Exit if retries failed
  if [[ $success -eq 0 ]]; then
    echo "Instance IP not found. Please check if the instance $INSTANCE_NAME is running. Exiting."  >&2
    exit 1
  fi

  echo $internal_ip
}

# *****************************************************************************
# Function: is_valid_commit_hash
# Purpose : Check whether provided commit hash is valid or not.
# Usage   : get_instance_ip <instance name>
# Return  : Return 1 in case of valid commit hash. Retrun 0 otherwise.
# *****************************************************************************
is_valid_commit_hash() {
  local ALPS_PATH=$1
  local COMMIT_HASH=$2

  local commit_check=$(git --git-dir $ALPS_PATH/.git --work-tree $ALPS_PATH cat-file -t $COMMIT_HASH)
  if [[ $commit_check != "commit" ]]; then
    echo "Not a valid commit. Please enter a valid commit."
    local VALID_COMMIT_HASH="false"
  else
    local VALID_COMMIT_HASH="true"
  fi
  echo $VALID_COMMIT_HASH
}

# *****************************************************************************
# Function: modify_git_config
# Purpose : Modify the git config
#           checkout/clone commits/repos
# Usage   : modify_git_config <repo_name> <gerrit_id> <write_to_script>
# *****************************************************************************
function modify_git_config() {
  local repo_name=$1
  local gerrit_id=$2
  local write_to_script=$3
  if [[ $# -ne 3 ]]; then
    log "BUG: $# args received by ${FUNCNAME}"
    exit 100
  fi

  echo "cd /home/${_USER}/work/${repo_name}/.git && sed -i \"/url = ssh:/ c\        url = ssh://${gerrit_id}@192.168.10.77:29418/${repo_name}.git\" config" >> ${write_to_script}
}

# *****************************************************************************
# Function: get_latest_logs
# Purpose : Gets the latest test logs from in a .tar file.
#           User might run several tests in on the instance, the funtion gets
#           only the latest results.
# Usage   : get_latest_logs
# *****************************************************************************
function get_latest_logs() {
  local instance_ip=$1
  local instance_name=$2
  local source_dir=$3
  local dest_dir=$4

  local local_file=$(mktemp $WORKSPACE/collect_log-XXXXX)
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "ls -rtd ${source_dir}/*/ | tail -1 > /tmp/latest_log_dir" >> ${local_file}
  echo "LOG_FNAME=\$(cat /tmp/latest_log_dir |cut -d '/' -f 5)" >> ${local_file}
  echo "tar -zcf /tmp/\${LOG_FNAME}.tar \`cat /tmp/latest_log_dir\`" >> ${local_file}
  echo "echo \${LOG_FNAME} > /tmp/latest_log_filename"  >> ${local_file}
  local file_name=/tmp/$(basename ${local_file})
  upload ${instance_ip} ${local_file} ${file_name}
  rm ${local_file}
  run_cmd_gci ${instance_ip} "bash ${file_name}"
  download ${instance_ip} /tmp/latest_log_filename ${dest_dir}/latest_log_filename
  local log_tar=$(cat ${dest_dir}/latest_log_filename)
  download ${instance_ip} /tmp/${log_tar}.tar ${dest_dir}/${instance_name}-logs.tar
  echo "Logs have been placed at ${dest_dir}/${instance_name}-logs.tar"
}

# ******************************************************************************
# Function: run_poll_cmd
# Purpose : Poll the given gcloud command running in the background on the basis
#           of pid to see if the command is completed. On completion, create an
#           empty file in /tmp
# Usage   : run_poll_cmd <cloud_instance_ip> <process_to_poll_for> <check for failure>
# ******************************************************************************
function run_poll_cmd() {
  local INSTANCE_IP=$1
  local process=$2
  local LOG_FILE=$3
  local ERROR_CHECK=$4
  local local_file=$(mktemp $WORKSPACE/poll_gcloud_cmd-XXXXX)

  # Create a script that will constantly poll for the running process and exit only when it has ended
  cat /dev/null > ${local_file}
  echo "#!/bin/bash" >> ${local_file}
  echo "echo \"Waiting for command to finish ... (Log will be tailed below) \"" >> ${local_file}
  echo "tail -n +1 -f $LOG_FILE &" >> ${local_file}
  echo "while [[ ! -z \`pgrep -f ${process}\` ]]; do sleep 5; done;" >> ${local_file}
  echo "pkill tail" >> ${local_file}

  # If error checking is enabled checking for the return value of the script.
  if [ $ERROR_CHECK -eq 1 ]; then
    echo "return_value=\$(tail -1 $LOG_FILE)" >> ${local_file}
    #The last line contains the return value of the script.
    echo "if [[ \$return_value == \"Return Value=0\" ]]; then" >> ${local_file}
    echo "echo \"$process completely successfully, exiting\"" >> ${local_file}
    #Any value other than zero means either the script did not complete or encountered an error
    echo "else echo \"$process did not complete successfully, exiting\"" >> ${local_file}
    echo "exit 1" >> ${local_file}
    echo "fi" >> ${local_file}
  else
    #Exit true if no error checking is enabled
    echo "echo \"$process completely successfully, exiting\"" >> ${local_file}
  fi
  local instance_file=/tmp/$(basename ${local_file})
  tryexec upload ${INSTANCE_IP} ${local_file} ${instance_file}
  rm ${local_file}
  tryexec run_cmd_gci ${INSTANCE_IP} "bash ${instance_file}"
}
# ******************************************************************************
# Function: run_bg_cmd
# Purpose : Takes a script located on the and appends the return value checking
#           to the script. The script is then run in the background
# Usage   : run_bg_cmd <cloud_instance_ip> <path to file> <command to run> <log file>
# ******************************************************************************
function run_bg_cmd() {
  local INSTANCE_IP=$1
  local file=$2
  local CMD=$3
  local LOG_FILE=$4
  #Append error checking to the file.
  tryexec run_cmd_gci ${INSTANCE_IP} "sed -i '$ a\retval=\\\$?' ${file}"
  tryexec run_cmd_gci ${INSTANCE_IP} "sed -i '$ a\echo' ${file}"
  tryexec run_cmd_gci ${INSTANCE_IP} "sed -i '$ a\echo \"Return Value=\$retval\"\' ${file}"
  #Run the command in the background
  tryexec run_cmd_gci_bg ${INSTANCE_IP} "$CMD" "$LOG_FILE"

}
# ******************************************************************************
# Function: make_install_alps
# Purpose : Creates a script for building alps, uploads and runs the script
#           on the instance. The return value for the install is echoed to
#           check for failure.
# Usage   : make_install_alps <cloud_instance_ip> <log file>
# ******************************************************************************
function make_install_alps() {
  local INSTANCE_IP=$1
  local LOG_FILE=$2
  local local_file=$(mktemp $WORKSPACE/make_install_alps-XXXXX)
  cat /dev/null > ${local_file}
  echo "cd /home/plumgrid/work/alps/;" >> ${local_file}
  echo "rm -rf /opt/pg/bin/*" >> ${local_file}
  echo "rm -rf /opt/pg/systest/*" >> ${local_file}
  echo "git clean -fdx" >> ${local_file}
  echo "mkdir build" >> ${local_file}
  echo "cd build" >> ${local_file}
  echo "source /opt/pg/env/alps.bashrc" >> ${local_file}
  echo "export PATH=\"/usr/lib/ccache/:\${PATH}\"" >> ${local_file}
  echo "cmake ..;" >> ${local_file}
  echo "make -j4 install" >> ${local_file}
  #File name needs to be constant for continue functionality, thus renaming.
  local instance_file=/tmp/$(basename $local_file)
  local renamed_file=/tmp/make_install_alps.sh
  tryexec upload ${INSTANCE_IP} ${local_file} ${instance_file}
  tryexec run_cmd_gci ${INSTANCE_IP} "mv ${instance_file} ${renamed_file}"
  rm ${local_file}
  tryexec run_bg_cmd ${INSTANCE_IP} "${renamed_file}" "/bin/bash ${renamed_file}" "$LOG_FILE"
}

# ******************************************************************************
# Function: make_tools_iovisor
# Purpose : Creates a script which makes and installs tools and iovisor, uploads
#           and runs the script.The return value for the script is echoed to
#           check for failure.
# Usage   : make_tools_iovisor <cloud_instance_ip> <log file>
# ******************************************************************************
function make_tools_iovisor() {
  local INSTANCE_IP=$1
  local LOG_FILE=$2
  local local_file=$(mktemp $WORKSPACE/make_tools_iovisor.sh-XXXXX)
  cat /dev/null > ${local_file}
  cat >> ${local_file} <<DELIM__
cd /home/plumgrid/work/tools/build
export PATH="/usr/lib/ccache/:\${PATH}"
cmake ..
sudo make test_packages
sudo make packages
make -C packages install
make -j4 install
cd /home/plumgrid/work/iovisor/bld
make -j4 -k
sudo make install
DELIM__
  #File name needs to be constant for continue functionality, thus renaming.
  local instance_file=/tmp/$(basename ${local_file})
  local renamed_file=/tmp/make_tools_iovisor.sh
  tryexec upload ${INSTANCE_IP}  ${local_file} ${instance_file}
  tryexec run_cmd_gci ${INSTANCE_IP} "mv ${instance_file} ${renamed_file}"
  rm ${local_file}
  tryexec run_bg_cmd ${INSTANCE_IP} "${renamed_file}" "/bin/bash ${renamed_file}" "$LOG_FILE"
}
# ******************************************************************************
# Function: check_elfsurgeon
# Purpose : Creates a script which makes alps, checks the elfsurgeon files, uploads
#           and runs the script.The return value for the script is echoed to
#           check for failure.
# Usage   : check_elfsurgeon <cloud_instance_ip> <log file>
# ******************************************************************************
function check_elfsurgeon() {
  local INSTANCE_IP=$1
  local LOG_FILE=$2
  local local_file=$(mktemp $WORKSPACE/check_elfsurgeon-XXXXX)
  cat /dev/null > ${local_file}
  cat >> ${local_file} <<DELIM__
cd /home/plumgrid/work/alps/build
make -j4
elfsurgeon_files=\$(git status --porcelain | grep 'common/elfsurgeon/dependency_hist' | wc -l)
if [[ "\$elfsurgeon_files" != "0" ]]; then
git status --porcelain | grep 'common/elfsurgeon/dependency_hist'
echo "\${elfsurgeon_files} ELFsurgeon history files were not updated:"
exit 1; fi
DELIM__
  #File name needs to be constant for continue functionality, thus renaming.
  local instance_file=/tmp/$(basename ${local_file})
  local renamed_file=/tmp/check_elfsurgeon.sh
  tryexec upload ${INSTANCE_IP}  ${local_file} ${instance_file}
  tryexec run_cmd_gci ${INSTANCE_IP} "mv ${instance_file} ${renamed_file}"
  rm ${local_file}
  tryexec run_bg_cmd ${INSTANCE_IP} "${renamed_file}" "/bin/bash ${renamed_file}" "$LOG_FILE"
}

# *****************************************************************************
# Function: exec_gcloud_instances
# Purpose : Wrapper for gcloud instances commands, retries the command if an error is encountered.
# Usage   : exec_gcloud_instances <operation> <name> <options>
# *****************************************************************************
function exec_gcloud_instances() {
  local operation=$1
  local name=$2
  local options=${@:3}

  case $operation in
    create)
      # Check if the instance already exists
      gcloud compute instances list ${name} --zones $ZONE | grep -q "${name}" || retval=$?
      if [ $retval -eq 0 ]; then
        echo "Instance:$name already exists."
        return 1
      fi
      ;;
    delete)
        # Check if the instance is already deleted
        gcloud compute instances list ${name} --zones $ZONE | grep -q "${name}" || retval=$?
        if [ $retval -ne 0 ]; then
          echo "Instance:$name does not exist."
          return 1
        fi
      ;;
    *)
      echo "Operation:$operation on Entity:Instances is invalid, Exiting"
      return 1
  esac

  for i in `seq 1 5`;
  do
    echo "Try-$i: gcloud compute instances $operation $name $options"
    # Execute the command.
    retval=0
    gcloud compute instances $operation $name $options || retval=$?
    if [ $retval -eq 0 ]; then
      return 0;
    fi

    for j in `seq 1 15`;
    do
      retval=0
      case $operation in
        create)
          gcloud compute instances list $name | grep "${name}" | grep "RUNNING" || retval=$?
          if [ $retval -eq 0 ]; then
            success=1
            break
          fi
          ;;
        delete)
          gcloud compute instances list $name | grep "${name}" || retval=$?
          if [ $retval -ne 0 ]; then
            success=1
            break
          fi
          ;;
      esac
      sleep 5
    done
    if [ ${success} -eq 1 ]; then
      echo "SUCCESS"
      return 0
    fi
    sleep 30
  done
  return 1
}
# *****************************************************************************
# Function: exec_gcloud_snapshots
# Purpose : Wrapper for gcloud snapshots commands, retries the command if an error is encountered.
# Usage   : exec_gcloud_snapshots <operation> <name> <options>
# *****************************************************************************
function exec_gcloud_snapshots() {
  local operation=$1
  local name=$2
  local options=${@:3}
  case $operation in
  delete)
    # Check if the snapshot is already deleted
    gcloud compute snapshots list ${name} | grep -q "${name}" || retval=$?
    if [ $retval -ne 0 ]; then
      echo "Snapshot:$name does not exist."
      return 1
    fi
    ;;
  *)
    echo "Operation:$operation on Entity:snapshot is invalid, Exiting"
    return 1
  esac

  for i in `seq 1 5`;
  do
    echo "Try-$i: gcloud compute snapshot $operation $name $options"
    # Execute the command.
    retval=0
    gcloud compute snapshots $operation $name $options || retval=$?
    if [ $retval -eq 0 ]; then
      return 0;
    fi

    for j in `seq 1 15`;
    do
      echo "$j: Checking if $operation snapshots:$name succeeded"
      retval=0

      gcloud compute snapshots list $name | grep "${name}" || retval=$?
      if [ $retval -ne 0 ]; then
        success=1
        break
      fi
    sleep 5
    done
    if [ ${success} -eq 1 ]; then
      echo "SUCCESS"
      return 0
    fi
    sleep 30
  done
  return 1
}
# *****************************************************************************
# Function: exec_gcloud_disks
# Purpose : Wrapper for gcloud disks commands, retries the command if an error is encountered.
# Usage   : exec_gcloud_disks <operation> <name> <options>
# *****************************************************************************
function exec_gcloud_disks() {
  local operation=$1
  local name=$2
  local options=${@:3}
  case $operation in
    create)
      # Check if disk already exists
      gcloud compute disks list ${name} --zones $ZONE | grep -q "${name}" || retval=$?
      if [ $retval -eq 0 ]; then
        echo "Disk:$name already exists."
        return 1
      fi
      ;;
    delete)
      # Check if disk already deleted
      gcloud compute disks list ${name} --zones $ZONE | grep -q "${name}" || retval=$?
      if [ $retval -ne 0 ]; then
        echo "Disk:$name does not exist."
        return 1
      fi
      ;;
    snapshot)
      local snapshot_name=$4
      # Check if disk already deleted
      gcloud compute snapshots list ${snapshot_name} | grep -q "${snapshot_name}" || retval=$?
      if [ $retval -eq 0 ]; then
        echo "Snapshot:$snapshot_name already exists."
        return 1
      fi
      ;;
    *)
      echo "Operation:$operation on Entity:disks is invalid, Exiting"
      return 1
  esac

  for i in `seq 1 5`;
  do
    echo "Try-$i: gcloud compute disks $operation $name $options"
    # Execute the command.
    retval=0
    gcloud compute disks $operation $name $options || retval=$?
    if [ $retval -eq 0 ]; then
      return 0;
    fi

    for j in `seq 1 15`;
    do
      echo "$j: Checking if $operation disks:$name succeeded"
      retval=0
      case $operation in
        create)
          gcloud compute disks list $name | grep "${name}" | grep "READY" || retval=$?
          if [ $retval -eq 0 ]; then
            success=1
            break
          fi
          ;;
        delete)
          gcloud compute disks list $name | grep "${name}" || retval=$?
          if [ $retval -ne 0 ]; then
            success=1
            break
          fi
          ;;
        snapshot)
          gcloud compute snapshots list $snapshot_name | grep "${snapshot_name}" | grep "READY" || retval=$?
          if [ $retval -eq 0 ]; then
            success=1
            break
          fi
          ;;
      esac
      sleep 5
    done
    if [ ${success} -eq 1 ]; then
      echo "SUCCESS"
      return 0
    fi
    sleep 30
  done
  return 1
}

# *****************************************************************************
# Function: exec_gcloud_cmd
# Purpose : Wrapper for gcloud commands, retries the command if an error is encountered.
# Usage   : exec_gcloud_cmd <entity> <operation> <name> <options>
# *****************************************************************************
function exec_gcloud_cmd {
  local entity=$1
  local operation=$2
  local name=$3
  local options=${@:4}
  local retval=0
  local success=0
  #Check if the operation is valid on the entity
  case $entity in
    disks)
      exec_gcloud_disks $operation $name $options
      ;;
    instances)
      exec_gcloud_instances $operation $name $options
      ;;
    snapshots)
      exec_gcloud_snapshots $operation $name $options
      ;;
  *)
    echo "Entity:$entity is invalid. Exiting"
    return 1
  esac

}

# *****************************************************************************
# Function: cleanup
# Purpose : Cleans up the instances/disks/snapshots in case of failure.
# Usage   : cleanup
# Prereq  :
# *****************************************************************************
function cleanup() {
  #Need to disable exit on error because some commands might fail.
  set +e
  #delete everything while ignoring errors.
  gcloud compute instances delete ${INSTANCE_NAME} -q --delete-disks all
  gcloud compute disks delete ${INSTANCE_NAME}-d1 -q
  gcloud compute disks delete ${INSTANCE_NAME}-d2 -q
  gcloud compute snapshots delete ${INSTANCE_NAME}-ssd1 -q
  gcloud compute snapshots delete ${INSTANCE_NAME}-ssd2 -q
  #Enable error checknig again.
  set -e
}

# *****************************************************************************
# Function: tryexec
# Purpose : Try to execute a command. If the command returns success, this
#           function returns 0. Otherwise, the script is aborted with the status
#           code of the failed command.
# Usage   : tryexec <command>
# Prereq  :
# *****************************************************************************
function tryexec() {
  local retval=0;
  "$@" || retval=$?
  [[ $retval -eq 0 ]] && return 0

  echo 'A command has failed:'
  echo "  $@"
  echo "Value returned: ${retval}"
  echo "$(basename $0) Failed, do you want to cleanup the instances?"
  read -r -p "Are you sure you want to continue? (y/N)" response
    response=${response,,}    # tolower
    if [[ $response =~ ^(yes|y)$ ]]; then
      echo "Proceeding with cleanup..."
      cleanup
      exit $retval
    else
      exit $retval
    fi
}

# *****************************************************************************
# Function: retryexec
# Purpose : Try to execute a command. If the command returns success, this
#           function returns 0. Otherwise, the script retries for a while. If
#           it still fails, its then aborted with the status code of the failed
#           command.
# Usage   : retryexec <command>
# Prereq  :
# *****************************************************************************
function retryexec() {
  retry=1
  until [[ $retry == "10" ]]
  do
     echo "Try $retry for command "
     echo "  $@"
     local retval=0;
     "$@" || retval=$?
     if [[ $retval == "0" ]]; then
       break
     fi
     let retry++
     if [[ $retry == "10" ]]; then
       echo "Command $@ failed"
       echo "$(basename $0) Failed, do you want to cleanup the instances?"
       read -r -p "Are you sure you want to continue? (y/N)" response
       response=${response,,}    # tolower
       if [[ $response =~ ^(yes|y)$ ]]; then
         echo "Proceeding with cleanup..."
         cleanup
         exit 1
       else
         exit 1
       fi
     fi
     echo "Command $@ Failed on try $retry : Will try again, restarting ssh-agent before retrying"
     eval `ssh-agent -k`
  done
}

# *****************************************************************************
# Function: check_file_existence
# Purpose : Checks if the file exists.
# Usage   : check_file_existence <Path with filename>
# Prereq  :
# *****************************************************************************
function check_file_existence() {
  if [ ! -f "$1" ] ; then
    echo "$1 does not exist!"
    exit 1
  fi
}
# *****************************************************************************
# Function: check_build_inputs
# Purpose : Checks if the inputs provided to aurora build are correct.
# Usage   : check_build_inputs <PROJECT> <REFSPEC> <BRANCH>
# Prereq  :
# *****************************************************************************
function check_build_inputs() {
  local INSTANCE_NAME=$1
  local PROJECT=$2
  local REFSPEC=$3
  local BRANCH=$4
  local RESULT=1

  #Check instance name length
  #GCE allows a maximum of 62 characters for disks and instances.
  #16 characters are appended when the instance a run instance is created.
  #Leaving a room for 20 characters for run in case it is changed later.
  if [ ${#INSTANCE_NAME} -gt "42" ]; then
    echo "Instance name is too long, try a shorter TAG, exiting."
    exit 1
  fi

  #Check project name
  local project_list=$(ssh -p ${GERRIT_PORT} ${gerritid}@${GERRIT_IP} gerrit ls-projects)
  for project_name in ${project_list}; do
    if [[ $project_name =~ $PROJECT ]]; then
      RESULT=0
      break
    fi
  done
  if [[ $RESULT -eq 1 ]]; then
    echo "Invalid project name: ${PROJECT}"
    show_build_help
    exit 1
  fi
  if [[ "$REFSPEC" != "none" ]]; then
    #Check if refespec exists for the project
    git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/${PROJECT} "${REFSPEC}" | grep "${REFSPEC}" || RESULT=$?
    if [[ $RESULT -ne 0 ]];then
      echo "Refspec: $REFSPEC does not exist for the project: ${PROJECT}"
      show_build_help
      exit 1
    fi
  fi
  #Check if branch exists
  git ls-remote ssh://${gerritid}@${GERRIT_IP}:${GERRIT_PORT}/${PROJECT} "${BRANCH}" | grep -q "${BRANCH}" || RESULT=$?
    if [[ $RESULT -ne 0 ]];then
    echo "Branch: $BRANCH does not exist for the project: ${PROJECT}"
    show_build_help
    exit 1
  fi
}
# *****************************************************************************
# Function: check_run_inputs
# Purpose : Checks if the inputs provided to aurora run are correct.
# Usage   : check_run_inputs <BUILDID>
# Prereq  :
# *****************************************************************************
function check_run_inputs() {
  local BUILDID=$1
  local RESULT

  gcloud compute snapshots list ${BUILDID}-ssd1 | grep "${BUILDID}-ssd1" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Snapshot ${BUILDID}-ssd1 does not exist, wrong Build-ID"
    show_run_help
    exit 1
  fi

  gcloud compute snapshots list ${BUILDID}-ssd2 | grep "${BUILDID}-ssd2" || RESULT=$?
  if [[ $RESULT -ne 0 ]];then
    echo "Snapshot ${BUILDID}-ssd2 does not exist, wrong Build-ID"
    show_run_help
    exit 1
  fi
}

function record_step() {
  local step=$1
  local step_file=$2
  echo $step > ${step_file}
}

# ***********************************************************************************
# Function: upload
# Purpose : Upload a file/folder from your local machine to cloud instance
# Usage   : upload <Cloud instance IP>
#                  <Local file which needs to be uploaded>
#                  <path to destination directory>
# Test function by giving relative path.
# ***********************************************************************************
function upload() {
  local INSTANCE_IP=$1
  local FILE=$2
  local DESTINATION=$3

  echo "** $INSTANCE_NAME $FILE $DESTINATION **"
  scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o CheckHostIP=no -r $FILE "${_USER}@${INSTANCE_IP}:${DESTINATION}"
}

# *****************************************************************************
# Function: download
# Purpose : Download a file/folder from cloud instance to your local machine.
# Usage   : download <Cloud instance IP>
#                    <Location of file which needs to be downloaded>
#                    <Local machine's path where you need to download>
# *****************************************************************************
function download() {
  local INSTANCE_IP=$1
  local FILE=$2
  local DESTINATION=$3

  scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o CheckHostIP=no -r "${_USER}@${INSTANCE_IP}:$FILE" ${DESTINATION}
}

# *****************************************************************************
# Function: check_instance_limit
# Purpose : Checks if the number of currently running is less than the MAX number of
#           instances allowed.
# Usage   : check_instance_limit
# Prereq  : aurora init has been called
# *****************************************************************************
function check_instance_limit() {
  local CURRENT_INSTANCES=$(gcloud compute instances list --regexp "${emailid}-.*" --zones $ZONE | grep "${emailid}-" | wc -l)
  #Check against max instances allowed.
  if [[ $CURRENT_INSTANCES -lt $MAX_USER_INSTANCES ]]; then
    return 0
  else
    echo "Currently running instances (${CURRENT_INSTANCES}) for user:${emailid} exceeds maximum allowed (${MAX_USER_INSTANCES})"
    echo "Please delete existing instances to continue."
    exit 1
  fi
}

# *****************************************************************************
# Function: print_time_taken
# Purpose : Prints the time duration between two intervals in HH:MM:SS format
# Usage   : print_time_taken <start time> <end time> <step>
# *****************************************************************************
function print_time_taken() {
  local start_time=$1
  local end_time=$2
  local step=$3
  local time_diff=$(( ${end_time}- ${start_time} ))
  printf "Total Time taken in ${step}: %02d:%02d:%02d\n" "$(( time_diff/3600 ))" "$(( (time_diff%3600)/60 ))" "$(( time_diff%60 ))"
}

# *****************************************************************************
# Function: commit_test_against
# Purpose : Use the Test-against feature in the gerrit commit to fetch code
#           from another repository (the current code is dependent on)
# Usage   : commit_test_against
# *****************************************************************************
function commit_test_against() {
  # Try to parse the commit message, if any
  # This environment variable is set automatically by Jenkins on a gerrit-based event
  if [[ -n "${GERRIT_CHANGE_COMMIT_MESSAGE}" ]]; then
    local commit_msg=$(echo "${GERRIT_CHANGE_COMMIT_MESSAGE}" | base64 -d -i)
    # extract the last paragraph
    local line_of_last_newline=$(echo "${commit_msg}" | awk '/^$/{line=NR;} END{if(line!="")print line}')
    if [[ -n "${line_of_last_newline}" ]]; then
      commit_msg=$(echo "${commit_msg}" | awk "{if(NR>${line_of_last_newline})print}")
    fi

    if [[ -n "${commit_msg}" ]]; then
      # if something is left to parse, check whether we have branch translations
      local matching_lines=$(echo "${commit_msg}" | grep "^Test-against: ")
      local no_matching_lines=$(echo "${matching_lines}" | wc -l)
      if [[ "${no_matching_lines}" -gt 1 ]]; then
        # likely user error, fail loudly
        echo "Too many lines (${no_matching_lines}) for pattern 'Test-against: ' inside the commit message"
        echo "Too many lines (${no_matching_lines}) for pattern 'Test-against: ' inside the commit message. Not supported.." >> "${WORKSPACE}/status-message.log"
        exit 1
      fi

      # actually grab the translation and print it
      local matched_translation=$(echo "${matching_lines}" | sed "s/Test-against: //" | cut -f 1 -d' ')
      if [[ -n "${matched_translation}" ]]; then
        echo "${matched_translation}"
        return 0
      fi
      # else just be silent in the usual case: that is, a commit
      # message is present, but provides no branch translation
    else
      exit 1
    fi
  else
    return 0
  fi
}

# *****************************************************************************
# Function: abbrev_to_repository
# Purpose : Translate exactly one "Test-against"-compliant abbreviation to the full repository name
# Usage   : abbrev_to_repository
# *****************************************************************************
function abbrev_to_repository() {
  read line
  case "$line" in
    alps)
      echo "alps"
      ;;
    pgcli)
      echo "pg_cli"
      ;;
    pglib)
      echo "python-plumgridlib"
      ;;
    pgui)
      echo "pg_ui"
      ;;
    pkg)
      echo "pkg"
      ;;
    sal)
      echo "sal"
      ;;
    *)
      echo "$line"
      ;;
  esac
  return 0
}
